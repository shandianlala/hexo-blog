{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":0,"renderable":1},{"_id":"source/assets/img/avatar.jpg","path":"assets/img/avatar.jpg","modified":0,"renderable":0},{"_id":"source/assets/img/favicon.ico","path":"assets/img/favicon.ico","modified":0,"renderable":0},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"source/assets/img/alipay.jpg","path":"assets/img/alipay.jpg","modified":0,"renderable":0},{"_id":"source/assets/img/wechat.png","path":"assets/img/wechat.png","modified":0,"renderable":0},{"_id":"source/assets/img/article/动态规划表.jpg","path":"assets/img/article/动态规划表.jpg","modified":0,"renderable":0},{"_id":"source/assets/img/article/最长子序列方程.jpg","path":"assets/img/article/最长子序列方程.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/404.html","hash":"8ea68cffb49d7110f3037246a3e579dfa58f48b7","modified":1512003010000},{"_id":"source/CNAME","hash":"eb147ce5f6dc85703409a224b56e1755b1a7ad60","modified":1511321176000},{"_id":"themes/yilia/.babelrc","hash":"db600d40e93e6d8023737a65d58d3be7370e5e30","modified":1511321588000},{"_id":"themes/yilia/.editorconfig","hash":"daaa8757fac18f8735fadd0a37a42c06f421ca14","modified":1511321588000},{"_id":"themes/yilia/.eslintignore","hash":"ed9d8911ca08c3dd5072c48dd0be4d06f8897730","modified":1511321588000},{"_id":"themes/yilia/.eslintrc.js","hash":"303d25adf02ad65720e537a16a4a137d14bb755f","modified":1511321588000},{"_id":"themes/yilia/.gitattributes","hash":"758cfbecfa7919e99abddf3297f37cde7e3d8d4e","modified":1511321588000},{"_id":"themes/yilia/.gitignore","hash":"d5fc575329853ff620b50fc62ad4b18fa09a308a","modified":1511321588000},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1511321588000},{"_id":"themes/yilia/_config.yml","hash":"3e89dc5b236362e0ce32961b78c96161967ce86d","modified":1573577755692},{"_id":"themes/yilia/package.json","hash":"ee6aa61f1cb89fd549e3e087c0232207a9c9ee30","modified":1511321588000},{"_id":"themes/yilia/webpack.config.js","hash":"da7657347109ddb4ab8602b219778117254677fe","modified":1511321588000},{"_id":"source/_posts/17年除夕的前一天.md","hash":"4d223dc953b5f7be8b9c8ebf62dfa57f232ccb12","modified":1519392826940},{"_id":"source/_posts/IntelliJ-IDEA访问不到web项目的图片.md","hash":"ab0264ff936d7210b803c57ae711aa40d035cd9f","modified":1513259728000},{"_id":"source/_posts/Java内存区域与内存溢出异常.md","hash":"1c2f4ee5418e7e250bf8a2b5ba5330e9fba13641","modified":1537628539141},{"_id":"source/_posts/MarkDown写文章的几个常用命令.md","hash":"0026d6aa014ec11d52fd5ead89a0ec405979481d","modified":1513259728000},{"_id":"source/_posts/RPC服务框架Dubbo.md","hash":"3ba8435ee172cf89649c528bf95720aa4e32bce1","modified":1513759426000},{"_id":"source/_posts/Regular-Expression-Matching.md","hash":"70a3dd7c2cf81935d317d6979688cac7a1c3e0d5","modified":1513259728000},{"_id":"source/_posts/ThreadLocal理解.md","hash":"c808fb1726dc3fb2296091ad176897b8c62e30f2","modified":1562470411557},{"_id":"source/_posts/Thread类阅读笔记.md","hash":"ff755edb8e9b3dc98eed1d64f3585488a119a703","modified":1513259728000},{"_id":"source/_posts/Try-Your-Best.md","hash":"ffe98ab662b88fcec3d4da14fe4f5a931497f670","modified":1573575052044},{"_id":"source/_posts/ZooKeeper的使用及其原理.md","hash":"b08127170d68a0cc1666656177c7bac924100ba4","modified":1555167428094},{"_id":"source/_posts/git命令介绍.md","hash":"4be2fbbb54f6bb2ae0f3b06dc5d8a9d1dcea5d0f","modified":1515681950339},{"_id":"source/_posts/hello-world.md","hash":"2b32ecc2679ade63a7a99c5a6db4131e2472e43c","modified":1514638281265},{"_id":"source/_posts/hexo博客安装教程.md","hash":"c34f4aa09d14a6da09fbb2429c47f147a562a9d0","modified":1514899055753},{"_id":"source/_posts/hexo博客更换电脑后配置教程.md","hash":"191f1164530bebc723b6ce7cd511157a14338a5c","modified":1514903172149},{"_id":"source/_posts/hexo的yilia主题配置地址收藏.md","hash":"5bd41c33a98d153ce3b69983d1d4d1433ffcc284","modified":1513301310000},{"_id":"source/_posts/http请求接口数据乱码.md","hash":"898bf95328c86389a40bcb245ed4d67b08b5b45e","modified":1513259728000},{"_id":"source/_posts/java-web项目中设置session会话超时的时间.md","hash":"f8c9fb37260d34db838fc761751b6e6ccaf2dc66","modified":1513644250000},{"_id":"source/_posts/mybatis官方文档.md","hash":"99b4c1a6651e306f62baa280f1bc2af5950f4006","modified":1527039462097},{"_id":"source/_posts/shiro验证框架.md","hash":"26133ee5348ab185e45f2cfb41b4c4aca7aa3069","modified":1527038792832},{"_id":"source/_posts/《维京：王者之战》观影感.md","hash":"96977204016111612202e2321abd59686730e08f","modified":1513259728000},{"_id":"source/_posts/你好，武汉.md","hash":"15219c50c0b4efa45008a72057f0ae5fbb686ba8","modified":1513259728000},{"_id":"source/_posts/你应该知道的JAVA面试题.md","hash":"e79da25c5d2b4da1fb2f3a66386a523b43c362b0","modified":1513259728000},{"_id":"source/_posts/使用Nginx和Tomcat来搭建高性能负载均衡集群.md","hash":"eb232b72bb0431800fc2ae058ef78eb55a33f8ff","modified":1519355268736},{"_id":"source/_posts/在Linux环境下部署java-web项目.md","hash":"a1edc717c3baab6cce2e9a4b64029226d5aca211","modified":1514189532000},{"_id":"source/_posts/常用单词汇集.md","hash":"9f1e4c5bbb2b9c929bbfb9498b9a8af988a2d846","modified":1515679103880},{"_id":"source/_posts/理解分析HashMap的数据结构.md","hash":"148cd9a619ef4a7380b9a4b9eb3fb95f08760ceb","modified":1513259728000},{"_id":"source/_posts/由求最长回文数的引发的思考.md","hash":"3c8118e83eb8e3b1ece2ca7d7384d7b79c2c4249","modified":1560954580386},{"_id":"source/_posts/突如起来的阿里巴巴的面试电话.md","hash":"eb74ae23ecdc9cbe45f2fcd1f35af23bb577cbd5","modified":1521817929116},{"_id":"source/_posts/致那些年我读过的英才.md","hash":"28b55108ea1c960b595e0f11bb5d388512f81a7c","modified":1513259728000},{"_id":"source/_posts/记毕业第一个月.md","hash":"4be72369da5a944950f6b29997d3a516a631e225","modified":1513259728000},{"_id":"source/_posts/配置zookeeper的dubbo-admin管理平台.md","hash":"8c2c9eb38542db4183055c00f290eb17b8f552e9","modified":1513259728000},{"_id":"themes/yilia/.git/FETCH_HEAD","hash":"1efc9d034adf6456e816fcbb20023807ca64bbd0","modified":1511321650000},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1511321588000},{"_id":"themes/yilia/.git/ORIG_HEAD","hash":"4ed77da1a2617db0e77c3e3e190a1c79c16dfb9a","modified":1511321650000},{"_id":"themes/yilia/.git/config","hash":"24300cece9d72967ea63724bdb2a8e3c2ac2cc52","modified":1511321588000},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1511321568000},{"_id":"themes/yilia/.git/index","hash":"503088e0e8427f0ce268757125a35d4e958ef5d5","modified":1511321588000},{"_id":"themes/yilia/.git/packed-refs","hash":"83644c3638dafa38c817265c9207f098dd8aeee6","modified":1511321588000},{"_id":"themes/yilia/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1511321588000},{"_id":"themes/yilia/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1511321588000},{"_id":"themes/yilia/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1511321588000},{"_id":"themes/yilia/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1511321588000},{"_id":"themes/yilia/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1511321588000},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1511321588000},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1511321588000},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1511321588000},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1511321588000},{"_id":"themes/yilia/layout/index.ejs","hash":"ec498c6c0606acde997ce195dad97b267418d980","modified":1511321588000},{"_id":"themes/yilia/layout/layout.ejs","hash":"b471ab706d48e0be3f783eab1c94bf5878ef5a94","modified":1511321588000},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1511321588000},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1511321588000},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1511321588000},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"bb9c0b299469f6a38de18948d8c523c39b10da58","modified":1514448308000},{"_id":"themes/yilia/source/slider.e37972.js","hash":"ce5eac88301fe4f2fce0fb6203adfd58eb8313ac","modified":1511321588000},{"_id":"themes/yilia/source-src/css.ejs","hash":"cf7eab48d626433120d1ef9697f719a359817018","modified":1511321588000},{"_id":"themes/yilia/source-src/script.ejs","hash":"28abac2426761d7e715b38aadd86ce6549c8ae77","modified":1511321588000},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1511321588000},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"283ae27ea37ac3e0e45b2e05c2482a4c594b9c25","modified":1511321588000},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"1801ef448909ea23c0a48e9d63b80d0cfd5534ce","modified":1511321588000},{"_id":"source/assets/img/avatar.jpg","hash":"e14b3fb5b5be8bec84d6847550203c2f4e0ab649","modified":1511356304000},{"_id":"source/assets/img/favicon.ico","hash":"4773ff0aa29716afe2247194944f4bea895e2f25","modified":1500429484000},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"86b9655a9ebbde13ac8dd5795eb4d5b539edab0f","modified":1511321568000},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1511321568000},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1511321568000},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"42fa41564917b44183a50c4d94bb03e1768ddad8","modified":1511321568000},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1511321568000},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"b4ad74c989616b7395dc6c9fce9871bb1e86dfb5","modified":1511321568000},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1511321568000},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1511321568000},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"39355a075977d05708ef74e1b66d09a36e486df1","modified":1511321568000},{"_id":"themes/yilia/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1511321568000},{"_id":"themes/yilia/.git/logs/HEAD","hash":"34055ceab85fb6524b6d8dcee27c5c0b3473af55","modified":1511321588000},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"c70f367f54064a441e574c913f5e0ea121d0f899","modified":1511321588000},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1511321588000},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"edc0154b30a4127acda10297bec6aacf754b4ac4","modified":1511321588000},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"dce88361b657c78d32ae13dbb9c135c5c0271892","modified":1573577372234},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"751e5deab5365348be5243688b419c82d337ab9a","modified":1511321588000},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"155327c23607f69989b58845f24d842a54e504b8","modified":1511321588000},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1511321588000},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"cc17d7f1f6f7e317e5945e83944a62076d96397a","modified":1514516826000},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1511321588000},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"58d25514048088e7f6da71a3e3d2bbd441d3cf34","modified":1514514478000},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1511321588000},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"eedf23875eda21abf63850edc9609da0d852aacd","modified":1514211248000},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"11550a418921d330e6553be0569a94ab5a217967","modified":1511321588000},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"ccec1fc70f021cb50ac85b524e7949878ab93a18","modified":1511321588000},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c4e7d5912fdfa9c536cd3aa556b5304badf6aa7c","modified":1514210574000},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"cc1c39903aed0a0601d104238d2bbd13ad2a36f3","modified":1511321588000},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1511321588000},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1511321588000},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1511321588000},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1511321588000},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1511321588000},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1511321588000},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1511321588000},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1511321588000},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1511321588000},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"29ba600e98ed55f7af4ade8038272c84cba21188","modified":1511321588000},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"ce227b6f5a9af194fd5d455200630f32c05e151f","modified":1511321588000},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"d6a7dd88404b383b5b94e4c7ec675a410c41f3cc","modified":1511321588000},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"f7388f5c11370ef462f7cb913d8f72edf24ecaf9","modified":1511321588000},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"1577a2336b3ad122f49f60dff2bc1a97d4e7b18b","modified":1511321588000},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"8f82fe898ba1c1bd00c24a7d8270feddc7eba3bc","modified":1511321588000},{"_id":"themes/yilia/source-src/css/article.scss","hash":"55d082fec4c6bb341725567acaa29ce37d50320a","modified":1511321588000},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"07244c188f58ecfb90bb7c047b8cde977f1dc4b4","modified":1511321588000},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"ec1dc9aaf531b286e91b88e69ccc1ff3d4a8abe3","modified":1573577270326},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"96d7eb1d42c06fdcccb8ef969f6ecd30c3194903","modified":1511321588000},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1511321588000},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1511321588000},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"f53ea8270752b5919ec5d79224d22af91f2eda12","modified":1511321588000},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"40e5aa5056dc0b3b9f51c5b387370b612e265d4e","modified":1511321588000},{"_id":"themes/yilia/source-src/css/left.scss","hash":"80dac621e43581a254d0152d5df901e4d0b01c09","modified":1511321588000},{"_id":"themes/yilia/source-src/css/main.scss","hash":"9eba1fcf4805256697528fcf3b767cf6dd8d0591","modified":1511321588000},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"19f10fd2f0c3377aa4b165b3c2291ecf86dd9351","modified":1511321588000},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"d995dcd483a250fe61b426158afb61bf8923a927","modified":1511321588000},{"_id":"themes/yilia/source-src/css/page.scss","hash":"244c4d75c375978ff9edb74acc68825e63c6b235","modified":1511321588000},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"a557a9ed244c82b8b71e9da9de3339d92783499f","modified":1511321588000},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"2495f7e4e3b055735c531f944b5f40a118a351ec","modified":1511321588000},{"_id":"themes/yilia/source-src/css/share.scss","hash":"9d6f6884f40c191882e56a1e1e1192400944a515","modified":1511321588000},{"_id":"themes/yilia/source-src/css/social.scss","hash":"a10a038a1dac8953cb4ffc7e04272eff9fac54e4","modified":1511321588000},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"399744e98e7c67939ed9b23c2670d8baad044eda","modified":1511321588000},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"915c93edd67c5326695cc7dc84b14c5f154dbcc8","modified":1511321588000},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"2924fb6f77c4a9973cd928c2c7db0acb848ed483","modified":1511321588000},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"b81cedbe31accca82e597801186911a7b5e6841c","modified":1511321588000},{"_id":"themes/yilia/source-src/js/Q.js","hash":"e56d9710afa79b31ca6b9fbd845f6d1895f5214b","modified":1511321588000},{"_id":"themes/yilia/source-src/js/anm.js","hash":"d18f6276a352b871390a4112d479b9e58b8cdbbe","modified":1511321588000},{"_id":"themes/yilia/source-src/js/aside.js","hash":"5e4c3c3d61f1e1ce2f09688d3aff25fadc851fff","modified":1511321588000},{"_id":"themes/yilia/source-src/js/browser.js","hash":"4dc04845cf27f350922b63f1813a9c82e6e33b05","modified":1511321588000},{"_id":"themes/yilia/source-src/js/fix.js","hash":"67b8819abb886c9d066fb3b0624ca15e06f63fe0","modified":1511321588000},{"_id":"themes/yilia/source-src/js/main.js","hash":"fe98bf90ce61658fe16ae057f8b6a512a845af3b","modified":1511321588000},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"461c08ffcbc724d74ec7e0ff38e171eefe0f89fd","modified":1511321588000},{"_id":"themes/yilia/source-src/js/report.js","hash":"57680f9a23bd0a1eaafd64ae08cc33e20627ab15","modified":1511321588000},{"_id":"themes/yilia/source-src/js/share.js","hash":"d4ccff8266c37363b3904226f5d035b7db882c61","modified":1511321588000},{"_id":"themes/yilia/source-src/js/slider.js","hash":"0beaa112657ad57c723d9e773d5b79de60c1dd74","modified":1511321588000},{"_id":"themes/yilia/source-src/js/util.js","hash":"3bcdeb95072b85600874424e6929e3e22cfddaa0","modified":1511321588000},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"c699cf3c89409ec8f044258e0715a470861b5d5d","modified":1511321588000},{"_id":"source/assets/img/alipay.jpg","hash":"9e440c47cf988f441d973435ba0356e15d8b0aa0","modified":1511358060000},{"_id":"source/assets/img/wechat.png","hash":"173531cd735b07fef5b3899878d6c78343d9a3ea","modified":1511358746000},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"e98ec0b3b56f14d1d79af99ceb42727719a584f3","modified":1511321588000},{"_id":"source/assets/img/article/动态规划表.jpg","hash":"88813e3fa289849c92e81194c8f1f95acc7c8321","modified":1502442520000},{"_id":"source/assets/img/article/最长子序列方程.jpg","hash":"76b7ac208adbb21257538fcecbc99d71efc4156d","modified":1502442584000},{"_id":"themes/yilia/.git/objects/pack/pack-f5b98643f034bb4e9b894e20180a72487ca9e2d1.idx","hash":"1c0e45fc4d9e332a9402007e8456e6a609360549","modified":1511321588000},{"_id":"themes/yilia/.git/refs/heads/master","hash":"4ed77da1a2617db0e77c3e3e190a1c79c16dfb9a","modified":1511321588000},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"e777cbf959b11c4dfda649c562799899b90ab4a3","modified":1511321588000},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"086c8a88fd3bcae7ec13258df58e25d6354af2fa","modified":1511321588000},{"_id":"themes/yilia/layout/_partial/post/codingment.ejs","hash":"9293f5c1fcb9c65649527f3459d7852fcc7ccdf0","modified":1512119622000},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"aae96de18d48cd3b9b7bf6fed0100e15b53cca97","modified":1511321588000},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"f6b4c4eaafb5ac386273354b5f64a26139b7a3b0","modified":1511321588000},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"25655016773aa5d0774c56115ae1736a9fc9ea1f","modified":1512119574000},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"b6a97043f9ec37e571aacacfedcda1d4d75e3c7c","modified":1511321588000},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"345b262e3c3b75c0cd9a93d9ecabcf06e33e54ff","modified":1511321588000},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2c4e4ca36c9bb4318506c38aca7127f1f44d827f","modified":1511321588000},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1511321588000},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"fb022502c741b4a26bad6b2ad37245c10ede3f1a","modified":1511321588000},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"1834c3ed8560716e63bb3a50be94cac87fbbeaf3","modified":1511321588000},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"262ffcd88775080b7f511db37f58d2bcb1b2bfc7","modified":1511321588000},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"91db061c9c17628291a005e5bd4936cf9d35a6c4","modified":1511321588000},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"6e75bdaa46de83094ba0873099c6e7d656a22453","modified":1511321588000},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"398a49913b4a47d928103562b1ce94520be4026a","modified":1511321588000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1511321588000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1511321588000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1511321588000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1511321588000},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1511321588000},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1511321588000},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1511321588000},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"34055ceab85fb6524b6d8dcee27c5c0b3473af55","modified":1511321588000},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1511321588000},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"34055ceab85fb6524b6d8dcee27c5c0b3473af55","modified":1511321588000},{"_id":"themes/yilia/.git/objects/pack/pack-f5b98643f034bb4e9b894e20180a72487ca9e2d1.pack","hash":"6f384e0e882033b8e7fb95a8923e06001501b25b","modified":1511321588000},{"_id":"public/baidu_urls.txt","hash":"6adec5c62ee0d1fb046a18372ba486e50f8f6e0f","modified":1573575126559},{"_id":"public/baidusitemap.xml","hash":"cbf7c082b95fd358118fb6e150d50be2728512fe","modified":1573575126734},{"_id":"public/content.json","hash":"781081e83ace697fb2e08a01c2ed4fee5ac5f1b4","modified":1573575126747},{"_id":"public/sitemap.xml","hash":"a3ed5677593c05467c03c562c385a51b78af0720","modified":1573575126747},{"_id":"public/404.html","hash":"c825165cb411c94e9a901478686aa7e5e0b0484b","modified":1573577903637},{"_id":"public/blogs/21a25d7a-zookeeper-use-principle/index.html","hash":"704c79270663f770ad7267d18ebe47239609b7bb","modified":1573577903640},{"_id":"public/blogs/21b75e70-mybatis-official-document/index.html","hash":"d7d18186b1c614459767cda01f9129aebba7d807","modified":1573577903640},{"_id":"public/blogs/21b75d7a-memory-overflow-exception/index.html","hash":"564ae3ce83214565a77354ac0d670ef321de0568","modified":1573577903640},{"_id":"public/blogs/63e54bd-Try-Your-Best/index.html","hash":"2adbfb1dececf40b80bfe2f2370ef28f5d35b911","modified":1573577903638},{"_id":"public/blogs/362db54f-ThreadLocal/index.html","hash":"f9f21d31f3acd60ff9589a167a92a12d16805a97","modified":1573577903639},{"_id":"public/blogs/b7aae4ad-the day before 17 New Year's Eve/index.html","hash":"9f666f7fe86441a42c533c903e0967c080e9d5a8","modified":1573577903642},{"_id":"public/blogs/61afe343-shiro-authority-frame/index.html","hash":"1680ccaff3d0f7a99b1252e632d54beaa94eb68d","modified":1573577903641},{"_id":"public/blogs/c95fe668/index.html","hash":"103a5eb5eac4597f815f2996f567e48d5e0808dd","modified":1573577903641},{"_id":"public/blogs/b7aae4ad-nginx-tomcat-cluster/index.html","hash":"c34668aaa796f37f45481d3efa3c0c205290a62e","modified":1573577903642},{"_id":"public/blogs/e95b6d7d/index.html","hash":"9d77d3da3b7965263fda458230f4a18ceec74a3f","modified":1573577903644},{"_id":"public/blogs/b7aae4ad/index.html","hash":"2bbb1d138cd386a0a923248d9428d674b4911c42","modified":1573577903644},{"_id":"public/blogs/fda57de0/index.html","hash":"85ff6c4cf3e6ca99ed885ff224e9d3dd6d1b9a69","modified":1573577903645},{"_id":"public/blogs/d54218b1/index.html","hash":"4d8cca304ecd1a5632fdca45a83ceca7924155d7","modified":1573577903645},{"_id":"public/blogs/5220878b-git-command-introduction/index.html","hash":"851601d853b8de2f1bae4757b25383fd90d50185","modified":1573577903643},{"_id":"public/blogs/739343a9/index.html","hash":"64c2327c4f91f1c0be62392c5ddd2504b7489064","modified":1573577903645},{"_id":"public/blogs/b9e89015/index.html","hash":"6dba5b0d45e6a27a3ec4420e9c8eeb01907d7607","modified":1573577903646},{"_id":"public/blogs/9c02c64f/index.html","hash":"33db5d47a8dd0e103f6bfb22b6d2ae733d6817a0","modified":1573577903646},{"_id":"public/blogs/10818c5d/index.html","hash":"df10f9dac93e092432953653b55ece630dba5c2a","modified":1573577903646},{"_id":"public/blogs/aef118f4/index.html","hash":"09381c7af3c551c2f5d5ecb1d3e013aff2b627ed","modified":1573577903647},{"_id":"public/blogs/cb6878a2/index.html","hash":"21a1c6a2590038c78b306ef5b03560a38072a115","modified":1573577903647},{"_id":"public/blogs/d46124c7/index.html","hash":"7bd1b99d4b0f109643bbde397caa9e2ab4ca6c60","modified":1573577903648},{"_id":"public/blogs/fac581d3-hexo-install/index.html","hash":"ac6f633f9fb95289c2a317f1afa8f7031e1fe510","modified":1573577903643},{"_id":"public/blogs/cc0e19bd/index.html","hash":"ef624161b74f411e93b0b99f7519e5c12531cd2c","modified":1573577903649},{"_id":"public/blogs/37159b1b/index.html","hash":"c572ca55134b04641f8fc3df15baf27edf851b8a","modified":1573577903649},{"_id":"public/blogs/922954aa/index.html","hash":"2da70694728d120c8886fbeda059a3f458b77841","modified":1573577903647},{"_id":"public/blogs/162a7fa0/index.html","hash":"d02d05a4b303d1279b9ae74b009114402f9b6c71","modified":1573577903650},{"_id":"public/blogs/702042b3/index.html","hash":"1a9f27f98354450ab0da2de2b3e03f7a8d1e41ef","modified":1573577903650},{"_id":"public/blogs/12d63093/index.html","hash":"530a0e4fc2aab4c84d9dfa3d3fd45bd20f974dec","modified":1573577903651},{"_id":"public/archives/index.html","hash":"7640f5a55345721f59d9e80c1952b9fd4644a651","modified":1573575131694},{"_id":"public/blogs/99f8ffac-hexo-blog-change-computer-teach/index.html","hash":"1c465a97f48740a3206dc2c4ee61e32828cdf4ce","modified":1573577903643},{"_id":"public/blogs/7e219bde/index.html","hash":"90b6d47a60ab1556a2f92c7657eb5fe7e5b32fe8","modified":1573577903648},{"_id":"public/archives/2012/index.html","hash":"7731432ced4fab22abde1ddf8e8f5ee765a5d19f","modified":1573575131695},{"_id":"public/archives/2012/06/index.html","hash":"ec8d5ea761e45971abdc8ebbf5ada73c224b22d8","modified":1573575131696},{"_id":"public/archives/2017/index.html","hash":"ba697c1ed3faf8d878fb3fad971a231957ca4436","modified":1573575131697},{"_id":"public/archives/2017/page/2/index.html","hash":"c0f66b26559683597c7717102d9f5a1395e27b53","modified":1573575131697},{"_id":"public/archives/2017/08/index.html","hash":"5c2575c3e5765ca4a89602a931e511b150a7903e","modified":1573575131697},{"_id":"public/archives/2017/11/index.html","hash":"ae329c5355af0d3fe542c1099a48fa784555c231","modified":1573575131698},{"_id":"public/archives/2017/12/index.html","hash":"d5542d2eb5b91341ee58354caaa355ed678955b7","modified":1573575131698},{"_id":"public/archives/page/3/index.html","hash":"4218c7ed3304e365cbeda583f9ca2bf5b190cae1","modified":1573575131698},{"_id":"public/archives/2018/index.html","hash":"7a1bc9629627bbe9601e8e925ec0461e1a352242","modified":1573575131699},{"_id":"public/archives/2017/12/page/2/index.html","hash":"ebb0a81cd664284ff8008b381cebe40defa0ead0","modified":1573575131699},{"_id":"public/archives/2018/01/index.html","hash":"48633f98bea85c1d1e2d5f200ac37078ba23190c","modified":1573575131700},{"_id":"public/archives/2018/03/index.html","hash":"1bbb85defbf2542560788c6117242ee72ba45149","modified":1573575131701},{"_id":"public/archives/page/2/index.html","hash":"8f2fd7e9aa951d2b3a77781b666330ccd27bcf32","modified":1573575131701},{"_id":"public/archives/2018/09/index.html","hash":"c318f055baca2972da9eac388b35afd9dad9cd8d","modified":1573575131702},{"_id":"public/archives/2019/index.html","hash":"cc42a17e38ac758d9c6004e4fd6f171b94ed6dc5","modified":1573575131706},{"_id":"public/blogs/4a17b156/index.html","hash":"0587a223201a6465040bcfa0f3b437563edfb68e","modified":1573577903649},{"_id":"public/archives/2019/06/index.html","hash":"ef254e243a52c8ffbb0645088960fe6fb0a80b9f","modified":1573575131707},{"_id":"public/archives/2018/02/index.html","hash":"47973e5816a8410d62ce4fd1a35c5b225717754a","modified":1573575131708},{"_id":"public/archives/2018/04/index.html","hash":"75017e053bcf1530ac582607d220168afca7707c","modified":1573575131708},{"_id":"public/archives/2019/04/index.html","hash":"897c89e0aeb8211528cfba3db22cc43a67096f3a","modified":1573575131708},{"_id":"public/index.html","hash":"fdbdfccdd6ce050d0d4ab9978f886e29a80edaf9","modified":1573575131710},{"_id":"public/page/2/index.html","hash":"56f2dfd228a254bdafc3ca2b230c4488ca38f1c1","modified":1573575131710},{"_id":"public/tags/IntelliJ-IDEA/index.html","hash":"dc34c3e8f4b7b7aa81ddbc291edab778e7b6a313","modified":1573575131710},{"_id":"public/tags/配置/index.html","hash":"cb84078ac711effe1bd2dd4ecaf3642b3ea5ad9d","modified":1573575131711},{"_id":"public/tags/MarkDown命令/index.html","hash":"d2bd850afc6a7ce855711d7f35493928cbd129eb","modified":1573575131711},{"_id":"public/tags/JAVA/index.html","hash":"ee1c4da89239f6daa4affb73dbffdd83ea8a3460","modified":1573575131711},{"_id":"public/tags/JAVA/page/2/index.html","hash":"f2b9ea429550cef455b7b81e6161c818f71d7cf6","modified":1573575131712},{"_id":"public/page/3/index.html","hash":"2fd1e4c98da7b86c9a0cae716fc8b057aa644519","modified":1573575131712},{"_id":"public/tags/java虚拟机/index.html","hash":"075a8435b495e79aa63256c72cef1362692583d9","modified":1573575131712},{"_id":"public/tags/dubbo/index.html","hash":"a093788d4a2364c14ea6e82d207f412bc28f516f","modified":1573575131713},{"_id":"public/tags/框架/index.html","hash":"a967cf013327ff94c4d1a889ffd29d28b6abef93","modified":1573575131713},{"_id":"public/tags/jdk源码/index.html","hash":"8e338abddc313aaabfb12351242dc10d47ee70bf","modified":1573575131713},{"_id":"public/tags/算法/index.html","hash":"3b8adf09e76d8fba76b394de1f3d842ef856e1ac","modified":1573575131714},{"_id":"public/tags/教程/index.html","hash":"589530703b7d16b81e31940d83239dcf506c256e","modified":1573575131714},{"_id":"public/tags/hexo博客配置/index.html","hash":"b6d6483ba5fff7c84b7971e0c01acf9a5c8c8d7c","modified":1573575131715},{"_id":"public/tags/乱码/index.html","hash":"250e65b4783421787128e6393c7b2ffdb2268f3a","modified":1573575131715},{"_id":"public/tags/HTTP/index.html","hash":"955c421d90b46a636843c0f6b83c50a10164957c","modified":1573575131715},{"_id":"public/tags/mybatis/index.html","hash":"c61a878f39552a9f9840be6d95cdff67bc405604","modified":1573575131716},{"_id":"public/tags/shiro/index.html","hash":"3fb6688543416b923776133ac5c7374443b562fd","modified":1573575131716},{"_id":"public/tags/电影/index.html","hash":"6970e1831cb136006f5962e02ee04c210eccbcc0","modified":1573575131716},{"_id":"public/tags/面试/index.html","hash":"d19ee6a1e37547517fa43b76b9ce720c7a39d67b","modified":1573575131717},{"_id":"public/tags/nginx/index.html","hash":"7e799a9ea2acb8da4753b5fbae412a436a6ed607","modified":1573575131717},{"_id":"public/tags/ZooKeeper/index.html","hash":"6e3ab62b24411f346ec3b0d64b7d8aae997bc7f9","modified":1573575131717},{"_id":"public/tags/Linux/index.html","hash":"e47cc06e47d0943ecfc9a7d49e47231a5e2df4df","modified":1573575131718},{"_id":"public/tags/单词/index.html","hash":"d1c76238a9b33ec8b447074bd817cecec68cda0d","modified":1573575131718},{"_id":"public/tags/数据结构/index.html","hash":"b60c5a1d000d0074083dac7ecf8f5785c491ab19","modified":1573575131718},{"_id":"public/tags/数据结构算法/index.html","hash":"576db2ff74b75a4435c4b6f344deccf4b0fdd5fe","modified":1573575131719},{"_id":"public/tags/感想/index.html","hash":"ba2725f22424b7e1d65e042f3d13324a27a41e8b","modified":1573575131719},{"_id":"public/tags/zookeeper/index.html","hash":"1de7b5bc23eeea2bcad44c9450b79cdace15135a","modified":1573575131719},{"_id":"public/tags/dubbo-admin/index.html","hash":"b8ccb542bfa9d9284ec2ff9fd8d3fbeccb8238f1","modified":1573575131720},{"_id":"public/tags/web/index.html","hash":"8e9385f86838d8dd0d838b8f247b3b700452ca05","modified":1573575131720},{"_id":"public/tags/Tomcat/index.html","hash":"857015be67dba67e048601910f7c1240bcbf341a","modified":1573575131720},{"_id":"public/tags/生活感想/index.html","hash":"ac67f65e6f679daef7fb002133f4270efa66a0b4","modified":1573575131721},{"_id":"public/archives/page/4/index.html","hash":"d5a221428d4fa71c1fc54f1fc4db577de6b70091","modified":1573575131748},{"_id":"public/archives/2019/11/index.html","hash":"5fbde6739d21955fed2c1f14db3106dc0be43999","modified":1573575131748},{"_id":"public/page/4/index.html","hash":"1a45434436730b709dc4fe5a999ffd5b7d652dd2","modified":1573575131748},{"_id":"public/CNAME","hash":"eb147ce5f6dc85703409a224b56e1755b1a7ad60","modified":1573575131749},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1573575131749},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1573575131749},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1573575131749},{"_id":"public/assets/img/avatar.jpg","hash":"e14b3fb5b5be8bec84d6847550203c2f4e0ab649","modified":1573575131750},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1573575131750},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1573575131750},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1573575131750},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1573575131751},{"_id":"public/assets/img/favicon.ico","hash":"4773ff0aa29716afe2247194944f4bea895e2f25","modified":1573575131751},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1573575131751},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1573575131751},{"_id":"public/assets/img/article/动态规划表.jpg","hash":"88813e3fa289849c92e81194c8f1f95acc7c8321","modified":1573575131751},{"_id":"public/assets/img/article/最长子序列方程.jpg","hash":"76b7ac208adbb21257538fcecbc99d71efc4156d","modified":1573575131752},{"_id":"public/assets/img/alipay.jpg","hash":"9e440c47cf988f441d973435ba0356e15d8b0aa0","modified":1573575131767},{"_id":"public/assets/img/wechat.png","hash":"173531cd735b07fef5b3899878d6c78343d9a3ea","modified":1573575131771},{"_id":"public/main.0cf68a.css","hash":"bb9c0b299469f6a38de18948d8c523c39b10da58","modified":1573575131784},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1573575131784},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1573575131784},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1573575131785},{"_id":"themes/yilia/layout/_partial/post/gittalk.ejs","hash":"032d8d94b3b0eeac492d8d655762dac4ccb8aacd","modified":1573577157856},{"_id":"themes/yilia/layout/_partial/post/gitalk.ejs","hash":"032d8d94b3b0eeac492d8d655762dac4ccb8aacd","modified":1573577157856}],"Category":[],"Data":[],"Page":[{"_content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\t\n\t<meta charset=\"UTF-8\">\t\n\t<title>404</title>\n</head>\n<body>\n\t<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\"></script>\n</body>\n</html>","source":"404.html","raw":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\t\n\t<meta charset=\"UTF-8\">\t\n\t<title>404</title>\n</head>\n<body>\n\t<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\"></script>\n</body>\n</html>","date":"2017-12-30T10:28:36.801Z","updated":"2017-11-30T00:50:10.000Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"ck2w200ob0000mwd30o9jr5sf","content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\t\n\t<meta charset=\"UTF-8\">\t\n\t<title>404</title>\n</head>\n<body>\n\t<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\"></script>\n</body>\n</html>","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\t\n\t<meta charset=\"UTF-8\">\t\n\t<title>404</title>\n</head>\n<body>\n\t<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\"></script>\n</body>\n</html>"}],"Post":[{"title":"17年除夕的前一天","abbrlink":"b7aae4ad-the day before 17 New Year's Eve","date":"2018-02-14T01:23:02.000Z","_content":"\n昨天早上从武汉做的火车回到阳新，<!-- more -->嫂子开着车带着侄子侄女来接，顺道把家里养的豚（番鸭）带到县城的菜场脱毛，避免爸妈自己手工去毛玩弄好久，我自个就在县城逗留了会儿，跑到网吧开了机子，也不知道玩啥，就跟媳妇发了条消息，说我在网吧，跟媳妇一起去吃了KFC,跟着她一起压着马路，下午三点多从阳新回太子。\n\n因为阳新到黄石黄阳公路修通了，大大缩短了时间，筠山隧道的贯通也大大缩短了从我家到县城的距离，侄子昨晚要跟我一起睡，由于我在跟父亲聊天，我就叫他先上去睡，我一会儿就上来。他很听话的就上去了。\n\n早上六点多的时候，感觉到侄子在翻身，我半眯着眼看着他，看到他眼睛挣得圆圆的，我就假装我仍再睡，一会儿后我就问他怎么醒这么早，他的回答尽然把我逗乐了，“你总摸我肚子，然后我就醒了”，哈哈哈。\n\n他心里还挂念着他的玩具，问我什么时候带他去买玩具，他想要一个遥控赛车，喜欢蓝色，我就把淘宝打开了，搜遥控车，他看到其中一个可以变形的赛车很喜欢，说这个好，我仔细看了看觉得还行，跟他说得十来天后才能玩到，他说行，但我没注意到他内心可能有一丝丝的纠结。\n\n他说他不开心的时候喜欢唱歌，听到这我内心感觉到我的小侄子真的在慢慢的长大了。因为青年人不开心的时候也会唱歌跳舞。\n\n他问我的梦想是什么，我惊呆了，这是我侄子问我的问题吗？是的，我没听错，我一时语塞，不知如何回答，回答不能太认真，毕竟他还是一个八岁的孩子可能不能懂，我就说“我的梦想是程文锗认真读书，考个大学”，这个小崽子的成绩单语文45数学72。然后我就问他他的梦想是什么，他说他喜欢唱歌，已经会唱了好多歌了，我问他都会唱哪些歌，他思考了一会没有说话，我意识到可能他不认识歌名的字，就问他，他点了点头，我说那你哼个调调我听下，他又认真想了会儿，笑着对我说一下子想不起来。\n","source":"_posts/17年除夕的前一天.md","raw":"---\ntitle: 17年除夕的前一天\nabbrlink: b7aae4ad-the day before 17 New Year's Eve\ndate: 2018-02-14 09:23:02\ntags: [生活感想]\n---\n\n昨天早上从武汉做的火车回到阳新，<!-- more -->嫂子开着车带着侄子侄女来接，顺道把家里养的豚（番鸭）带到县城的菜场脱毛，避免爸妈自己手工去毛玩弄好久，我自个就在县城逗留了会儿，跑到网吧开了机子，也不知道玩啥，就跟媳妇发了条消息，说我在网吧，跟媳妇一起去吃了KFC,跟着她一起压着马路，下午三点多从阳新回太子。\n\n因为阳新到黄石黄阳公路修通了，大大缩短了时间，筠山隧道的贯通也大大缩短了从我家到县城的距离，侄子昨晚要跟我一起睡，由于我在跟父亲聊天，我就叫他先上去睡，我一会儿就上来。他很听话的就上去了。\n\n早上六点多的时候，感觉到侄子在翻身，我半眯着眼看着他，看到他眼睛挣得圆圆的，我就假装我仍再睡，一会儿后我就问他怎么醒这么早，他的回答尽然把我逗乐了，“你总摸我肚子，然后我就醒了”，哈哈哈。\n\n他心里还挂念着他的玩具，问我什么时候带他去买玩具，他想要一个遥控赛车，喜欢蓝色，我就把淘宝打开了，搜遥控车，他看到其中一个可以变形的赛车很喜欢，说这个好，我仔细看了看觉得还行，跟他说得十来天后才能玩到，他说行，但我没注意到他内心可能有一丝丝的纠结。\n\n他说他不开心的时候喜欢唱歌，听到这我内心感觉到我的小侄子真的在慢慢的长大了。因为青年人不开心的时候也会唱歌跳舞。\n\n他问我的梦想是什么，我惊呆了，这是我侄子问我的问题吗？是的，我没听错，我一时语塞，不知如何回答，回答不能太认真，毕竟他还是一个八岁的孩子可能不能懂，我就说“我的梦想是程文锗认真读书，考个大学”，这个小崽子的成绩单语文45数学72。然后我就问他他的梦想是什么，他说他喜欢唱歌，已经会唱了好多歌了，我问他都会唱哪些歌，他思考了一会没有说话，我意识到可能他不认识歌名的字，就问他，他点了点头，我说那你哼个调调我听下，他又认真想了会儿，笑着对我说一下子想不起来。\n","slug":"17年除夕的前一天","published":1,"updated":"2018-02-23T13:33:46.940Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2w200sl0001mwd3c00on2rj","content":"<p>昨天早上从武汉做的火车回到阳新，<a id=\"more\"></a>嫂子开着车带着侄子侄女来接，顺道把家里养的豚（番鸭）带到县城的菜场脱毛，避免爸妈自己手工去毛玩弄好久，我自个就在县城逗留了会儿，跑到网吧开了机子，也不知道玩啥，就跟媳妇发了条消息，说我在网吧，跟媳妇一起去吃了KFC,跟着她一起压着马路，下午三点多从阳新回太子。</p>\n<p>因为阳新到黄石黄阳公路修通了，大大缩短了时间，筠山隧道的贯通也大大缩短了从我家到县城的距离，侄子昨晚要跟我一起睡，由于我在跟父亲聊天，我就叫他先上去睡，我一会儿就上来。他很听话的就上去了。</p>\n<p>早上六点多的时候，感觉到侄子在翻身，我半眯着眼看着他，看到他眼睛挣得圆圆的，我就假装我仍再睡，一会儿后我就问他怎么醒这么早，他的回答尽然把我逗乐了，“你总摸我肚子，然后我就醒了”，哈哈哈。</p>\n<p>他心里还挂念着他的玩具，问我什么时候带他去买玩具，他想要一个遥控赛车，喜欢蓝色，我就把淘宝打开了，搜遥控车，他看到其中一个可以变形的赛车很喜欢，说这个好，我仔细看了看觉得还行，跟他说得十来天后才能玩到，他说行，但我没注意到他内心可能有一丝丝的纠结。</p>\n<p>他说他不开心的时候喜欢唱歌，听到这我内心感觉到我的小侄子真的在慢慢的长大了。因为青年人不开心的时候也会唱歌跳舞。</p>\n<p>他问我的梦想是什么，我惊呆了，这是我侄子问我的问题吗？是的，我没听错，我一时语塞，不知如何回答，回答不能太认真，毕竟他还是一个八岁的孩子可能不能懂，我就说“我的梦想是程文锗认真读书，考个大学”，这个小崽子的成绩单语文45数学72。然后我就问他他的梦想是什么，他说他喜欢唱歌，已经会唱了好多歌了，我问他都会唱哪些歌，他思考了一会没有说话，我意识到可能他不认识歌名的字，就问他，他点了点头，我说那你哼个调调我听下，他又认真想了会儿，笑着对我说一下子想不起来。</p>\n","site":{"data":{}},"excerpt":"<p>昨天早上从武汉做的火车回到阳新，","more":"嫂子开着车带着侄子侄女来接，顺道把家里养的豚（番鸭）带到县城的菜场脱毛，避免爸妈自己手工去毛玩弄好久，我自个就在县城逗留了会儿，跑到网吧开了机子，也不知道玩啥，就跟媳妇发了条消息，说我在网吧，跟媳妇一起去吃了KFC,跟着她一起压着马路，下午三点多从阳新回太子。</p>\n<p>因为阳新到黄石黄阳公路修通了，大大缩短了时间，筠山隧道的贯通也大大缩短了从我家到县城的距离，侄子昨晚要跟我一起睡，由于我在跟父亲聊天，我就叫他先上去睡，我一会儿就上来。他很听话的就上去了。</p>\n<p>早上六点多的时候，感觉到侄子在翻身，我半眯着眼看着他，看到他眼睛挣得圆圆的，我就假装我仍再睡，一会儿后我就问他怎么醒这么早，他的回答尽然把我逗乐了，“你总摸我肚子，然后我就醒了”，哈哈哈。</p>\n<p>他心里还挂念着他的玩具，问我什么时候带他去买玩具，他想要一个遥控赛车，喜欢蓝色，我就把淘宝打开了，搜遥控车，他看到其中一个可以变形的赛车很喜欢，说这个好，我仔细看了看觉得还行，跟他说得十来天后才能玩到，他说行，但我没注意到他内心可能有一丝丝的纠结。</p>\n<p>他说他不开心的时候喜欢唱歌，听到这我内心感觉到我的小侄子真的在慢慢的长大了。因为青年人不开心的时候也会唱歌跳舞。</p>\n<p>他问我的梦想是什么，我惊呆了，这是我侄子问我的问题吗？是的，我没听错，我一时语塞，不知如何回答，回答不能太认真，毕竟他还是一个八岁的孩子可能不能懂，我就说“我的梦想是程文锗认真读书，考个大学”，这个小崽子的成绩单语文45数学72。然后我就问他他的梦想是什么，他说他喜欢唱歌，已经会唱了好多歌了，我问他都会唱哪些歌，他思考了一会没有说话，我意识到可能他不认识歌名的字，就问他，他点了点头，我说那你哼个调调我听下，他又认真想了会儿，笑着对我说一下子想不起来。</p>"},{"title":"IntelliJ IDEA访问不到web项目的图片","abbrlink":"739343a9","date":"2017-12-06T12:56:03.000Z","_content":"\n> Idea被认为是业界最好的Java开发工具，要使得它乖乖听话，任我摆布，还需要花时间调教调教它。\n\n今天在使用idea维护之前的博客项目的时候，发现原来在eclipse上跑的好好的项目突然在idea上就不好使了，部署的web项目，富文本编辑器的图片上传报错，页面访问不到图片。下面开始我解决问题的整个步骤。\n<!-- more -->\n### 运行项目，控制台打印的日志乱码。\n在tomcat的配置页面中`VM options` 选项中加入\n![](http://ozux0lqfa.bkt.clouddn.com/vmoption.png)\n```\n-Dfile.encoding=UTF-8\n```\n\n### 项目成功跑起来了，但用富文本编辑器上传图片，页面报错。\n- idea中tomcat发布项目的默认路径是项目所在地里的target目录里面。\n我的做法是更改项目发布路径到tomcat目录下的webapps目录下面，下面更改发布路径到tomcat。\n![](http://ozux0lqfa.bkt.clouddn.com/idea_%E4%BF%AE%E6%94%B9%E5%8F%91%E5%B8%83%E8%B7%AF%E5%BE%84%E4%B8%BATomcat%E7%9A%84webapps1.png)\n![](http://ozux0lqfa.bkt.clouddn.com/idea-tomcat%E5%8F%91%E5%B8%83%E7%9B%AE%E5%BD%952.png)\n这样之后，在重新运行项目，项目就会发布到tomcat的webapps目录里。\n\n### 配置图片资源文件\n- **sdll-blog**项目的图片资源目录我是存储在*upload*文件里面，\n![](http://ozux0lqfa.bkt.clouddn.com/idea%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95.png)\n- 现在我需要在idea里面配置upload文件资源。\n![](http://ozux0lqfa.bkt.clouddn.com/idea%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90%E7%9B%AE%E5%BD%951.png)\n**注意：**`Application context`里面的值配置为`/upload`\n\n![](http://ozux0lqfa.bkt.clouddn.com/idea%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90%E7%9B%AE%E5%BD%952.png)\n完成之后，再次运行项目，还是报找不到文件错误，查看控制台打印的日志，发现一个坑，发现在tomcat的安装路径中有部分有空格。文件夹**IDEA SERVER**控制条输出日志空格被解析成**IDEA%2%SERVER**，发现这个问题后，重新配置了个tomcat,重新运行项目，\n- 浏览器访问资源文件\n![](http://ozux0lqfa.bkt.clouddn.com/idea%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AE%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6yes.png)\n- 正常访问upload文件夹里面的图片资源了，富文本编辑器也不报错了哦。","source":"_posts/IntelliJ-IDEA访问不到web项目的图片.md","raw":"---\ntitle: IntelliJ IDEA访问不到web项目的图片\ntags:\n  - IntelliJ IDEA\n  - 配置\nabbrlink: 739343a9\ndate: 2017-12-06 20:56:03\n---\n\n> Idea被认为是业界最好的Java开发工具，要使得它乖乖听话，任我摆布，还需要花时间调教调教它。\n\n今天在使用idea维护之前的博客项目的时候，发现原来在eclipse上跑的好好的项目突然在idea上就不好使了，部署的web项目，富文本编辑器的图片上传报错，页面访问不到图片。下面开始我解决问题的整个步骤。\n<!-- more -->\n### 运行项目，控制台打印的日志乱码。\n在tomcat的配置页面中`VM options` 选项中加入\n![](http://ozux0lqfa.bkt.clouddn.com/vmoption.png)\n```\n-Dfile.encoding=UTF-8\n```\n\n### 项目成功跑起来了，但用富文本编辑器上传图片，页面报错。\n- idea中tomcat发布项目的默认路径是项目所在地里的target目录里面。\n我的做法是更改项目发布路径到tomcat目录下的webapps目录下面，下面更改发布路径到tomcat。\n![](http://ozux0lqfa.bkt.clouddn.com/idea_%E4%BF%AE%E6%94%B9%E5%8F%91%E5%B8%83%E8%B7%AF%E5%BE%84%E4%B8%BATomcat%E7%9A%84webapps1.png)\n![](http://ozux0lqfa.bkt.clouddn.com/idea-tomcat%E5%8F%91%E5%B8%83%E7%9B%AE%E5%BD%952.png)\n这样之后，在重新运行项目，项目就会发布到tomcat的webapps目录里。\n\n### 配置图片资源文件\n- **sdll-blog**项目的图片资源目录我是存储在*upload*文件里面，\n![](http://ozux0lqfa.bkt.clouddn.com/idea%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95.png)\n- 现在我需要在idea里面配置upload文件资源。\n![](http://ozux0lqfa.bkt.clouddn.com/idea%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90%E7%9B%AE%E5%BD%951.png)\n**注意：**`Application context`里面的值配置为`/upload`\n\n![](http://ozux0lqfa.bkt.clouddn.com/idea%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90%E7%9B%AE%E5%BD%952.png)\n完成之后，再次运行项目，还是报找不到文件错误，查看控制台打印的日志，发现一个坑，发现在tomcat的安装路径中有部分有空格。文件夹**IDEA SERVER**控制条输出日志空格被解析成**IDEA%2%SERVER**，发现这个问题后，重新配置了个tomcat,重新运行项目，\n- 浏览器访问资源文件\n![](http://ozux0lqfa.bkt.clouddn.com/idea%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AE%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6yes.png)\n- 正常访问upload文件夹里面的图片资源了，富文本编辑器也不报错了哦。","slug":"IntelliJ-IDEA访问不到web项目的图片","published":1,"updated":"2017-12-14T13:55:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2w200t40002mwd3s1lt7zex","content":"<blockquote>\n<p>Idea被认为是业界最好的Java开发工具，要使得它乖乖听话，任我摆布，还需要花时间调教调教它。</p>\n</blockquote>\n<p>今天在使用idea维护之前的博客项目的时候，发现原来在eclipse上跑的好好的项目突然在idea上就不好使了，部署的web项目，富文本编辑器的图片上传报错，页面访问不到图片。下面开始我解决问题的整个步骤。<br><a id=\"more\"></a></p>\n<h3 id=\"运行项目，控制台打印的日志乱码。\"><a href=\"#运行项目，控制台打印的日志乱码。\" class=\"headerlink\" title=\"运行项目，控制台打印的日志乱码。\"></a>运行项目，控制台打印的日志乱码。</h3><p>在tomcat的配置页面中<code>VM options</code> 选项中加入<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/vmoption.png\" alt=\"\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Dfile.encoding=UTF-8</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"项目成功跑起来了，但用富文本编辑器上传图片，页面报错。\"><a href=\"#项目成功跑起来了，但用富文本编辑器上传图片，页面报错。\" class=\"headerlink\" title=\"项目成功跑起来了，但用富文本编辑器上传图片，页面报错。\"></a>项目成功跑起来了，但用富文本编辑器上传图片，页面报错。</h3><ul>\n<li>idea中tomcat发布项目的默认路径是项目所在地里的target目录里面。<br>我的做法是更改项目发布路径到tomcat目录下的webapps目录下面，下面更改发布路径到tomcat。<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/idea_%E4%BF%AE%E6%94%B9%E5%8F%91%E5%B8%83%E8%B7%AF%E5%BE%84%E4%B8%BATomcat%E7%9A%84webapps1.png\" alt=\"\"><br><img src=\"http://ozux0lqfa.bkt.clouddn.com/idea-tomcat%E5%8F%91%E5%B8%83%E7%9B%AE%E5%BD%952.png\" alt=\"\"><br>这样之后，在重新运行项目，项目就会发布到tomcat的webapps目录里。</li>\n</ul>\n<h3 id=\"配置图片资源文件\"><a href=\"#配置图片资源文件\" class=\"headerlink\" title=\"配置图片资源文件\"></a>配置图片资源文件</h3><ul>\n<li><strong>sdll-blog</strong>项目的图片资源目录我是存储在<em>upload</em>文件里面，<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/idea%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95.png\" alt=\"\"></li>\n<li>现在我需要在idea里面配置upload文件资源。<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/idea%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90%E7%9B%AE%E5%BD%951.png\" alt=\"\"><br><strong>注意：</strong><code>Application context</code>里面的值配置为<code>/upload</code></li>\n</ul>\n<p><img src=\"http://ozux0lqfa.bkt.clouddn.com/idea%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90%E7%9B%AE%E5%BD%952.png\" alt=\"\"><br>完成之后，再次运行项目，还是报找不到文件错误，查看控制台打印的日志，发现一个坑，发现在tomcat的安装路径中有部分有空格。文件夹<strong>IDEA SERVER</strong>控制条输出日志空格被解析成<strong>IDEA%2%SERVER</strong>，发现这个问题后，重新配置了个tomcat,重新运行项目，</p>\n<ul>\n<li>浏览器访问资源文件<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/idea%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AE%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6yes.png\" alt=\"\"></li>\n<li>正常访问upload文件夹里面的图片资源了，富文本编辑器也不报错了哦。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Idea被认为是业界最好的Java开发工具，要使得它乖乖听话，任我摆布，还需要花时间调教调教它。</p>\n</blockquote>\n<p>今天在使用idea维护之前的博客项目的时候，发现原来在eclipse上跑的好好的项目突然在idea上就不好使了，部署的web项目，富文本编辑器的图片上传报错，页面访问不到图片。下面开始我解决问题的整个步骤。<br>","more":"</p>\n<h3 id=\"运行项目，控制台打印的日志乱码。\"><a href=\"#运行项目，控制台打印的日志乱码。\" class=\"headerlink\" title=\"运行项目，控制台打印的日志乱码。\"></a>运行项目，控制台打印的日志乱码。</h3><p>在tomcat的配置页面中<code>VM options</code> 选项中加入<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/vmoption.png\" alt=\"\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Dfile.encoding=UTF-8</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"项目成功跑起来了，但用富文本编辑器上传图片，页面报错。\"><a href=\"#项目成功跑起来了，但用富文本编辑器上传图片，页面报错。\" class=\"headerlink\" title=\"项目成功跑起来了，但用富文本编辑器上传图片，页面报错。\"></a>项目成功跑起来了，但用富文本编辑器上传图片，页面报错。</h3><ul>\n<li>idea中tomcat发布项目的默认路径是项目所在地里的target目录里面。<br>我的做法是更改项目发布路径到tomcat目录下的webapps目录下面，下面更改发布路径到tomcat。<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/idea_%E4%BF%AE%E6%94%B9%E5%8F%91%E5%B8%83%E8%B7%AF%E5%BE%84%E4%B8%BATomcat%E7%9A%84webapps1.png\" alt=\"\"><br><img src=\"http://ozux0lqfa.bkt.clouddn.com/idea-tomcat%E5%8F%91%E5%B8%83%E7%9B%AE%E5%BD%952.png\" alt=\"\"><br>这样之后，在重新运行项目，项目就会发布到tomcat的webapps目录里。</li>\n</ul>\n<h3 id=\"配置图片资源文件\"><a href=\"#配置图片资源文件\" class=\"headerlink\" title=\"配置图片资源文件\"></a>配置图片资源文件</h3><ul>\n<li><strong>sdll-blog</strong>项目的图片资源目录我是存储在<em>upload</em>文件里面，<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/idea%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95.png\" alt=\"\"></li>\n<li>现在我需要在idea里面配置upload文件资源。<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/idea%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90%E7%9B%AE%E5%BD%951.png\" alt=\"\"><br><strong>注意：</strong><code>Application context</code>里面的值配置为<code>/upload</code></li>\n</ul>\n<p><img src=\"http://ozux0lqfa.bkt.clouddn.com/idea%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90%E7%9B%AE%E5%BD%952.png\" alt=\"\"><br>完成之后，再次运行项目，还是报找不到文件错误，查看控制台打印的日志，发现一个坑，发现在tomcat的安装路径中有部分有空格。文件夹<strong>IDEA SERVER</strong>控制条输出日志空格被解析成<strong>IDEA%2%SERVER</strong>，发现这个问题后，重新配置了个tomcat,重新运行项目，</p>\n<ul>\n<li>浏览器访问资源文件<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/idea%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AE%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6yes.png\" alt=\"\"></li>\n<li>正常访问upload文件夹里面的图片资源了，富文本编辑器也不报错了哦。</li>\n</ul>"},{"title":"MarkDown写文章的几个常用命令","abbrlink":"cc0e19bd","date":"2017-11-25T03:11:39.000Z","_content":"初次接触MarkDown的时候，记住这几个常用的命令，可以达到事半功倍的效果。\n<!-- more -->\n\n- 文章太长，在想截断的地方换行加上：\n> `<!-- more -->`\n- 引用，与内容保留一个空格:\n> \"`>`\"\n- 标题，#和「一级标题」之间建议保留一个字符的空格\n> `# 一级标题`              \n> `## 二级标题`\n> `### 三级标题`\n> `#### 四级标题`\n> `##### 五级标题`\n> `###### 六级标题`\n    \n- 图片\n> `![你好世界](https://www.sdll.club/img/hellowold.jpg)`\n- 链接\n> `[闪电拉拉个人博客](http://www.sdll.club)`\n**效果** **:**  [闪电拉拉个人博客](http://www.sdll.club)\n- 代码\n单行代码引用(左右各一个符号，把代码包裹起来)：\n`print('代码符号在左上角esc键下面！');`\n多行代码引用(上下各三个符号，把代码包裹起来)：\n```\npublic static String getName() {\n    System.out.println(\"代码符号在左上角esc键下面！！！\")\n}\n```\n- 列表，与内容之间保持一个空格\n> `-` 你好，我是无序列表\n> `1.` 我是有序列表\n- 粗体斜体\n`*闪电侠*`        效果(斜体)：*闪电侠*\n`**闪电侠**`     效果(粗体)：**闪电侠**\n- 表格\n```\ndog | bird | cat\n----|------|----\nfoo | foo  | foo\nbar | bar  | bar\nbaz | baz  | baz\n```\n> **效果**：\n\ndog | bird | cat\n----|------|----\nfoo | foo  | foo\nbar | bar  | bar\nbaz | baz  | baz\n\n参考文章：\nhttp://www.isetsuna.com/hexo/writing-image/\nhttp://www.jianshu.com/p/q81RER\n\n**推荐两款MarkDown在线编辑器：**\n[StackEdit在线编辑器](https://stackedit.io/editor#)\n[Cmd Markdown 编辑阅读器](https://www.zybuluo.com/mdeditor)","source":"_posts/MarkDown写文章的几个常用命令.md","raw":"---\ntitle: MarkDown写文章的几个常用命令\ntags:\n  - MarkDown命令\nabbrlink: cc0e19bd\ndate: 2017-11-25 11:11:39\n---\n初次接触MarkDown的时候，记住这几个常用的命令，可以达到事半功倍的效果。\n<!-- more -->\n\n- 文章太长，在想截断的地方换行加上：\n> `<!-- more -->`\n- 引用，与内容保留一个空格:\n> \"`>`\"\n- 标题，#和「一级标题」之间建议保留一个字符的空格\n> `# 一级标题`              \n> `## 二级标题`\n> `### 三级标题`\n> `#### 四级标题`\n> `##### 五级标题`\n> `###### 六级标题`\n    \n- 图片\n> `![你好世界](https://www.sdll.club/img/hellowold.jpg)`\n- 链接\n> `[闪电拉拉个人博客](http://www.sdll.club)`\n**效果** **:**  [闪电拉拉个人博客](http://www.sdll.club)\n- 代码\n单行代码引用(左右各一个符号，把代码包裹起来)：\n`print('代码符号在左上角esc键下面！');`\n多行代码引用(上下各三个符号，把代码包裹起来)：\n```\npublic static String getName() {\n    System.out.println(\"代码符号在左上角esc键下面！！！\")\n}\n```\n- 列表，与内容之间保持一个空格\n> `-` 你好，我是无序列表\n> `1.` 我是有序列表\n- 粗体斜体\n`*闪电侠*`        效果(斜体)：*闪电侠*\n`**闪电侠**`     效果(粗体)：**闪电侠**\n- 表格\n```\ndog | bird | cat\n----|------|----\nfoo | foo  | foo\nbar | bar  | bar\nbaz | baz  | baz\n```\n> **效果**：\n\ndog | bird | cat\n----|------|----\nfoo | foo  | foo\nbar | bar  | bar\nbaz | baz  | baz\n\n参考文章：\nhttp://www.isetsuna.com/hexo/writing-image/\nhttp://www.jianshu.com/p/q81RER\n\n**推荐两款MarkDown在线编辑器：**\n[StackEdit在线编辑器](https://stackedit.io/editor#)\n[Cmd Markdown 编辑阅读器](https://www.zybuluo.com/mdeditor)","slug":"MarkDown写文章的几个常用命令","published":1,"updated":"2017-12-14T13:55:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2w200tn0004mwd37isr0qlg","content":"<p>初次接触MarkDown的时候，记住这几个常用的命令，可以达到事半功倍的效果。<br><a id=\"more\"></a></p>\n<ul>\n<li>文章太长，在想截断的地方换行加上：<blockquote>\n<p><code>&lt;!-- more --&gt;</code></p>\n</blockquote>\n</li>\n<li>引用，与内容保留一个空格:<blockquote>\n<p>“<code>&gt;</code>“</p>\n</blockquote>\n</li>\n<li><p>标题，#和「一级标题」之间建议保留一个字符的空格</p>\n<blockquote>\n<p><code># 一级标题</code><br><code>## 二级标题</code><br><code>### 三级标题</code><br><code>#### 四级标题</code><br><code>##### 五级标题</code><br><code>###### 六级标题</code></p>\n</blockquote>\n</li>\n<li><p>图片</p>\n<blockquote>\n<p><code>![你好世界](https://www.sdll.club/img/hellowold.jpg)</code></p>\n</blockquote>\n</li>\n<li>链接<blockquote>\n<p><code>[闪电拉拉个人博客](http://www.sdll.club)</code><br><strong>效果</strong> <strong>:</strong>  <a href=\"http://www.sdll.club\" target=\"_blank\" rel=\"noopener\">闪电拉拉个人博客</a></p>\n</blockquote>\n</li>\n<li><p>代码<br>单行代码引用(左右各一个符号，把代码包裹起来)：<br><code>print(&#39;代码符号在左上角esc键下面！&#39;);</code><br>多行代码引用(上下各三个符号，把代码包裹起来)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static String getName() &#123;</span><br><span class=\"line\">    System.out.println(&quot;代码符号在左上角esc键下面！！！&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>列表，与内容之间保持一个空格</p>\n<blockquote>\n<p><code>-</code> 你好，我是无序列表<br><code>1.</code> 我是有序列表</p>\n</blockquote>\n</li>\n<li>粗体斜体<br><code>*闪电侠*</code>        效果(斜体)：<em>闪电侠</em><br><code>**闪电侠**</code>     效果(粗体)：<strong>闪电侠</strong></li>\n<li>表格<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dog | bird | cat</span><br><span class=\"line\">----|------|----</span><br><span class=\"line\">foo | foo  | foo</span><br><span class=\"line\">bar | bar  | bar</span><br><span class=\"line\">baz | baz  | baz</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p><strong>效果</strong>：</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>dog</th>\n<th>bird</th>\n<th>cat</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>foo</td>\n<td>foo</td>\n<td>foo</td>\n</tr>\n<tr>\n<td>bar</td>\n<td>bar</td>\n<td>bar</td>\n</tr>\n<tr>\n<td>baz</td>\n<td>baz</td>\n<td>baz</td>\n</tr>\n</tbody>\n</table>\n<p>参考文章：<br><a href=\"http://www.isetsuna.com/hexo/writing-image/\" target=\"_blank\" rel=\"noopener\">http://www.isetsuna.com/hexo/writing-image/</a><br><a href=\"http://www.jianshu.com/p/q81RER\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/q81RER</a></p>\n<p><strong>推荐两款MarkDown在线编辑器：</strong><br><a href=\"https://stackedit.io/editor#\" target=\"_blank\" rel=\"noopener\">StackEdit在线编辑器</a><br><a href=\"https://www.zybuluo.com/mdeditor\" target=\"_blank\" rel=\"noopener\">Cmd Markdown 编辑阅读器</a></p>\n","site":{"data":{}},"excerpt":"<p>初次接触MarkDown的时候，记住这几个常用的命令，可以达到事半功倍的效果。<br>","more":"</p>\n<ul>\n<li>文章太长，在想截断的地方换行加上：<blockquote>\n<p><code>&lt;!-- more --&gt;</code></p>\n</blockquote>\n</li>\n<li>引用，与内容保留一个空格:<blockquote>\n<p>“<code>&gt;</code>“</p>\n</blockquote>\n</li>\n<li><p>标题，#和「一级标题」之间建议保留一个字符的空格</p>\n<blockquote>\n<p><code># 一级标题</code><br><code>## 二级标题</code><br><code>### 三级标题</code><br><code>#### 四级标题</code><br><code>##### 五级标题</code><br><code>###### 六级标题</code></p>\n</blockquote>\n</li>\n<li><p>图片</p>\n<blockquote>\n<p><code>![你好世界](https://www.sdll.club/img/hellowold.jpg)</code></p>\n</blockquote>\n</li>\n<li>链接<blockquote>\n<p><code>[闪电拉拉个人博客](http://www.sdll.club)</code><br><strong>效果</strong> <strong>:</strong>  <a href=\"http://www.sdll.club\" target=\"_blank\" rel=\"noopener\">闪电拉拉个人博客</a></p>\n</blockquote>\n</li>\n<li><p>代码<br>单行代码引用(左右各一个符号，把代码包裹起来)：<br><code>print(&#39;代码符号在左上角esc键下面！&#39;);</code><br>多行代码引用(上下各三个符号，把代码包裹起来)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static String getName() &#123;</span><br><span class=\"line\">    System.out.println(&quot;代码符号在左上角esc键下面！！！&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>列表，与内容之间保持一个空格</p>\n<blockquote>\n<p><code>-</code> 你好，我是无序列表<br><code>1.</code> 我是有序列表</p>\n</blockquote>\n</li>\n<li>粗体斜体<br><code>*闪电侠*</code>        效果(斜体)：<em>闪电侠</em><br><code>**闪电侠**</code>     效果(粗体)：<strong>闪电侠</strong></li>\n<li>表格<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dog | bird | cat</span><br><span class=\"line\">----|------|----</span><br><span class=\"line\">foo | foo  | foo</span><br><span class=\"line\">bar | bar  | bar</span><br><span class=\"line\">baz | baz  | baz</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p><strong>效果</strong>：</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>dog</th>\n<th>bird</th>\n<th>cat</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>foo</td>\n<td>foo</td>\n<td>foo</td>\n</tr>\n<tr>\n<td>bar</td>\n<td>bar</td>\n<td>bar</td>\n</tr>\n<tr>\n<td>baz</td>\n<td>baz</td>\n<td>baz</td>\n</tr>\n</tbody>\n</table>\n<p>参考文章：<br><a href=\"http://www.isetsuna.com/hexo/writing-image/\" target=\"_blank\" rel=\"noopener\">http://www.isetsuna.com/hexo/writing-image/</a><br><a href=\"http://www.jianshu.com/p/q81RER\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/q81RER</a></p>\n<p><strong>推荐两款MarkDown在线编辑器：</strong><br><a href=\"https://stackedit.io/editor#\" target=\"_blank\" rel=\"noopener\">StackEdit在线编辑器</a><br><a href=\"https://www.zybuluo.com/mdeditor\" target=\"_blank\" rel=\"noopener\">Cmd Markdown 编辑阅读器</a></p>"},{"title":"RPC服务框架Dubbo","abbrlink":"b7aae4ad","date":"2017-12-14T07:55:02.000Z","_content":"\n[Dubbo](http://dubbo.io/) |dʌbəʊ| 是一个高性能，基于Java的RPC（Remote Procedure Call：远程过程调用）框架，由阿里巴巴开源。和许多RPC系统一样，dubbo基于定义一个服务的思想，指定可以通过参数和返回类型远程调用的方法。在服务器端，服务器实现这个接口并运行一个dubbo服务器来处理客户端调用。在客户端，客户端有一个存根，提供与服务器相同的方法。\n<!-- more -->\n**注意：**\ndubbo |dʌbəʊ| 音译`达博`，而不是`肚博`，专业名词还是念对比较好。\n\n### 一、dubbo模块介绍\n- **dubbo-common** 公共逻辑模块，包括 Util 类和通用模型。\n- **dubbo-remoting** 远程通讯模块，相当于 Dubbo 协议的实现，如果 RPC 用 RMI 协议，则不需要使用此包。\n- **dubbo-rpc** 远程调用模块，抽象各种协议，以及动态代理，只包含一对一的调用，不关心集群的管理。\n- **dubbo-cluster** 集群模块， 将多个服务提供方伪装为一个提供方， 包括： 负载均衡, 容错，路由等，集群的地址列表可以是静态配置的，也可以是由注册中心下发。\n- **dubbo-registry** 注册中心模块，基于注册中心下发地址的集群方式，以及对各种注册中心的抽象。\n- **dubbo-monitor** 监控模块，统计服务调用次数，调用时间的，调用链跟踪的服务。\n- **dubbo-config** 配置模块，是 Dubbo 对外的 API，用户通过 Config 使用 Dubbo，隐藏Dubbo 所有细节。\n- **dubbo-container** 容器模块，是一个 Standlone 的容器，以简单的 Main 加载 Spring启动，因为服务通常不需要 Tomcat/JBoss 等 Web 容器的特性，没必要用 Web 容器去加载服务。\n\n```\n<modules>\n    <module>hessian-lite</module>\n    <module>dubbo-common</module>   <!-- 公共模块 -->\n    <module>dubbo-container</module><!-- 容器 -->\n    <module>dubbo-remoting</module>\n    <module>dubbo-rpc</module>      <!-- rpc远程调用 -->\n    <module>dubbo-filter</module>\n    <module>dubbo-cluster</module>  <!-- 集群 -->\n    <module>dubbo-registry</module> <!-- 注册中心 -->\n    <module>dubbo-monitor</module>\n    <module>dubbo-config</module>   <!-- 配置spring，提供dubbo的api -->\n    <module>dubbo</module>\n    <module>dubbo-simple</module>\n    <module>dubbo-admin</module>    <!-- 配置dubbo-admin可视化界面 -->\n    <module>dubbo-demo</module>     <!-- 用户测试demo模块 -->\n    <module>dubbo-plugin</module>\n</modules>\n```\n\n**参考：**\nhttp://blog.csdn.net/u011659172/article/details/51491518","source":"_posts/RPC服务框架Dubbo.md","raw":"---\ntitle: RPC服务框架Dubbo\nabbrlink: b7aae4ad\ndate: 2017-12-14 15:55:02\ntags: [JAVA,框架,dubbo]\n---\n\n[Dubbo](http://dubbo.io/) |dʌbəʊ| 是一个高性能，基于Java的RPC（Remote Procedure Call：远程过程调用）框架，由阿里巴巴开源。和许多RPC系统一样，dubbo基于定义一个服务的思想，指定可以通过参数和返回类型远程调用的方法。在服务器端，服务器实现这个接口并运行一个dubbo服务器来处理客户端调用。在客户端，客户端有一个存根，提供与服务器相同的方法。\n<!-- more -->\n**注意：**\ndubbo |dʌbəʊ| 音译`达博`，而不是`肚博`，专业名词还是念对比较好。\n\n### 一、dubbo模块介绍\n- **dubbo-common** 公共逻辑模块，包括 Util 类和通用模型。\n- **dubbo-remoting** 远程通讯模块，相当于 Dubbo 协议的实现，如果 RPC 用 RMI 协议，则不需要使用此包。\n- **dubbo-rpc** 远程调用模块，抽象各种协议，以及动态代理，只包含一对一的调用，不关心集群的管理。\n- **dubbo-cluster** 集群模块， 将多个服务提供方伪装为一个提供方， 包括： 负载均衡, 容错，路由等，集群的地址列表可以是静态配置的，也可以是由注册中心下发。\n- **dubbo-registry** 注册中心模块，基于注册中心下发地址的集群方式，以及对各种注册中心的抽象。\n- **dubbo-monitor** 监控模块，统计服务调用次数，调用时间的，调用链跟踪的服务。\n- **dubbo-config** 配置模块，是 Dubbo 对外的 API，用户通过 Config 使用 Dubbo，隐藏Dubbo 所有细节。\n- **dubbo-container** 容器模块，是一个 Standlone 的容器，以简单的 Main 加载 Spring启动，因为服务通常不需要 Tomcat/JBoss 等 Web 容器的特性，没必要用 Web 容器去加载服务。\n\n```\n<modules>\n    <module>hessian-lite</module>\n    <module>dubbo-common</module>   <!-- 公共模块 -->\n    <module>dubbo-container</module><!-- 容器 -->\n    <module>dubbo-remoting</module>\n    <module>dubbo-rpc</module>      <!-- rpc远程调用 -->\n    <module>dubbo-filter</module>\n    <module>dubbo-cluster</module>  <!-- 集群 -->\n    <module>dubbo-registry</module> <!-- 注册中心 -->\n    <module>dubbo-monitor</module>\n    <module>dubbo-config</module>   <!-- 配置spring，提供dubbo的api -->\n    <module>dubbo</module>\n    <module>dubbo-simple</module>\n    <module>dubbo-admin</module>    <!-- 配置dubbo-admin可视化界面 -->\n    <module>dubbo-demo</module>     <!-- 用户测试demo模块 -->\n    <module>dubbo-plugin</module>\n</modules>\n```\n\n**参考：**\nhttp://blog.csdn.net/u011659172/article/details/51491518","slug":"RPC服务框架Dubbo","published":1,"updated":"2017-12-20T08:43:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2w200tx0005mwd3moqs87z6","content":"<p><a href=\"http://dubbo.io/\" target=\"_blank\" rel=\"noopener\">Dubbo</a> |dʌbəʊ| 是一个高性能，基于Java的RPC（Remote Procedure Call：远程过程调用）框架，由阿里巴巴开源。和许多RPC系统一样，dubbo基于定义一个服务的思想，指定可以通过参数和返回类型远程调用的方法。在服务器端，服务器实现这个接口并运行一个dubbo服务器来处理客户端调用。在客户端，客户端有一个存根，提供与服务器相同的方法。<br><a id=\"more\"></a><br><strong>注意：</strong><br>dubbo |dʌbəʊ| 音译<code>达博</code>，而不是<code>肚博</code>，专业名词还是念对比较好。</p>\n<h3 id=\"一、dubbo模块介绍\"><a href=\"#一、dubbo模块介绍\" class=\"headerlink\" title=\"一、dubbo模块介绍\"></a>一、dubbo模块介绍</h3><ul>\n<li><strong>dubbo-common</strong> 公共逻辑模块，包括 Util 类和通用模型。</li>\n<li><strong>dubbo-remoting</strong> 远程通讯模块，相当于 Dubbo 协议的实现，如果 RPC 用 RMI 协议，则不需要使用此包。</li>\n<li><strong>dubbo-rpc</strong> 远程调用模块，抽象各种协议，以及动态代理，只包含一对一的调用，不关心集群的管理。</li>\n<li><strong>dubbo-cluster</strong> 集群模块， 将多个服务提供方伪装为一个提供方， 包括： 负载均衡, 容错，路由等，集群的地址列表可以是静态配置的，也可以是由注册中心下发。</li>\n<li><strong>dubbo-registry</strong> 注册中心模块，基于注册中心下发地址的集群方式，以及对各种注册中心的抽象。</li>\n<li><strong>dubbo-monitor</strong> 监控模块，统计服务调用次数，调用时间的，调用链跟踪的服务。</li>\n<li><strong>dubbo-config</strong> 配置模块，是 Dubbo 对外的 API，用户通过 Config 使用 Dubbo，隐藏Dubbo 所有细节。</li>\n<li><strong>dubbo-container</strong> 容器模块，是一个 Standlone 的容器，以简单的 Main 加载 Spring启动，因为服务通常不需要 Tomcat/JBoss 等 Web 容器的特性，没必要用 Web 容器去加载服务。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;modules&gt;</span><br><span class=\"line\">    &lt;module&gt;hessian-lite&lt;/module&gt;</span><br><span class=\"line\">    &lt;module&gt;dubbo-common&lt;/module&gt;   &lt;!-- 公共模块 --&gt;</span><br><span class=\"line\">    &lt;module&gt;dubbo-container&lt;/module&gt;&lt;!-- 容器 --&gt;</span><br><span class=\"line\">    &lt;module&gt;dubbo-remoting&lt;/module&gt;</span><br><span class=\"line\">    &lt;module&gt;dubbo-rpc&lt;/module&gt;      &lt;!-- rpc远程调用 --&gt;</span><br><span class=\"line\">    &lt;module&gt;dubbo-filter&lt;/module&gt;</span><br><span class=\"line\">    &lt;module&gt;dubbo-cluster&lt;/module&gt;  &lt;!-- 集群 --&gt;</span><br><span class=\"line\">    &lt;module&gt;dubbo-registry&lt;/module&gt; &lt;!-- 注册中心 --&gt;</span><br><span class=\"line\">    &lt;module&gt;dubbo-monitor&lt;/module&gt;</span><br><span class=\"line\">    &lt;module&gt;dubbo-config&lt;/module&gt;   &lt;!-- 配置spring，提供dubbo的api --&gt;</span><br><span class=\"line\">    &lt;module&gt;dubbo&lt;/module&gt;</span><br><span class=\"line\">    &lt;module&gt;dubbo-simple&lt;/module&gt;</span><br><span class=\"line\">    &lt;module&gt;dubbo-admin&lt;/module&gt;    &lt;!-- 配置dubbo-admin可视化界面 --&gt;</span><br><span class=\"line\">    &lt;module&gt;dubbo-demo&lt;/module&gt;     &lt;!-- 用户测试demo模块 --&gt;</span><br><span class=\"line\">    &lt;module&gt;dubbo-plugin&lt;/module&gt;</span><br><span class=\"line\">&lt;/modules&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>参考：</strong><br><a href=\"http://blog.csdn.net/u011659172/article/details/51491518\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/u011659172/article/details/51491518</a></p>\n","site":{"data":{}},"excerpt":"<p><a href=\"http://dubbo.io/\" target=\"_blank\" rel=\"noopener\">Dubbo</a> |dʌbəʊ| 是一个高性能，基于Java的RPC（Remote Procedure Call：远程过程调用）框架，由阿里巴巴开源。和许多RPC系统一样，dubbo基于定义一个服务的思想，指定可以通过参数和返回类型远程调用的方法。在服务器端，服务器实现这个接口并运行一个dubbo服务器来处理客户端调用。在客户端，客户端有一个存根，提供与服务器相同的方法。<br>","more":"<br><strong>注意：</strong><br>dubbo |dʌbəʊ| 音译<code>达博</code>，而不是<code>肚博</code>，专业名词还是念对比较好。</p>\n<h3 id=\"一、dubbo模块介绍\"><a href=\"#一、dubbo模块介绍\" class=\"headerlink\" title=\"一、dubbo模块介绍\"></a>一、dubbo模块介绍</h3><ul>\n<li><strong>dubbo-common</strong> 公共逻辑模块，包括 Util 类和通用模型。</li>\n<li><strong>dubbo-remoting</strong> 远程通讯模块，相当于 Dubbo 协议的实现，如果 RPC 用 RMI 协议，则不需要使用此包。</li>\n<li><strong>dubbo-rpc</strong> 远程调用模块，抽象各种协议，以及动态代理，只包含一对一的调用，不关心集群的管理。</li>\n<li><strong>dubbo-cluster</strong> 集群模块， 将多个服务提供方伪装为一个提供方， 包括： 负载均衡, 容错，路由等，集群的地址列表可以是静态配置的，也可以是由注册中心下发。</li>\n<li><strong>dubbo-registry</strong> 注册中心模块，基于注册中心下发地址的集群方式，以及对各种注册中心的抽象。</li>\n<li><strong>dubbo-monitor</strong> 监控模块，统计服务调用次数，调用时间的，调用链跟踪的服务。</li>\n<li><strong>dubbo-config</strong> 配置模块，是 Dubbo 对外的 API，用户通过 Config 使用 Dubbo，隐藏Dubbo 所有细节。</li>\n<li><strong>dubbo-container</strong> 容器模块，是一个 Standlone 的容器，以简单的 Main 加载 Spring启动，因为服务通常不需要 Tomcat/JBoss 等 Web 容器的特性，没必要用 Web 容器去加载服务。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;modules&gt;</span><br><span class=\"line\">    &lt;module&gt;hessian-lite&lt;/module&gt;</span><br><span class=\"line\">    &lt;module&gt;dubbo-common&lt;/module&gt;   &lt;!-- 公共模块 --&gt;</span><br><span class=\"line\">    &lt;module&gt;dubbo-container&lt;/module&gt;&lt;!-- 容器 --&gt;</span><br><span class=\"line\">    &lt;module&gt;dubbo-remoting&lt;/module&gt;</span><br><span class=\"line\">    &lt;module&gt;dubbo-rpc&lt;/module&gt;      &lt;!-- rpc远程调用 --&gt;</span><br><span class=\"line\">    &lt;module&gt;dubbo-filter&lt;/module&gt;</span><br><span class=\"line\">    &lt;module&gt;dubbo-cluster&lt;/module&gt;  &lt;!-- 集群 --&gt;</span><br><span class=\"line\">    &lt;module&gt;dubbo-registry&lt;/module&gt; &lt;!-- 注册中心 --&gt;</span><br><span class=\"line\">    &lt;module&gt;dubbo-monitor&lt;/module&gt;</span><br><span class=\"line\">    &lt;module&gt;dubbo-config&lt;/module&gt;   &lt;!-- 配置spring，提供dubbo的api --&gt;</span><br><span class=\"line\">    &lt;module&gt;dubbo&lt;/module&gt;</span><br><span class=\"line\">    &lt;module&gt;dubbo-simple&lt;/module&gt;</span><br><span class=\"line\">    &lt;module&gt;dubbo-admin&lt;/module&gt;    &lt;!-- 配置dubbo-admin可视化界面 --&gt;</span><br><span class=\"line\">    &lt;module&gt;dubbo-demo&lt;/module&gt;     &lt;!-- 用户测试demo模块 --&gt;</span><br><span class=\"line\">    &lt;module&gt;dubbo-plugin&lt;/module&gt;</span><br><span class=\"line\">&lt;/modules&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>参考：</strong><br><a href=\"http://blog.csdn.net/u011659172/article/details/51491518\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/u011659172/article/details/51491518</a></p>"},{"title":"Java内存区域与内存溢出异常","abbrlink":"21b75d7a-memory-overflow-exception","date":"2018-09-22T14:34:14.000Z","_content":"\n### 第二章 Java内存区域与内存溢出异常\n\n#### 2.1 概述\n- 因为有java虚拟机的存在，java程序员不需要为每一个new出来的对象去编写`delete/free`代码，因为虚拟机自动内存管理机制不容易出现内存溢出的问题。\n\n\n<!-- more -->\n\n#### 2.2 运行时数据区\n- *2.2.1* 程序计数器\n    - 每条线程都要一个独立的程序计数器，为了线程切换后能够切换到正确的执行位置。\n    - 此内存区域是唯一一个在java虚拟机规范中没有规定任何**OutOfMerroyError**情况的区域\n- *2.2.2* java虚拟机栈\n    - Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的\n生命周期与线程相同。\n    - Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack  Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。\n    - 局部变量表存放了编译期可知的各种基本数据类型、对象引用、returnAddress类型。\n- *2.2.3* 本地方法栈\n    - 虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务 。\n- *2.2.4* java堆\n    - Java堆(Java Heap)是Java虚拟机所管理的内存中最大的一块。\n    - 此内存区域的唯一目的就是存放对象实例，**几乎**所有的对象实例都在这里分配内存。(不是绝对哦)。\n    - Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。\n    - 无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。\n    - Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。\n- *2.2.5* 方法区\n   - 方法区（MethodArea）与**Java堆**一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；别名叫做Non-Heap(非堆)。\n   - 不需要连续的内存、可以选择固定大小或者可拓展、可以选择不实现垃圾收集。\n   - 该区域的内存回收主要是针对常量池的回收和对类型的卸载(条件相当严苛)，回收“成绩”难以令人满意。\n- *2.2.6* 运行时常量池\n    - 是方法区的一部分。\n    - Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存储编译期间生成的各种字面量和符号引用，在类加载后进入方法区的`运行时常量池`。\n    - 运行时常量池相对Class文件常量池的另外一个重要的特征是具备动态性，运行期间也可能将新的常量放入池中。\n- *2.2.7* 直接内存\n\n#### 2.3　HotSpot虚拟机对象探秘\n- *2.3.1* 对象的创建\n    - 为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。两种分配方式：**指针碰撞**(Bump the Pointer)、**空闲列表**(Free List)；在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。\n    - 采用CAS配上失败重试的方式保证更新操作的原子性\n    - 在Java堆中预先分配一小块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer,TLAB)\n    - JIT（just in time）即时编译器；\n- *2.3.2* 对象的内存布局\n    - 在HotSpot虚拟机中,对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。\n    - 对象头的另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是属于哪个类的实例。如果对象是一个Java数组，那在对象头中还必须有一块记录数组长度的数据。\n    - 实例数据部分是对象真正存储的有效信息，也是在程序代码中定义的各种类型的字段类容。从父类继承和子类中定义的都需要记录下来。\n    - 对其补充并不是必然存在的，起着占位符的作用。\n- *2.3.3* 对象的访问定位\n    - Java程序需要通过栈上的reference数据来操作堆上的具体对象，访问堆中的对象取决于虚拟机的实现而定的，目前主流的访问方式有：使用句柄、直接指针两种。\n    - 使用句柄：java堆中会划出一块内存来作为句柄池，reference中存储的就是对象的句柄地址。\n    - 直接指针：最大的好处的速度更快，节省了一次指针定位的开销。","source":"_posts/Java内存区域与内存溢出异常.md","raw":"---\ntitle: Java内存区域与内存溢出异常\ntags:\n  - java虚拟机\nabbrlink: 21b75d7a-memory-overflow-exception\ndate: 2018-09-22 22:34:14\n---\n\n### 第二章 Java内存区域与内存溢出异常\n\n#### 2.1 概述\n- 因为有java虚拟机的存在，java程序员不需要为每一个new出来的对象去编写`delete/free`代码，因为虚拟机自动内存管理机制不容易出现内存溢出的问题。\n\n\n<!-- more -->\n\n#### 2.2 运行时数据区\n- *2.2.1* 程序计数器\n    - 每条线程都要一个独立的程序计数器，为了线程切换后能够切换到正确的执行位置。\n    - 此内存区域是唯一一个在java虚拟机规范中没有规定任何**OutOfMerroyError**情况的区域\n- *2.2.2* java虚拟机栈\n    - Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的\n生命周期与线程相同。\n    - Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack  Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。\n    - 局部变量表存放了编译期可知的各种基本数据类型、对象引用、returnAddress类型。\n- *2.2.3* 本地方法栈\n    - 虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务 。\n- *2.2.4* java堆\n    - Java堆(Java Heap)是Java虚拟机所管理的内存中最大的一块。\n    - 此内存区域的唯一目的就是存放对象实例，**几乎**所有的对象实例都在这里分配内存。(不是绝对哦)。\n    - Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。\n    - 无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。\n    - Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。\n- *2.2.5* 方法区\n   - 方法区（MethodArea）与**Java堆**一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；别名叫做Non-Heap(非堆)。\n   - 不需要连续的内存、可以选择固定大小或者可拓展、可以选择不实现垃圾收集。\n   - 该区域的内存回收主要是针对常量池的回收和对类型的卸载(条件相当严苛)，回收“成绩”难以令人满意。\n- *2.2.6* 运行时常量池\n    - 是方法区的一部分。\n    - Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存储编译期间生成的各种字面量和符号引用，在类加载后进入方法区的`运行时常量池`。\n    - 运行时常量池相对Class文件常量池的另外一个重要的特征是具备动态性，运行期间也可能将新的常量放入池中。\n- *2.2.7* 直接内存\n\n#### 2.3　HotSpot虚拟机对象探秘\n- *2.3.1* 对象的创建\n    - 为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。两种分配方式：**指针碰撞**(Bump the Pointer)、**空闲列表**(Free List)；在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。\n    - 采用CAS配上失败重试的方式保证更新操作的原子性\n    - 在Java堆中预先分配一小块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer,TLAB)\n    - JIT（just in time）即时编译器；\n- *2.3.2* 对象的内存布局\n    - 在HotSpot虚拟机中,对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。\n    - 对象头的另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是属于哪个类的实例。如果对象是一个Java数组，那在对象头中还必须有一块记录数组长度的数据。\n    - 实例数据部分是对象真正存储的有效信息，也是在程序代码中定义的各种类型的字段类容。从父类继承和子类中定义的都需要记录下来。\n    - 对其补充并不是必然存在的，起着占位符的作用。\n- *2.3.3* 对象的访问定位\n    - Java程序需要通过栈上的reference数据来操作堆上的具体对象，访问堆中的对象取决于虚拟机的实现而定的，目前主流的访问方式有：使用句柄、直接指针两种。\n    - 使用句柄：java堆中会划出一块内存来作为句柄池，reference中存储的就是对象的句柄地址。\n    - 直接指针：最大的好处的速度更快，节省了一次指针定位的开销。","slug":"Java内存区域与内存溢出异常","published":1,"updated":"2018-09-22T15:02:19.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2w200u20006mwd3d5yo1fkk","content":"<h3 id=\"第二章-Java内存区域与内存溢出异常\"><a href=\"#第二章-Java内存区域与内存溢出异常\" class=\"headerlink\" title=\"第二章 Java内存区域与内存溢出异常\"></a>第二章 Java内存区域与内存溢出异常</h3><h4 id=\"2-1-概述\"><a href=\"#2-1-概述\" class=\"headerlink\" title=\"2.1 概述\"></a>2.1 概述</h4><ul>\n<li>因为有java虚拟机的存在，java程序员不需要为每一个new出来的对象去编写<code>delete/free</code>代码，因为虚拟机自动内存管理机制不容易出现内存溢出的问题。</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"2-2-运行时数据区\"><a href=\"#2-2-运行时数据区\" class=\"headerlink\" title=\"2.2 运行时数据区\"></a>2.2 运行时数据区</h4><ul>\n<li><em>2.2.1</em> 程序计数器<ul>\n<li>每条线程都要一个独立的程序计数器，为了线程切换后能够切换到正确的执行位置。</li>\n<li>此内存区域是唯一一个在java虚拟机规范中没有规定任何<strong>OutOfMerroyError</strong>情况的区域</li>\n</ul>\n</li>\n<li><em>2.2.2</em> java虚拟机栈<ul>\n<li>Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的<br>生命周期与线程相同。</li>\n<li>Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack  Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</li>\n<li>局部变量表存放了编译期可知的各种基本数据类型、对象引用、returnAddress类型。</li>\n</ul>\n</li>\n<li><em>2.2.3</em> 本地方法栈<ul>\n<li>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务 。</li>\n</ul>\n</li>\n<li><em>2.2.4</em> java堆<ul>\n<li>Java堆(Java Heap)是Java虚拟机所管理的内存中最大的一块。</li>\n<li>此内存区域的唯一目的就是存放对象实例，<strong>几乎</strong>所有的对象实例都在这里分配内存。(不是绝对哦)。</li>\n<li>Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。</li>\n<li>无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。</li>\n<li>Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。</li>\n</ul>\n</li>\n<li><em>2.2.5</em> 方法区<ul>\n<li>方法区（MethodArea）与<strong>Java堆</strong>一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；别名叫做Non-Heap(非堆)。</li>\n<li>不需要连续的内存、可以选择固定大小或者可拓展、可以选择不实现垃圾收集。</li>\n<li>该区域的内存回收主要是针对常量池的回收和对类型的卸载(条件相当严苛)，回收“成绩”难以令人满意。</li>\n</ul>\n</li>\n<li><em>2.2.6</em> 运行时常量池<ul>\n<li>是方法区的一部分。</li>\n<li>Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存储编译期间生成的各种字面量和符号引用，在类加载后进入方法区的<code>运行时常量池</code>。</li>\n<li>运行时常量池相对Class文件常量池的另外一个重要的特征是具备动态性，运行期间也可能将新的常量放入池中。</li>\n</ul>\n</li>\n<li><em>2.2.7</em> 直接内存</li>\n</ul>\n<h4 id=\"2-3-HotSpot虚拟机对象探秘\"><a href=\"#2-3-HotSpot虚拟机对象探秘\" class=\"headerlink\" title=\"2.3　HotSpot虚拟机对象探秘\"></a>2.3　HotSpot虚拟机对象探秘</h4><ul>\n<li><em>2.3.1</em> 对象的创建<ul>\n<li>为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。两种分配方式：<strong>指针碰撞</strong>(Bump the Pointer)、<strong>空闲列表</strong>(Free List)；在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。</li>\n<li>采用CAS配上失败重试的方式保证更新操作的原子性</li>\n<li>在Java堆中预先分配一小块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer,TLAB)</li>\n<li>JIT（just in time）即时编译器；</li>\n</ul>\n</li>\n<li><em>2.3.2</em> 对象的内存布局<ul>\n<li>在HotSpot虚拟机中,对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</li>\n<li>对象头的另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是属于哪个类的实例。如果对象是一个Java数组，那在对象头中还必须有一块记录数组长度的数据。</li>\n<li>实例数据部分是对象真正存储的有效信息，也是在程序代码中定义的各种类型的字段类容。从父类继承和子类中定义的都需要记录下来。</li>\n<li>对其补充并不是必然存在的，起着占位符的作用。</li>\n</ul>\n</li>\n<li><em>2.3.3</em> 对象的访问定位<ul>\n<li>Java程序需要通过栈上的reference数据来操作堆上的具体对象，访问堆中的对象取决于虚拟机的实现而定的，目前主流的访问方式有：使用句柄、直接指针两种。</li>\n<li>使用句柄：java堆中会划出一块内存来作为句柄池，reference中存储的就是对象的句柄地址。</li>\n<li>直接指针：最大的好处的速度更快，节省了一次指针定位的开销。</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"第二章-Java内存区域与内存溢出异常\"><a href=\"#第二章-Java内存区域与内存溢出异常\" class=\"headerlink\" title=\"第二章 Java内存区域与内存溢出异常\"></a>第二章 Java内存区域与内存溢出异常</h3><h4 id=\"2-1-概述\"><a href=\"#2-1-概述\" class=\"headerlink\" title=\"2.1 概述\"></a>2.1 概述</h4><ul>\n<li>因为有java虚拟机的存在，java程序员不需要为每一个new出来的对象去编写<code>delete/free</code>代码，因为虚拟机自动内存管理机制不容易出现内存溢出的问题。</li>\n</ul>","more":"<h4 id=\"2-2-运行时数据区\"><a href=\"#2-2-运行时数据区\" class=\"headerlink\" title=\"2.2 运行时数据区\"></a>2.2 运行时数据区</h4><ul>\n<li><em>2.2.1</em> 程序计数器<ul>\n<li>每条线程都要一个独立的程序计数器，为了线程切换后能够切换到正确的执行位置。</li>\n<li>此内存区域是唯一一个在java虚拟机规范中没有规定任何<strong>OutOfMerroyError</strong>情况的区域</li>\n</ul>\n</li>\n<li><em>2.2.2</em> java虚拟机栈<ul>\n<li>Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的<br>生命周期与线程相同。</li>\n<li>Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack  Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</li>\n<li>局部变量表存放了编译期可知的各种基本数据类型、对象引用、returnAddress类型。</li>\n</ul>\n</li>\n<li><em>2.2.3</em> 本地方法栈<ul>\n<li>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务 。</li>\n</ul>\n</li>\n<li><em>2.2.4</em> java堆<ul>\n<li>Java堆(Java Heap)是Java虚拟机所管理的内存中最大的一块。</li>\n<li>此内存区域的唯一目的就是存放对象实例，<strong>几乎</strong>所有的对象实例都在这里分配内存。(不是绝对哦)。</li>\n<li>Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。</li>\n<li>无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。</li>\n<li>Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。</li>\n</ul>\n</li>\n<li><em>2.2.5</em> 方法区<ul>\n<li>方法区（MethodArea）与<strong>Java堆</strong>一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；别名叫做Non-Heap(非堆)。</li>\n<li>不需要连续的内存、可以选择固定大小或者可拓展、可以选择不实现垃圾收集。</li>\n<li>该区域的内存回收主要是针对常量池的回收和对类型的卸载(条件相当严苛)，回收“成绩”难以令人满意。</li>\n</ul>\n</li>\n<li><em>2.2.6</em> 运行时常量池<ul>\n<li>是方法区的一部分。</li>\n<li>Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存储编译期间生成的各种字面量和符号引用，在类加载后进入方法区的<code>运行时常量池</code>。</li>\n<li>运行时常量池相对Class文件常量池的另外一个重要的特征是具备动态性，运行期间也可能将新的常量放入池中。</li>\n</ul>\n</li>\n<li><em>2.2.7</em> 直接内存</li>\n</ul>\n<h4 id=\"2-3-HotSpot虚拟机对象探秘\"><a href=\"#2-3-HotSpot虚拟机对象探秘\" class=\"headerlink\" title=\"2.3　HotSpot虚拟机对象探秘\"></a>2.3　HotSpot虚拟机对象探秘</h4><ul>\n<li><em>2.3.1</em> 对象的创建<ul>\n<li>为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。两种分配方式：<strong>指针碰撞</strong>(Bump the Pointer)、<strong>空闲列表</strong>(Free List)；在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。</li>\n<li>采用CAS配上失败重试的方式保证更新操作的原子性</li>\n<li>在Java堆中预先分配一小块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer,TLAB)</li>\n<li>JIT（just in time）即时编译器；</li>\n</ul>\n</li>\n<li><em>2.3.2</em> 对象的内存布局<ul>\n<li>在HotSpot虚拟机中,对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</li>\n<li>对象头的另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是属于哪个类的实例。如果对象是一个Java数组，那在对象头中还必须有一块记录数组长度的数据。</li>\n<li>实例数据部分是对象真正存储的有效信息，也是在程序代码中定义的各种类型的字段类容。从父类继承和子类中定义的都需要记录下来。</li>\n<li>对其补充并不是必然存在的，起着占位符的作用。</li>\n</ul>\n</li>\n<li><em>2.3.3</em> 对象的访问定位<ul>\n<li>Java程序需要通过栈上的reference数据来操作堆上的具体对象，访问堆中的对象取决于虚拟机的实现而定的，目前主流的访问方式有：使用句柄、直接指针两种。</li>\n<li>使用句柄：java堆中会划出一块内存来作为句柄池，reference中存储的就是对象的句柄地址。</li>\n<li>直接指针：最大的好处的速度更快，节省了一次指针定位的开销。</li>\n</ul>\n</li>\n</ul>"},{"title":"Regular Expression Matching","abbrlink":"b9e89015","date":"2017-12-05T14:35:53.000Z","_content":"\n### 正则匹配\n在[leetcode](https://leetcode.com/problems/regular-expression-matching/description/)上看到一道正则的题目。\n<!-- more -->\n![](http://ozux0lqfa.bkt.clouddn.com/Regular%20Expression%20Matching.png)\n\n### 解决方式\n#### 递归方式（Recursion ）\n```\nclass Solution {\n    public boolean isMatch(String text, String pattern) {\n        if (pattern.isEmpty()) return text.isEmpty();\n        boolean first_match = (!text.isEmpty() && \n                               (pattern.charAt(0) == text.charAt(0) || pattern.charAt(0) == '.'));\n        \n        if (pattern.length() >= 2 && pattern.charAt(1) == '*'){\n            return (isMatch(text, pattern.substring(2)) || \n                    (first_match && isMatch(text.substring(1), pattern)));\n        } else {\n            return first_match && isMatch(text.substring(1), pattern.substring(1));\n        }\n    }\n}\n```\n\n#### 动态规划（Dynamic Programming）\n```\nclass Solution {\n    public boolean isMatch(String text, String pattern) {\n        boolean[][] dp = new boolean[text.length() + 1][pattern.length() + 1];\n        dp[text.length()][pattern.length()] = true;\n        \n        for (int i = text.length(); i >= 0; i--){\n            for (int j = pattern.length() - 1; j >= 0; j--){\n                boolean first_match = (i < text.length() && \n                                       (pattern.charAt(j) == text.charAt(i) ||\n                                        pattern.charAt(j) == '.'));\n                if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                    dp[i][j] = dp[i][j+2] || first_match && dp[i+1][j];\n                } else {\n                    dp[i][j] = first_match && dp[i+1][j+1];\n                }\n            }\n        }\n        return dp[0][0];\n    }\n}\n```\n","source":"_posts/Regular-Expression-Matching.md","raw":"---\ntitle: Regular Expression Matching\ntags:\n  - 算法\nabbrlink: b9e89015\ndate: 2017-12-05 22:35:53\n---\n\n### 正则匹配\n在[leetcode](https://leetcode.com/problems/regular-expression-matching/description/)上看到一道正则的题目。\n<!-- more -->\n![](http://ozux0lqfa.bkt.clouddn.com/Regular%20Expression%20Matching.png)\n\n### 解决方式\n#### 递归方式（Recursion ）\n```\nclass Solution {\n    public boolean isMatch(String text, String pattern) {\n        if (pattern.isEmpty()) return text.isEmpty();\n        boolean first_match = (!text.isEmpty() && \n                               (pattern.charAt(0) == text.charAt(0) || pattern.charAt(0) == '.'));\n        \n        if (pattern.length() >= 2 && pattern.charAt(1) == '*'){\n            return (isMatch(text, pattern.substring(2)) || \n                    (first_match && isMatch(text.substring(1), pattern)));\n        } else {\n            return first_match && isMatch(text.substring(1), pattern.substring(1));\n        }\n    }\n}\n```\n\n#### 动态规划（Dynamic Programming）\n```\nclass Solution {\n    public boolean isMatch(String text, String pattern) {\n        boolean[][] dp = new boolean[text.length() + 1][pattern.length() + 1];\n        dp[text.length()][pattern.length()] = true;\n        \n        for (int i = text.length(); i >= 0; i--){\n            for (int j = pattern.length() - 1; j >= 0; j--){\n                boolean first_match = (i < text.length() && \n                                       (pattern.charAt(j) == text.charAt(i) ||\n                                        pattern.charAt(j) == '.'));\n                if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                    dp[i][j] = dp[i][j+2] || first_match && dp[i+1][j];\n                } else {\n                    dp[i][j] = first_match && dp[i+1][j+1];\n                }\n            }\n        }\n        return dp[0][0];\n    }\n}\n```\n","slug":"Regular-Expression-Matching","published":1,"updated":"2017-12-14T13:55:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2w200ue0009mwd330ggsnqq","content":"<h3 id=\"正则匹配\"><a href=\"#正则匹配\" class=\"headerlink\" title=\"正则匹配\"></a>正则匹配</h3><p>在<a href=\"https://leetcode.com/problems/regular-expression-matching/description/\" target=\"_blank\" rel=\"noopener\">leetcode</a>上看到一道正则的题目。<br><a id=\"more\"></a><br><img src=\"http://ozux0lqfa.bkt.clouddn.com/Regular%20Expression%20Matching.png\" alt=\"\"></p>\n<h3 id=\"解决方式\"><a href=\"#解决方式\" class=\"headerlink\" title=\"解决方式\"></a>解决方式</h3><h4 id=\"递归方式（Recursion-）\"><a href=\"#递归方式（Recursion-）\" class=\"headerlink\" title=\"递归方式（Recursion ）\"></a>递归方式（Recursion ）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public boolean isMatch(String text, String pattern) &#123;</span><br><span class=\"line\">        if (pattern.isEmpty()) return text.isEmpty();</span><br><span class=\"line\">        boolean first_match = (!text.isEmpty() &amp;&amp; </span><br><span class=\"line\">                               (pattern.charAt(0) == text.charAt(0) || pattern.charAt(0) == &apos;.&apos;));</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (pattern.length() &gt;= 2 &amp;&amp; pattern.charAt(1) == &apos;*&apos;)&#123;</span><br><span class=\"line\">            return (isMatch(text, pattern.substring(2)) || </span><br><span class=\"line\">                    (first_match &amp;&amp; isMatch(text.substring(1), pattern)));</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return first_match &amp;&amp; isMatch(text.substring(1), pattern.substring(1));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"动态规划（Dynamic-Programming）\"><a href=\"#动态规划（Dynamic-Programming）\" class=\"headerlink\" title=\"动态规划（Dynamic Programming）\"></a>动态规划（Dynamic Programming）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public boolean isMatch(String text, String pattern) &#123;</span><br><span class=\"line\">        boolean[][] dp = new boolean[text.length() + 1][pattern.length() + 1];</span><br><span class=\"line\">        dp[text.length()][pattern.length()] = true;</span><br><span class=\"line\">        </span><br><span class=\"line\">        for (int i = text.length(); i &gt;= 0; i--)&#123;</span><br><span class=\"line\">            for (int j = pattern.length() - 1; j &gt;= 0; j--)&#123;</span><br><span class=\"line\">                boolean first_match = (i &lt; text.length() &amp;&amp; </span><br><span class=\"line\">                                       (pattern.charAt(j) == text.charAt(i) ||</span><br><span class=\"line\">                                        pattern.charAt(j) == &apos;.&apos;));</span><br><span class=\"line\">                if (j + 1 &lt; pattern.length() &amp;&amp; pattern.charAt(j+1) == &apos;*&apos;)&#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i][j+2] || first_match &amp;&amp; dp[i+1][j];</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    dp[i][j] = first_match &amp;&amp; dp[i+1][j+1];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dp[0][0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"正则匹配\"><a href=\"#正则匹配\" class=\"headerlink\" title=\"正则匹配\"></a>正则匹配</h3><p>在<a href=\"https://leetcode.com/problems/regular-expression-matching/description/\" target=\"_blank\" rel=\"noopener\">leetcode</a>上看到一道正则的题目。<br>","more":"<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/Regular%20Expression%20Matching.png\" alt=\"\"></p>\n<h3 id=\"解决方式\"><a href=\"#解决方式\" class=\"headerlink\" title=\"解决方式\"></a>解决方式</h3><h4 id=\"递归方式（Recursion-）\"><a href=\"#递归方式（Recursion-）\" class=\"headerlink\" title=\"递归方式（Recursion ）\"></a>递归方式（Recursion ）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public boolean isMatch(String text, String pattern) &#123;</span><br><span class=\"line\">        if (pattern.isEmpty()) return text.isEmpty();</span><br><span class=\"line\">        boolean first_match = (!text.isEmpty() &amp;&amp; </span><br><span class=\"line\">                               (pattern.charAt(0) == text.charAt(0) || pattern.charAt(0) == &apos;.&apos;));</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (pattern.length() &gt;= 2 &amp;&amp; pattern.charAt(1) == &apos;*&apos;)&#123;</span><br><span class=\"line\">            return (isMatch(text, pattern.substring(2)) || </span><br><span class=\"line\">                    (first_match &amp;&amp; isMatch(text.substring(1), pattern)));</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return first_match &amp;&amp; isMatch(text.substring(1), pattern.substring(1));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"动态规划（Dynamic-Programming）\"><a href=\"#动态规划（Dynamic-Programming）\" class=\"headerlink\" title=\"动态规划（Dynamic Programming）\"></a>动态规划（Dynamic Programming）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public boolean isMatch(String text, String pattern) &#123;</span><br><span class=\"line\">        boolean[][] dp = new boolean[text.length() + 1][pattern.length() + 1];</span><br><span class=\"line\">        dp[text.length()][pattern.length()] = true;</span><br><span class=\"line\">        </span><br><span class=\"line\">        for (int i = text.length(); i &gt;= 0; i--)&#123;</span><br><span class=\"line\">            for (int j = pattern.length() - 1; j &gt;= 0; j--)&#123;</span><br><span class=\"line\">                boolean first_match = (i &lt; text.length() &amp;&amp; </span><br><span class=\"line\">                                       (pattern.charAt(j) == text.charAt(i) ||</span><br><span class=\"line\">                                        pattern.charAt(j) == &apos;.&apos;));</span><br><span class=\"line\">                if (j + 1 &lt; pattern.length() &amp;&amp; pattern.charAt(j+1) == &apos;*&apos;)&#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i][j+2] || first_match &amp;&amp; dp[i+1][j];</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    dp[i][j] = first_match &amp;&amp; dp[i+1][j+1];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dp[0][0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"ThreadLocal理解","abbrlink":"362db54f-ThreadLocal","date":"2019-06-23T15:04:27.000Z","_content":"\n## 参考引用\n\n[手撕面试题ThreadLocal！！！](https://mp.weixin.qq.com/s?__biz=MzU2NjIzNDk5NQ==&mid=2247486666&idx=1&sn=ee9d72b115411940940f00171986e0db&chksm=fcaed6d6cbd95fc08cf5525e7974efc7753f9f018f2a79fd5386b9f0132b90645394e85c3568&mpshare=1&scene=1&srcid=#rd)\n\n## ThreadLocal是什么？\n面试官：讲讲你对ThreadLocal的一些理解。\n\n那么我们该怎么回答呢？你也可以思考下，下面看看零度的思考；\n- ThreadLocal用在什么地方？\n\n- ThreadLocal一些细节！\n\n- ThreadLocal的最佳实践！\n\n- 思考！\n\n  \n\n<!-- more -->\n\n  \n\n## ThreadLocal用在什么地方？\n讨论ThreadLocal用在什么地方前，我们先明确下，如果仅仅就一个线程，那么都不用谈ThreadLocal的，ThreadLocal是用在多线程的场景的！\nThreadLocal归纳下来就2类用途：\n- 保存线程上下文信息，在任意需要的地方可以获取！\n> 1、由于ThreadLocal的特性，同一线程在某地方进行设置，在随后的任意地方都可以获取到。从而可以用来保存线程上下文信息。\n2、常用的比如每个请求怎么把一串后续关联起来，就可以用ThreadLocal进行set，在后续的任意需要记录日志的方法里面进行get获取到请求id，从而把整个请求串起来。\n3、还有比如Spring的事务管理，用ThreadLocal存储Connection，从而各个DAO可以获取同一Connection，可以进行事务回滚，提交等操作。\n备注：ThreadLocal的这种用处，很多时候是用在一些优秀的框架里面的，一般我们很少接触，反而下面的场景我们接触的更多一些！\n- 线程安全的，避免某些情况需要考虑线程安全必须同步带来的性能损失！\n> ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。但是ThreadLocal也有局限性，我们来看看阿里规范：\n![](http://ww1.sinaimg.cn/large/8515e8c2ly1g4bgqpmiv3j20u004wdg7.jpg)\n每个线程往ThreadLocal中读写数据是线程隔离，互相之间不会影响的，所以ThreadLocal无法解决共享对象的更新问题！\n由于不需要共享信息，自然就不存在竞争问题了，从而保证了某些情况下线程的安全，以及避免了某些情况需要考虑线程安全必须同步带来的性能损失！\n这类场景阿里规范里面也提到了：\n![](http://ww1.sinaimg.cn/large/8515e8c2ly1g4bgtmiyk7j20u008rt92.jpg)\n\n## ThreadLocal一些细节\nThreaLocal使用示例代码：\n```\npublic class ThreadLocalTest {\n    private static ThreadLocal<Integer> threadLocal = new ThreadLocal<>();\n\n    public static void main(String[] args) {\n\n        new Thread(() -> {\n            try {\n                for (int i = 0; i < 100; i++) {\n                    // 给该线程的设置值\n                    threadLocal.set(i);\n                    System.out.println(Thread.currentThread().getName() + \"====\" + threadLocal.get());\n                    try {\n                        Thread.sleep(200);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            } finally {\n                threadLocal.remove();\n            }\n        }, \"threadLocal1\").start();\n\n\n        new Thread(() -> {\n            try {\n                for (int i = 0; i < 100; i++) {\n                    System.out.println(Thread.currentThread().getName() + \"====\" + threadLocal.get());\n                    try {\n                        Thread.sleep(200);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            } finally {\n                threadLocal.remove();\n            }\n        }, \"threadLocal2\").start();\n    }\n}\n```\n代码运行结果：\n\n![](http://ww1.sinaimg.cn/large/8515e8c2ly1g4bgvby07kj20dp0723yi.jpg)\n\n从运行的结果我们可以看到`threadLocal1`进行`set()`值对`threadLocal2`并**没有任何影响**！\n\n- `Thread`、`ThreadLocalMap`、`ThreadLocal`总览图：\n![](http://ww1.sinaimg.cn/large/8515e8c2ly1g4bgym7f89j20tq0m00t2.jpg)\n\n- `Thread`类有属性变量`threadLocals`（类型是`ThreadLocal.ThreadLocalMap`），也就是说每个线程有一个自己的`ThreadLocalMap` ，所以每个线程往这个`ThreadLocal`中读写隔离的，并且是互相不会影响的。\n![](http://ww1.sinaimg.cn/large/8515e8c2ly1g4bgz6eds7j20nd040weh.jpg)\n\n- 一个`ThreadLocal`只能存储一个`Object`对象，如果需要存储多个`Object`对象那么就需要多个`ThreadLocal`。\n如图：\n![](http://ww1.sinaimg.cn/large/8515e8c2ly1g4bh2dmh7cj20ts0m2dgg.jpg)\n看到上面的几个图，大概思路应该都清晰了，我们`Entry`的`key`指向`ThreadLocal`用虚线表示弱引用 ，下面我们来看看`ThreadLocalMap`:\n![](http://ww1.sinaimg.cn/large/8515e8c2ly1g4bh3liojaj20na0c0jrt.jpg)\n\n- java对象的引用包括 ： **强引用**，**软引用**，**弱引用**，**虚引用**。因为这里涉及到 **弱引用**，简单说明下：\n> 弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，该对象仅仅被弱引用关联，那么就会被回收。当仅仅只有ThreadLocalMap中的Entry的key指向ThreadLocal的时候，ThreadLocal会进行回收的！ThreadLocal被垃圾回收后，在ThreadLocalMap里对应的Entry的键值会变成null，但是Entry是强引用，那么Entry里面存储的Object，并没有办法进行回收，所以ThreadLocalMap 做了一些额外的回收工作。\n![](http://ww1.sinaimg.cn/large/8515e8c2ly1g4bh6khf5kj20u00dhdgl.jpg)\n虽然做了但是也会存在内存泄漏风险（我没有遇到过，网上很多类似场景，所以会提到后面的ThreadLocal最佳实践！）\n\n## ThreadLocal的最佳实践！\n很多时候，我们都是用在线程池的场景，程序不停止，线程基本不会销毁！\n由于线程的生命周期很长，如果我们往ThreadLocal里面set了很大很大的Object对象，虽然set、get等等方法在特定的条件会调用进行额外的清理，**但是ThreadLocal被垃圾回收后，在ThreadLocalMap里对应的Entry的键值会变成null，但是后续在也没有操作set、get等方法了**。\n\n所以最佳实践，应该在我们不使用的时候，主动调用remove方法进行清理。\n![](http://ww1.sinaimg.cn/large/8515e8c2ly1g4bha0clrkj20u004xmxi.jpg)\n这里把ThreadLocal定义为static还有一个好处就是，由于ThreadLocal有强引用在，那么在ThreadLocalMap里对应的Entry的键会永远存在，那么执行remove的时候就可以正确进行定位到并且删除！\n\n## 思考\n如果面试的时候，可以把上面的内容都可以讲到，个人觉得就非常好了，回答的就挺完美了。但是如果你可以进行下面的回答，那么就更完美了。\n\n对于ThreadLocal，我在看Netty源码的时候，还了解过FastThreadLocal，xxxxx一些列内容，那就是一个升级了。\n![](http://ww1.sinaimg.cn/large/8515e8c2ly1g4bhbtior6j20u00ijwf4.jpg)\n在我本地进行测试，FastThreadLocal的吞吐量是jdkThreadLocal的3倍左右。\n\n","source":"_posts/ThreadLocal理解.md","raw":"---\ntitle: ThreadLocal理解\ntags:\n  - JAVA\n  - jdk源码\nabbrlink: 362db54f-ThreadLocal\ndate: 2019-06-23 23:04:27\n---\n\n## 参考引用\n\n[手撕面试题ThreadLocal！！！](https://mp.weixin.qq.com/s?__biz=MzU2NjIzNDk5NQ==&mid=2247486666&idx=1&sn=ee9d72b115411940940f00171986e0db&chksm=fcaed6d6cbd95fc08cf5525e7974efc7753f9f018f2a79fd5386b9f0132b90645394e85c3568&mpshare=1&scene=1&srcid=#rd)\n\n## ThreadLocal是什么？\n面试官：讲讲你对ThreadLocal的一些理解。\n\n那么我们该怎么回答呢？你也可以思考下，下面看看零度的思考；\n- ThreadLocal用在什么地方？\n\n- ThreadLocal一些细节！\n\n- ThreadLocal的最佳实践！\n\n- 思考！\n\n  \n\n<!-- more -->\n\n  \n\n## ThreadLocal用在什么地方？\n讨论ThreadLocal用在什么地方前，我们先明确下，如果仅仅就一个线程，那么都不用谈ThreadLocal的，ThreadLocal是用在多线程的场景的！\nThreadLocal归纳下来就2类用途：\n- 保存线程上下文信息，在任意需要的地方可以获取！\n> 1、由于ThreadLocal的特性，同一线程在某地方进行设置，在随后的任意地方都可以获取到。从而可以用来保存线程上下文信息。\n2、常用的比如每个请求怎么把一串后续关联起来，就可以用ThreadLocal进行set，在后续的任意需要记录日志的方法里面进行get获取到请求id，从而把整个请求串起来。\n3、还有比如Spring的事务管理，用ThreadLocal存储Connection，从而各个DAO可以获取同一Connection，可以进行事务回滚，提交等操作。\n备注：ThreadLocal的这种用处，很多时候是用在一些优秀的框架里面的，一般我们很少接触，反而下面的场景我们接触的更多一些！\n- 线程安全的，避免某些情况需要考虑线程安全必须同步带来的性能损失！\n> ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。但是ThreadLocal也有局限性，我们来看看阿里规范：\n![](http://ww1.sinaimg.cn/large/8515e8c2ly1g4bgqpmiv3j20u004wdg7.jpg)\n每个线程往ThreadLocal中读写数据是线程隔离，互相之间不会影响的，所以ThreadLocal无法解决共享对象的更新问题！\n由于不需要共享信息，自然就不存在竞争问题了，从而保证了某些情况下线程的安全，以及避免了某些情况需要考虑线程安全必须同步带来的性能损失！\n这类场景阿里规范里面也提到了：\n![](http://ww1.sinaimg.cn/large/8515e8c2ly1g4bgtmiyk7j20u008rt92.jpg)\n\n## ThreadLocal一些细节\nThreaLocal使用示例代码：\n```\npublic class ThreadLocalTest {\n    private static ThreadLocal<Integer> threadLocal = new ThreadLocal<>();\n\n    public static void main(String[] args) {\n\n        new Thread(() -> {\n            try {\n                for (int i = 0; i < 100; i++) {\n                    // 给该线程的设置值\n                    threadLocal.set(i);\n                    System.out.println(Thread.currentThread().getName() + \"====\" + threadLocal.get());\n                    try {\n                        Thread.sleep(200);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            } finally {\n                threadLocal.remove();\n            }\n        }, \"threadLocal1\").start();\n\n\n        new Thread(() -> {\n            try {\n                for (int i = 0; i < 100; i++) {\n                    System.out.println(Thread.currentThread().getName() + \"====\" + threadLocal.get());\n                    try {\n                        Thread.sleep(200);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            } finally {\n                threadLocal.remove();\n            }\n        }, \"threadLocal2\").start();\n    }\n}\n```\n代码运行结果：\n\n![](http://ww1.sinaimg.cn/large/8515e8c2ly1g4bgvby07kj20dp0723yi.jpg)\n\n从运行的结果我们可以看到`threadLocal1`进行`set()`值对`threadLocal2`并**没有任何影响**！\n\n- `Thread`、`ThreadLocalMap`、`ThreadLocal`总览图：\n![](http://ww1.sinaimg.cn/large/8515e8c2ly1g4bgym7f89j20tq0m00t2.jpg)\n\n- `Thread`类有属性变量`threadLocals`（类型是`ThreadLocal.ThreadLocalMap`），也就是说每个线程有一个自己的`ThreadLocalMap` ，所以每个线程往这个`ThreadLocal`中读写隔离的，并且是互相不会影响的。\n![](http://ww1.sinaimg.cn/large/8515e8c2ly1g4bgz6eds7j20nd040weh.jpg)\n\n- 一个`ThreadLocal`只能存储一个`Object`对象，如果需要存储多个`Object`对象那么就需要多个`ThreadLocal`。\n如图：\n![](http://ww1.sinaimg.cn/large/8515e8c2ly1g4bh2dmh7cj20ts0m2dgg.jpg)\n看到上面的几个图，大概思路应该都清晰了，我们`Entry`的`key`指向`ThreadLocal`用虚线表示弱引用 ，下面我们来看看`ThreadLocalMap`:\n![](http://ww1.sinaimg.cn/large/8515e8c2ly1g4bh3liojaj20na0c0jrt.jpg)\n\n- java对象的引用包括 ： **强引用**，**软引用**，**弱引用**，**虚引用**。因为这里涉及到 **弱引用**，简单说明下：\n> 弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，该对象仅仅被弱引用关联，那么就会被回收。当仅仅只有ThreadLocalMap中的Entry的key指向ThreadLocal的时候，ThreadLocal会进行回收的！ThreadLocal被垃圾回收后，在ThreadLocalMap里对应的Entry的键值会变成null，但是Entry是强引用，那么Entry里面存储的Object，并没有办法进行回收，所以ThreadLocalMap 做了一些额外的回收工作。\n![](http://ww1.sinaimg.cn/large/8515e8c2ly1g4bh6khf5kj20u00dhdgl.jpg)\n虽然做了但是也会存在内存泄漏风险（我没有遇到过，网上很多类似场景，所以会提到后面的ThreadLocal最佳实践！）\n\n## ThreadLocal的最佳实践！\n很多时候，我们都是用在线程池的场景，程序不停止，线程基本不会销毁！\n由于线程的生命周期很长，如果我们往ThreadLocal里面set了很大很大的Object对象，虽然set、get等等方法在特定的条件会调用进行额外的清理，**但是ThreadLocal被垃圾回收后，在ThreadLocalMap里对应的Entry的键值会变成null，但是后续在也没有操作set、get等方法了**。\n\n所以最佳实践，应该在我们不使用的时候，主动调用remove方法进行清理。\n![](http://ww1.sinaimg.cn/large/8515e8c2ly1g4bha0clrkj20u004xmxi.jpg)\n这里把ThreadLocal定义为static还有一个好处就是，由于ThreadLocal有强引用在，那么在ThreadLocalMap里对应的Entry的键会永远存在，那么执行remove的时候就可以正确进行定位到并且删除！\n\n## 思考\n如果面试的时候，可以把上面的内容都可以讲到，个人觉得就非常好了，回答的就挺完美了。但是如果你可以进行下面的回答，那么就更完美了。\n\n对于ThreadLocal，我在看Netty源码的时候，还了解过FastThreadLocal，xxxxx一些列内容，那就是一个升级了。\n![](http://ww1.sinaimg.cn/large/8515e8c2ly1g4bhbtior6j20u00ijwf4.jpg)\n在我本地进行测试，FastThreadLocal的吞吐量是jdkThreadLocal的3倍左右。\n\n","slug":"ThreadLocal理解","published":1,"updated":"2019-07-07T03:33:31.557Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2w200v2000amwd3c5gikuf3","content":"<h2 id=\"参考引用\"><a href=\"#参考引用\" class=\"headerlink\" title=\"参考引用\"></a>参考引用</h2><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU2NjIzNDk5NQ==&amp;mid=2247486666&amp;idx=1&amp;sn=ee9d72b115411940940f00171986e0db&amp;chksm=fcaed6d6cbd95fc08cf5525e7974efc7753f9f018f2a79fd5386b9f0132b90645394e85c3568&amp;mpshare=1&amp;scene=1&amp;srcid=#rd\" target=\"_blank\" rel=\"noopener\">手撕面试题ThreadLocal！！！</a></p>\n<h2 id=\"ThreadLocal是什么？\"><a href=\"#ThreadLocal是什么？\" class=\"headerlink\" title=\"ThreadLocal是什么？\"></a>ThreadLocal是什么？</h2><p>面试官：讲讲你对ThreadLocal的一些理解。</p>\n<p>那么我们该怎么回答呢？你也可以思考下，下面看看零度的思考；</p>\n<ul>\n<li><p>ThreadLocal用在什么地方？</p>\n</li>\n<li><p>ThreadLocal一些细节！</p>\n</li>\n<li><p>ThreadLocal的最佳实践！</p>\n</li>\n<li><p>思考！</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"ThreadLocal用在什么地方？\"><a href=\"#ThreadLocal用在什么地方？\" class=\"headerlink\" title=\"ThreadLocal用在什么地方？\"></a>ThreadLocal用在什么地方？</h2><p>讨论ThreadLocal用在什么地方前，我们先明确下，如果仅仅就一个线程，那么都不用谈ThreadLocal的，ThreadLocal是用在多线程的场景的！<br>ThreadLocal归纳下来就2类用途：</p>\n<ul>\n<li>保存线程上下文信息，在任意需要的地方可以获取！<blockquote>\n<p>1、由于ThreadLocal的特性，同一线程在某地方进行设置，在随后的任意地方都可以获取到。从而可以用来保存线程上下文信息。<br>2、常用的比如每个请求怎么把一串后续关联起来，就可以用ThreadLocal进行set，在后续的任意需要记录日志的方法里面进行get获取到请求id，从而把整个请求串起来。<br>3、还有比如Spring的事务管理，用ThreadLocal存储Connection，从而各个DAO可以获取同一Connection，可以进行事务回滚，提交等操作。<br>备注：ThreadLocal的这种用处，很多时候是用在一些优秀的框架里面的，一般我们很少接触，反而下面的场景我们接触的更多一些！</p>\n</blockquote>\n</li>\n<li>线程安全的，避免某些情况需要考虑线程安全必须同步带来的性能损失！<blockquote>\n<p>ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。但是ThreadLocal也有局限性，我们来看看阿里规范：<br><img src=\"http://ww1.sinaimg.cn/large/8515e8c2ly1g4bgqpmiv3j20u004wdg7.jpg\" alt=\"\"><br>每个线程往ThreadLocal中读写数据是线程隔离，互相之间不会影响的，所以ThreadLocal无法解决共享对象的更新问题！<br>由于不需要共享信息，自然就不存在竞争问题了，从而保证了某些情况下线程的安全，以及避免了某些情况需要考虑线程安全必须同步带来的性能损失！<br>这类场景阿里规范里面也提到了：<br><img src=\"http://ww1.sinaimg.cn/large/8515e8c2ly1g4bgtmiyk7j20u008rt92.jpg\" alt=\"\"></p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"ThreadLocal一些细节\"><a href=\"#ThreadLocal一些细节\" class=\"headerlink\" title=\"ThreadLocal一些细节\"></a>ThreadLocal一些细节</h2><p>ThreaLocal使用示例代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ThreadLocalTest &#123;</span><br><span class=\"line\">    private static ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        new Thread(() -&gt; &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class=\"line\">                    // 给该线程的设置值</span><br><span class=\"line\">                    threadLocal.set(i);</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + &quot;====&quot; + threadLocal.get());</span><br><span class=\"line\">                    try &#123;</span><br><span class=\"line\">                        Thread.sleep(200);</span><br><span class=\"line\">                    &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; finally &#123;</span><br><span class=\"line\">                threadLocal.remove();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, &quot;threadLocal1&quot;).start();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        new Thread(() -&gt; &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + &quot;====&quot; + threadLocal.get());</span><br><span class=\"line\">                    try &#123;</span><br><span class=\"line\">                        Thread.sleep(200);</span><br><span class=\"line\">                    &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; finally &#123;</span><br><span class=\"line\">                threadLocal.remove();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, &quot;threadLocal2&quot;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>代码运行结果：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/8515e8c2ly1g4bgvby07kj20dp0723yi.jpg\" alt=\"\"></p>\n<p>从运行的结果我们可以看到<code>threadLocal1</code>进行<code>set()</code>值对<code>threadLocal2</code>并<strong>没有任何影响</strong>！</p>\n<ul>\n<li><p><code>Thread</code>、<code>ThreadLocalMap</code>、<code>ThreadLocal</code>总览图：<br><img src=\"http://ww1.sinaimg.cn/large/8515e8c2ly1g4bgym7f89j20tq0m00t2.jpg\" alt=\"\"></p>\n</li>\n<li><p><code>Thread</code>类有属性变量<code>threadLocals</code>（类型是<code>ThreadLocal.ThreadLocalMap</code>），也就是说每个线程有一个自己的<code>ThreadLocalMap</code> ，所以每个线程往这个<code>ThreadLocal</code>中读写隔离的，并且是互相不会影响的。<br><img src=\"http://ww1.sinaimg.cn/large/8515e8c2ly1g4bgz6eds7j20nd040weh.jpg\" alt=\"\"></p>\n</li>\n<li><p>一个<code>ThreadLocal</code>只能存储一个<code>Object</code>对象，如果需要存储多个<code>Object</code>对象那么就需要多个<code>ThreadLocal</code>。<br>如图：<br><img src=\"http://ww1.sinaimg.cn/large/8515e8c2ly1g4bh2dmh7cj20ts0m2dgg.jpg\" alt=\"\"><br>看到上面的几个图，大概思路应该都清晰了，我们<code>Entry</code>的<code>key</code>指向<code>ThreadLocal</code>用虚线表示弱引用 ，下面我们来看看<code>ThreadLocalMap</code>:<br><img src=\"http://ww1.sinaimg.cn/large/8515e8c2ly1g4bh3liojaj20na0c0jrt.jpg\" alt=\"\"></p>\n</li>\n<li><p>java对象的引用包括 ： <strong>强引用</strong>，<strong>软引用</strong>，<strong>弱引用</strong>，<strong>虚引用</strong>。因为这里涉及到 <strong>弱引用</strong>，简单说明下：</p>\n<blockquote>\n<p>弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，该对象仅仅被弱引用关联，那么就会被回收。当仅仅只有ThreadLocalMap中的Entry的key指向ThreadLocal的时候，ThreadLocal会进行回收的！ThreadLocal被垃圾回收后，在ThreadLocalMap里对应的Entry的键值会变成null，但是Entry是强引用，那么Entry里面存储的Object，并没有办法进行回收，所以ThreadLocalMap 做了一些额外的回收工作。<br><img src=\"http://ww1.sinaimg.cn/large/8515e8c2ly1g4bh6khf5kj20u00dhdgl.jpg\" alt=\"\"><br>虽然做了但是也会存在内存泄漏风险（我没有遇到过，网上很多类似场景，所以会提到后面的ThreadLocal最佳实践！）</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"ThreadLocal的最佳实践！\"><a href=\"#ThreadLocal的最佳实践！\" class=\"headerlink\" title=\"ThreadLocal的最佳实践！\"></a>ThreadLocal的最佳实践！</h2><p>很多时候，我们都是用在线程池的场景，程序不停止，线程基本不会销毁！<br>由于线程的生命周期很长，如果我们往ThreadLocal里面set了很大很大的Object对象，虽然set、get等等方法在特定的条件会调用进行额外的清理，<strong>但是ThreadLocal被垃圾回收后，在ThreadLocalMap里对应的Entry的键值会变成null，但是后续在也没有操作set、get等方法了</strong>。</p>\n<p>所以最佳实践，应该在我们不使用的时候，主动调用remove方法进行清理。<br><img src=\"http://ww1.sinaimg.cn/large/8515e8c2ly1g4bha0clrkj20u004xmxi.jpg\" alt=\"\"><br>这里把ThreadLocal定义为static还有一个好处就是，由于ThreadLocal有强引用在，那么在ThreadLocalMap里对应的Entry的键会永远存在，那么执行remove的时候就可以正确进行定位到并且删除！</p>\n<h2 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h2><p>如果面试的时候，可以把上面的内容都可以讲到，个人觉得就非常好了，回答的就挺完美了。但是如果你可以进行下面的回答，那么就更完美了。</p>\n<p>对于ThreadLocal，我在看Netty源码的时候，还了解过FastThreadLocal，xxxxx一些列内容，那就是一个升级了。<br><img src=\"http://ww1.sinaimg.cn/large/8515e8c2ly1g4bhbtior6j20u00ijwf4.jpg\" alt=\"\"><br>在我本地进行测试，FastThreadLocal的吞吐量是jdkThreadLocal的3倍左右。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"参考引用\"><a href=\"#参考引用\" class=\"headerlink\" title=\"参考引用\"></a>参考引用</h2><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU2NjIzNDk5NQ==&amp;mid=2247486666&amp;idx=1&amp;sn=ee9d72b115411940940f00171986e0db&amp;chksm=fcaed6d6cbd95fc08cf5525e7974efc7753f9f018f2a79fd5386b9f0132b90645394e85c3568&amp;mpshare=1&amp;scene=1&amp;srcid=#rd\" target=\"_blank\" rel=\"noopener\">手撕面试题ThreadLocal！！！</a></p>\n<h2 id=\"ThreadLocal是什么？\"><a href=\"#ThreadLocal是什么？\" class=\"headerlink\" title=\"ThreadLocal是什么？\"></a>ThreadLocal是什么？</h2><p>面试官：讲讲你对ThreadLocal的一些理解。</p>\n<p>那么我们该怎么回答呢？你也可以思考下，下面看看零度的思考；</p>\n<ul>\n<li><p>ThreadLocal用在什么地方？</p>\n</li>\n<li><p>ThreadLocal一些细节！</p>\n</li>\n<li><p>ThreadLocal的最佳实践！</p>\n</li>\n<li><p>思考！</p>\n</li>\n</ul>","more":"<h2 id=\"ThreadLocal用在什么地方？\"><a href=\"#ThreadLocal用在什么地方？\" class=\"headerlink\" title=\"ThreadLocal用在什么地方？\"></a>ThreadLocal用在什么地方？</h2><p>讨论ThreadLocal用在什么地方前，我们先明确下，如果仅仅就一个线程，那么都不用谈ThreadLocal的，ThreadLocal是用在多线程的场景的！<br>ThreadLocal归纳下来就2类用途：</p>\n<ul>\n<li>保存线程上下文信息，在任意需要的地方可以获取！<blockquote>\n<p>1、由于ThreadLocal的特性，同一线程在某地方进行设置，在随后的任意地方都可以获取到。从而可以用来保存线程上下文信息。<br>2、常用的比如每个请求怎么把一串后续关联起来，就可以用ThreadLocal进行set，在后续的任意需要记录日志的方法里面进行get获取到请求id，从而把整个请求串起来。<br>3、还有比如Spring的事务管理，用ThreadLocal存储Connection，从而各个DAO可以获取同一Connection，可以进行事务回滚，提交等操作。<br>备注：ThreadLocal的这种用处，很多时候是用在一些优秀的框架里面的，一般我们很少接触，反而下面的场景我们接触的更多一些！</p>\n</blockquote>\n</li>\n<li>线程安全的，避免某些情况需要考虑线程安全必须同步带来的性能损失！<blockquote>\n<p>ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。但是ThreadLocal也有局限性，我们来看看阿里规范：<br><img src=\"http://ww1.sinaimg.cn/large/8515e8c2ly1g4bgqpmiv3j20u004wdg7.jpg\" alt=\"\"><br>每个线程往ThreadLocal中读写数据是线程隔离，互相之间不会影响的，所以ThreadLocal无法解决共享对象的更新问题！<br>由于不需要共享信息，自然就不存在竞争问题了，从而保证了某些情况下线程的安全，以及避免了某些情况需要考虑线程安全必须同步带来的性能损失！<br>这类场景阿里规范里面也提到了：<br><img src=\"http://ww1.sinaimg.cn/large/8515e8c2ly1g4bgtmiyk7j20u008rt92.jpg\" alt=\"\"></p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"ThreadLocal一些细节\"><a href=\"#ThreadLocal一些细节\" class=\"headerlink\" title=\"ThreadLocal一些细节\"></a>ThreadLocal一些细节</h2><p>ThreaLocal使用示例代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ThreadLocalTest &#123;</span><br><span class=\"line\">    private static ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        new Thread(() -&gt; &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class=\"line\">                    // 给该线程的设置值</span><br><span class=\"line\">                    threadLocal.set(i);</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + &quot;====&quot; + threadLocal.get());</span><br><span class=\"line\">                    try &#123;</span><br><span class=\"line\">                        Thread.sleep(200);</span><br><span class=\"line\">                    &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; finally &#123;</span><br><span class=\"line\">                threadLocal.remove();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, &quot;threadLocal1&quot;).start();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        new Thread(() -&gt; &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + &quot;====&quot; + threadLocal.get());</span><br><span class=\"line\">                    try &#123;</span><br><span class=\"line\">                        Thread.sleep(200);</span><br><span class=\"line\">                    &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; finally &#123;</span><br><span class=\"line\">                threadLocal.remove();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, &quot;threadLocal2&quot;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>代码运行结果：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/8515e8c2ly1g4bgvby07kj20dp0723yi.jpg\" alt=\"\"></p>\n<p>从运行的结果我们可以看到<code>threadLocal1</code>进行<code>set()</code>值对<code>threadLocal2</code>并<strong>没有任何影响</strong>！</p>\n<ul>\n<li><p><code>Thread</code>、<code>ThreadLocalMap</code>、<code>ThreadLocal</code>总览图：<br><img src=\"http://ww1.sinaimg.cn/large/8515e8c2ly1g4bgym7f89j20tq0m00t2.jpg\" alt=\"\"></p>\n</li>\n<li><p><code>Thread</code>类有属性变量<code>threadLocals</code>（类型是<code>ThreadLocal.ThreadLocalMap</code>），也就是说每个线程有一个自己的<code>ThreadLocalMap</code> ，所以每个线程往这个<code>ThreadLocal</code>中读写隔离的，并且是互相不会影响的。<br><img src=\"http://ww1.sinaimg.cn/large/8515e8c2ly1g4bgz6eds7j20nd040weh.jpg\" alt=\"\"></p>\n</li>\n<li><p>一个<code>ThreadLocal</code>只能存储一个<code>Object</code>对象，如果需要存储多个<code>Object</code>对象那么就需要多个<code>ThreadLocal</code>。<br>如图：<br><img src=\"http://ww1.sinaimg.cn/large/8515e8c2ly1g4bh2dmh7cj20ts0m2dgg.jpg\" alt=\"\"><br>看到上面的几个图，大概思路应该都清晰了，我们<code>Entry</code>的<code>key</code>指向<code>ThreadLocal</code>用虚线表示弱引用 ，下面我们来看看<code>ThreadLocalMap</code>:<br><img src=\"http://ww1.sinaimg.cn/large/8515e8c2ly1g4bh3liojaj20na0c0jrt.jpg\" alt=\"\"></p>\n</li>\n<li><p>java对象的引用包括 ： <strong>强引用</strong>，<strong>软引用</strong>，<strong>弱引用</strong>，<strong>虚引用</strong>。因为这里涉及到 <strong>弱引用</strong>，简单说明下：</p>\n<blockquote>\n<p>弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，该对象仅仅被弱引用关联，那么就会被回收。当仅仅只有ThreadLocalMap中的Entry的key指向ThreadLocal的时候，ThreadLocal会进行回收的！ThreadLocal被垃圾回收后，在ThreadLocalMap里对应的Entry的键值会变成null，但是Entry是强引用，那么Entry里面存储的Object，并没有办法进行回收，所以ThreadLocalMap 做了一些额外的回收工作。<br><img src=\"http://ww1.sinaimg.cn/large/8515e8c2ly1g4bh6khf5kj20u00dhdgl.jpg\" alt=\"\"><br>虽然做了但是也会存在内存泄漏风险（我没有遇到过，网上很多类似场景，所以会提到后面的ThreadLocal最佳实践！）</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"ThreadLocal的最佳实践！\"><a href=\"#ThreadLocal的最佳实践！\" class=\"headerlink\" title=\"ThreadLocal的最佳实践！\"></a>ThreadLocal的最佳实践！</h2><p>很多时候，我们都是用在线程池的场景，程序不停止，线程基本不会销毁！<br>由于线程的生命周期很长，如果我们往ThreadLocal里面set了很大很大的Object对象，虽然set、get等等方法在特定的条件会调用进行额外的清理，<strong>但是ThreadLocal被垃圾回收后，在ThreadLocalMap里对应的Entry的键值会变成null，但是后续在也没有操作set、get等方法了</strong>。</p>\n<p>所以最佳实践，应该在我们不使用的时候，主动调用remove方法进行清理。<br><img src=\"http://ww1.sinaimg.cn/large/8515e8c2ly1g4bha0clrkj20u004xmxi.jpg\" alt=\"\"><br>这里把ThreadLocal定义为static还有一个好处就是，由于ThreadLocal有强引用在，那么在ThreadLocalMap里对应的Entry的键会永远存在，那么执行remove的时候就可以正确进行定位到并且删除！</p>\n<h2 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h2><p>如果面试的时候，可以把上面的内容都可以讲到，个人觉得就非常好了，回答的就挺完美了。但是如果你可以进行下面的回答，那么就更完美了。</p>\n<p>对于ThreadLocal，我在看Netty源码的时候，还了解过FastThreadLocal，xxxxx一些列内容，那就是一个升级了。<br><img src=\"http://ww1.sinaimg.cn/large/8515e8c2ly1g4bhbtior6j20u00ijwf4.jpg\" alt=\"\"><br>在我本地进行测试，FastThreadLocal的吞吐量是jdkThreadLocal的3倍左右。</p>"},{"title":"Thread类阅读笔记","abbrlink":"9c02c64f","date":"2017-12-04T13:53:21.000Z","_content":"Thread类在工作的过程中接触的少，也一直没花时间去细细阅读，Thread类是一个很重要的类，下面从Thread类的源码开刀喽。\n<!-- more -->\n```\npublic\nclass Thread implements Runnable {\n    /* Make sure registerNatives is the first thing <clinit> does. */\n    private static native void registerNatives();\n    static {\n        registerNatives();\n    }\n\n    private char        name[];         //线程名\n    private int         priority;       //线程的优先级\n    private Thread      threadQ;\n    private long        eetop;\n\n    /* Whether or not to single_step this thread. */\n    private boolean     single_step;\n\n    /* Whether or not the thread is a daemon thread. 是否为守护线程*/\n    private boolean     daemon = false;\n\n    /* JVM state 是否*/\n    private boolean     stillborn = false;\n\n    /* What will be run. 要执行的任务*/\n    private Runnable target;\n\n    /* The group of this thread */\n    private ThreadGroup group;\n\n    /* The context ClassLoader for this thread */\n    private ClassLoader contextClassLoader;\n\n    /* The inherited AccessControlContext of this thread */\n    private AccessControlContext inheritedAccessControlContext;\n\n    、、、、\n}\n```\n## 相关属性\nThread类实现了Runnable接口，在Thread类中，有一些比较关键的属性，比如name是表示Thread的名字，可以通过Thread类的构造器中的参数来指定线程名字，priority表示线程的优先级（最大值为10，最小值为1，默认值为5），daemon表示线程是否是守护线程，target表示要执行的任务。\n## 方法介绍\n### start()方法用synchronized关键字修饰\n```\npublic synchronized void start() {}\n```\n- synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：\n    1. **代码块：**被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；\n    2. **方法：**被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；\n    3. **静态：**的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；\n    4. **类：**其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。\nstart()用来启动一个线程，当调用start方法后，系统才会开启一个新的线程来执行用户定义的子任务，在这个过程中，会为相应的线程分配需要的资源。\n### run()方法\n    ```\n    @Override\n    public void run() {\n        if (target != null) {\n            target.run();\n        }\n    }\n    ```\n    run()方法是不需要用户来调用的，当通过start方法启动一个线程之后，当线程获得了CPU执行时间，便进入run方法体去执行具体的任务。注意，继承Thread类必须重写run方法，在run方法中定义具体要执行的任务。\n### sleep()方法,有两个重载的版本。\n    ```\n  - public static native void sleep(long millis) throws InterruptedException;\n  - public static void sleep(long millis, int nanos)\n    throws InterruptedException {\n        if (millis < 0) {\n            throw new IllegalArgumentException(\"timeout value is negative\");\n        }\n\n        if (nanos < 0 || nanos > 999999) {\n            throw new IllegalArgumentException(\n                                \"nanosecond timeout value out of range\");\n        }\n\n        if (nanos >= 500000 || (nanos != 0 && millis == 0)) {\n            millis++;\n        }\n\n        sleep(millis);\n    }\n    ```\n    sleep相当于让线程睡眠，交出CPU，让CPU去执行其他的任务。但是有一点要非常注意，sleep方法不会释放锁，也就是说如果当前线程持有对某个对象的锁，则即使调用sleep方法，其他线程也无法访问这个对象。下面举个例子简单说明。\n    - 新建线程类SThread，继承Thread类。\n    ```\n    package club.sdll.blog.thread;\n    public class SThread extends Thread {\n        private static Object object = new Object();\n        private static int count = 1; \n        @Override\n        public void run() {\n            synchronized(object) {\n                System.out.println(\"start count  ===  \" + count);\n                System.out.println(\"我是线程  ===  \" + Thread.currentThread().getName());\n                System.out.println(Thread.currentThread().getName() + \"睡眠开始 === \" + count);\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread().getName() + \"睡眠结束 === \" + count);\n                count++;\n                System.out.println(\"end   count  ===  \" + count);\n            }\n        }\n    }\n\n    ```\n    Test测试类。\n    ```\n    package club.sdll.blog.thread;\n    public class Test {\n        public static void main(String[] args) {\n            SThread cat = new SThread();\n            cat.setName(\"小猫\");\n            SThread dog = new SThread();\n            dog.setName(\"小狗\");\n            cat.start();\n            dog.start();\n        }\n    }\n\n    ```\n    - 有**syschronized同步锁**的情况测试结果：\n        ![](http://ozux0lqfa.bkt.clouddn.com/%E6%9C%89%E5%90%8C%E6%AD%A5%E9%94%81%E7%9A%84%E7%BB%93%E6%9E%9C.png)\n        从上面输出结果可以看出，当**小猫thread**进入睡眠状态之后，**小狗thread**并没有去执行具体的任务。只有当**小猫thread**执行完之后，此时**小猫thread**释放了对象锁`object`，**小狗thread**才开始执行。当线程睡眠时间满后，不一定会立即得到执行，因为此时可能CPU正在执行其他的任务。所以说调用sleep方法相当于让线程进入阻塞状态。\n    - 没有同步锁**synchronized(object) {}**的结果：两个线程同时都在争抢时间片\n        ![](http://ozux0lqfa.bkt.clouddn.com/%E6%B2%A1%E6%9C%89%E5%90%8C%E6%AD%A5%E9%94%81%E7%9A%84%E7%BB%93%E6%9E%9C.png)\n### yield()方法\n调用yield方法会让当前线程交出CPU权限，让CPU去执行其他的线程。它跟sleep方法类似，同样不会释放锁。但是yield不能控制具体的交出CPU的时间，另外，yield方法只能让拥有相同优先级的线程有获取CPU执行时间的机会。注意，调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的。\n### join()方法\n假如在main线程中，调用thread.join方法，则main方法会等待thread线程执行完毕或者等待一定的时间。如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的时间。\n```\npackage club.sdll.blog.thread;\nimport java.io.IOException;\npublic class Test2 {\n    public static void main(String[] args) throws IOException  {\n        System.out.println(\"进入线程“\"+Thread.currentThread().getName()+\"”\");\n        Test2 test2 = new Test2();\n        SThread thread = test2.new SThread();\n        thread.start();\n        try {\n            System.out.println(\"线程“\"+Thread.currentThread().getName()+\"”等待\");\n            thread.join();\n            System.out.println(\"线程“\"+Thread.currentThread().getName()+\"”继续执行\");\n        } catch (InterruptedException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    } \n     \n    class SThread extends Thread{\n        @Override\n        public void run() {\n            System.out.println(\"进入线程“\"+Thread.currentThread().getName()+\"”\");\n            try {\n                Thread.currentThread().sleep(5000);\n                System.out.println(\"线程“\"+Thread.currentThread().getName() + \"”休眠5秒\");\n            } catch (InterruptedException e) {\n                // TODO: handle exception\n            }\n            System.out.println(\"离开线程“\"+Thread.currentThread().getName()+\"”\");\n        }\n    }\n}\n\n```\n控制台打印结果：\n![](http://ozux0lqfa.bkt.clouddn.com/join%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95.png)\n\n### 未完待续\n\n**参考文章：**\nhttps://www.cnblogs.com/franson-2016/p/5498221.html\n    ","source":"_posts/Thread类阅读笔记.md","raw":"---\ntitle: Thread类阅读笔记\ntags:\n  - JAVA\n  - jdk源码\nabbrlink: 9c02c64f\ndate: 2017-12-04 21:53:21\n---\nThread类在工作的过程中接触的少，也一直没花时间去细细阅读，Thread类是一个很重要的类，下面从Thread类的源码开刀喽。\n<!-- more -->\n```\npublic\nclass Thread implements Runnable {\n    /* Make sure registerNatives is the first thing <clinit> does. */\n    private static native void registerNatives();\n    static {\n        registerNatives();\n    }\n\n    private char        name[];         //线程名\n    private int         priority;       //线程的优先级\n    private Thread      threadQ;\n    private long        eetop;\n\n    /* Whether or not to single_step this thread. */\n    private boolean     single_step;\n\n    /* Whether or not the thread is a daemon thread. 是否为守护线程*/\n    private boolean     daemon = false;\n\n    /* JVM state 是否*/\n    private boolean     stillborn = false;\n\n    /* What will be run. 要执行的任务*/\n    private Runnable target;\n\n    /* The group of this thread */\n    private ThreadGroup group;\n\n    /* The context ClassLoader for this thread */\n    private ClassLoader contextClassLoader;\n\n    /* The inherited AccessControlContext of this thread */\n    private AccessControlContext inheritedAccessControlContext;\n\n    、、、、\n}\n```\n## 相关属性\nThread类实现了Runnable接口，在Thread类中，有一些比较关键的属性，比如name是表示Thread的名字，可以通过Thread类的构造器中的参数来指定线程名字，priority表示线程的优先级（最大值为10，最小值为1，默认值为5），daemon表示线程是否是守护线程，target表示要执行的任务。\n## 方法介绍\n### start()方法用synchronized关键字修饰\n```\npublic synchronized void start() {}\n```\n- synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：\n    1. **代码块：**被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；\n    2. **方法：**被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；\n    3. **静态：**的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；\n    4. **类：**其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。\nstart()用来启动一个线程，当调用start方法后，系统才会开启一个新的线程来执行用户定义的子任务，在这个过程中，会为相应的线程分配需要的资源。\n### run()方法\n    ```\n    @Override\n    public void run() {\n        if (target != null) {\n            target.run();\n        }\n    }\n    ```\n    run()方法是不需要用户来调用的，当通过start方法启动一个线程之后，当线程获得了CPU执行时间，便进入run方法体去执行具体的任务。注意，继承Thread类必须重写run方法，在run方法中定义具体要执行的任务。\n### sleep()方法,有两个重载的版本。\n    ```\n  - public static native void sleep(long millis) throws InterruptedException;\n  - public static void sleep(long millis, int nanos)\n    throws InterruptedException {\n        if (millis < 0) {\n            throw new IllegalArgumentException(\"timeout value is negative\");\n        }\n\n        if (nanos < 0 || nanos > 999999) {\n            throw new IllegalArgumentException(\n                                \"nanosecond timeout value out of range\");\n        }\n\n        if (nanos >= 500000 || (nanos != 0 && millis == 0)) {\n            millis++;\n        }\n\n        sleep(millis);\n    }\n    ```\n    sleep相当于让线程睡眠，交出CPU，让CPU去执行其他的任务。但是有一点要非常注意，sleep方法不会释放锁，也就是说如果当前线程持有对某个对象的锁，则即使调用sleep方法，其他线程也无法访问这个对象。下面举个例子简单说明。\n    - 新建线程类SThread，继承Thread类。\n    ```\n    package club.sdll.blog.thread;\n    public class SThread extends Thread {\n        private static Object object = new Object();\n        private static int count = 1; \n        @Override\n        public void run() {\n            synchronized(object) {\n                System.out.println(\"start count  ===  \" + count);\n                System.out.println(\"我是线程  ===  \" + Thread.currentThread().getName());\n                System.out.println(Thread.currentThread().getName() + \"睡眠开始 === \" + count);\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread().getName() + \"睡眠结束 === \" + count);\n                count++;\n                System.out.println(\"end   count  ===  \" + count);\n            }\n        }\n    }\n\n    ```\n    Test测试类。\n    ```\n    package club.sdll.blog.thread;\n    public class Test {\n        public static void main(String[] args) {\n            SThread cat = new SThread();\n            cat.setName(\"小猫\");\n            SThread dog = new SThread();\n            dog.setName(\"小狗\");\n            cat.start();\n            dog.start();\n        }\n    }\n\n    ```\n    - 有**syschronized同步锁**的情况测试结果：\n        ![](http://ozux0lqfa.bkt.clouddn.com/%E6%9C%89%E5%90%8C%E6%AD%A5%E9%94%81%E7%9A%84%E7%BB%93%E6%9E%9C.png)\n        从上面输出结果可以看出，当**小猫thread**进入睡眠状态之后，**小狗thread**并没有去执行具体的任务。只有当**小猫thread**执行完之后，此时**小猫thread**释放了对象锁`object`，**小狗thread**才开始执行。当线程睡眠时间满后，不一定会立即得到执行，因为此时可能CPU正在执行其他的任务。所以说调用sleep方法相当于让线程进入阻塞状态。\n    - 没有同步锁**synchronized(object) {}**的结果：两个线程同时都在争抢时间片\n        ![](http://ozux0lqfa.bkt.clouddn.com/%E6%B2%A1%E6%9C%89%E5%90%8C%E6%AD%A5%E9%94%81%E7%9A%84%E7%BB%93%E6%9E%9C.png)\n### yield()方法\n调用yield方法会让当前线程交出CPU权限，让CPU去执行其他的线程。它跟sleep方法类似，同样不会释放锁。但是yield不能控制具体的交出CPU的时间，另外，yield方法只能让拥有相同优先级的线程有获取CPU执行时间的机会。注意，调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的。\n### join()方法\n假如在main线程中，调用thread.join方法，则main方法会等待thread线程执行完毕或者等待一定的时间。如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的时间。\n```\npackage club.sdll.blog.thread;\nimport java.io.IOException;\npublic class Test2 {\n    public static void main(String[] args) throws IOException  {\n        System.out.println(\"进入线程“\"+Thread.currentThread().getName()+\"”\");\n        Test2 test2 = new Test2();\n        SThread thread = test2.new SThread();\n        thread.start();\n        try {\n            System.out.println(\"线程“\"+Thread.currentThread().getName()+\"”等待\");\n            thread.join();\n            System.out.println(\"线程“\"+Thread.currentThread().getName()+\"”继续执行\");\n        } catch (InterruptedException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    } \n     \n    class SThread extends Thread{\n        @Override\n        public void run() {\n            System.out.println(\"进入线程“\"+Thread.currentThread().getName()+\"”\");\n            try {\n                Thread.currentThread().sleep(5000);\n                System.out.println(\"线程“\"+Thread.currentThread().getName() + \"”休眠5秒\");\n            } catch (InterruptedException e) {\n                // TODO: handle exception\n            }\n            System.out.println(\"离开线程“\"+Thread.currentThread().getName()+\"”\");\n        }\n    }\n}\n\n```\n控制台打印结果：\n![](http://ozux0lqfa.bkt.clouddn.com/join%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95.png)\n\n### 未完待续\n\n**参考文章：**\nhttps://www.cnblogs.com/franson-2016/p/5498221.html\n    ","slug":"Thread类阅读笔记","published":1,"updated":"2017-12-14T13:55:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2w200vb000cmwd3gw9rf1vo","content":"<p>Thread类在工作的过程中接触的少，也一直没花时间去细细阅读，Thread类是一个很重要的类，下面从Thread类的源码开刀喽。<br><a id=\"more\"></a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public</span><br><span class=\"line\">class Thread implements Runnable &#123;</span><br><span class=\"line\">    /* Make sure registerNatives is the first thing &lt;clinit&gt; does. */</span><br><span class=\"line\">    private static native void registerNatives();</span><br><span class=\"line\">    static &#123;</span><br><span class=\"line\">        registerNatives();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private char        name[];         //线程名</span><br><span class=\"line\">    private int         priority;       //线程的优先级</span><br><span class=\"line\">    private Thread      threadQ;</span><br><span class=\"line\">    private long        eetop;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* Whether or not to single_step this thread. */</span><br><span class=\"line\">    private boolean     single_step;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* Whether or not the thread is a daemon thread. 是否为守护线程*/</span><br><span class=\"line\">    private boolean     daemon = false;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* JVM state 是否*/</span><br><span class=\"line\">    private boolean     stillborn = false;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* What will be run. 要执行的任务*/</span><br><span class=\"line\">    private Runnable target;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* The group of this thread */</span><br><span class=\"line\">    private ThreadGroup group;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* The context ClassLoader for this thread */</span><br><span class=\"line\">    private ClassLoader contextClassLoader;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* The inherited AccessControlContext of this thread */</span><br><span class=\"line\">    private AccessControlContext inheritedAccessControlContext;</span><br><span class=\"line\"></span><br><span class=\"line\">    、、、、</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"相关属性\"><a href=\"#相关属性\" class=\"headerlink\" title=\"相关属性\"></a>相关属性</h2><p>Thread类实现了Runnable接口，在Thread类中，有一些比较关键的属性，比如name是表示Thread的名字，可以通过Thread类的构造器中的参数来指定线程名字，priority表示线程的优先级（最大值为10，最小值为1，默认值为5），daemon表示线程是否是守护线程，target表示要执行的任务。</p>\n<h2 id=\"方法介绍\"><a href=\"#方法介绍\" class=\"headerlink\" title=\"方法介绍\"></a>方法介绍</h2><h3 id=\"start-方法用synchronized关键字修饰\"><a href=\"#start-方法用synchronized关键字修饰\" class=\"headerlink\" title=\"start()方法用synchronized关键字修饰\"></a>start()方法用synchronized关键字修饰</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public synchronized void start() &#123;&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：</p>\n<ol>\n<li><strong>代码块：</strong>被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；</li>\n<li><strong>方法：</strong>被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</li>\n<li><strong>静态：</strong>的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；</li>\n<li><p><strong>类：</strong>其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。<br>start()用来启动一个线程，当调用start方法后，系统才会开启一个新的线程来执行用户定义的子任务，在这个过程中，会为相应的线程分配需要的资源。</p>\n<h3 id=\"run-方法\"><a href=\"#run-方法\" class=\"headerlink\" title=\"run()方法\"></a>run()方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void run() &#123;</span><br><span class=\"line\">    if (target != null) &#123;</span><br><span class=\"line\">        target.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>run()方法是不需要用户来调用的，当通过start方法启动一个线程之后，当线程获得了CPU执行时间，便进入run方法体去执行具体的任务。注意，继承Thread类必须重写run方法，在run方法中定义具体要执行的任务。</p>\n<h3 id=\"sleep-方法-有两个重载的版本。\"><a href=\"#sleep-方法-有两个重载的版本。\" class=\"headerlink\" title=\"sleep()方法,有两个重载的版本。\"></a>sleep()方法,有两个重载的版本。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- public static native void sleep(long millis) throws InterruptedException;</span><br><span class=\"line\">- public static void sleep(long millis, int nanos)</span><br><span class=\"line\">  throws InterruptedException &#123;</span><br><span class=\"line\">      if (millis &lt; 0) &#123;</span><br><span class=\"line\">          throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (nanos &lt; 0 || nanos &gt; 999999) &#123;</span><br><span class=\"line\">          throw new IllegalArgumentException(</span><br><span class=\"line\">                              &quot;nanosecond timeout value out of range&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (nanos &gt;= 500000 || (nanos != 0 &amp;&amp; millis == 0)) &#123;</span><br><span class=\"line\">          millis++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      sleep(millis);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>sleep相当于让线程睡眠，交出CPU，让CPU去执行其他的任务。但是有一点要非常注意，sleep方法不会释放锁，也就是说如果当前线程持有对某个对象的锁，则即使调用sleep方法，其他线程也无法访问这个对象。下面举个例子简单说明。</p>\n</li>\n</ol>\n<ul>\n<li><p>新建线程类SThread，继承Thread类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package club.sdll.blog.thread;</span><br><span class=\"line\">public class SThread extends Thread &#123;</span><br><span class=\"line\">    private static Object object = new Object();</span><br><span class=\"line\">    private static int count = 1; </span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        synchronized(object) &#123;</span><br><span class=\"line\">            System.out.println(&quot;start count  ===  &quot; + count);</span><br><span class=\"line\">            System.out.println(&quot;我是线程  ===  &quot; + Thread.currentThread().getName());</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + &quot;睡眠开始 === &quot; + count);</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                Thread.sleep(1000);</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + &quot;睡眠结束 === &quot; + count);</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">            System.out.println(&quot;end   count  ===  &quot; + count);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Test测试类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package club.sdll.blog.thread;</span><br><span class=\"line\">public class Test &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        SThread cat = new SThread();</span><br><span class=\"line\">        cat.setName(&quot;小猫&quot;);</span><br><span class=\"line\">        SThread dog = new SThread();</span><br><span class=\"line\">        dog.setName(&quot;小狗&quot;);</span><br><span class=\"line\">        cat.start();</span><br><span class=\"line\">        dog.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>有<strong>syschronized同步锁</strong>的情况测试结果：<br>  <img src=\"http://ozux0lqfa.bkt.clouddn.com/%E6%9C%89%E5%90%8C%E6%AD%A5%E9%94%81%E7%9A%84%E7%BB%93%E6%9E%9C.png\" alt=\"\"><br>  从上面输出结果可以看出，当<strong>小猫thread</strong>进入睡眠状态之后，<strong>小狗thread</strong>并没有去执行具体的任务。只有当<strong>小猫thread</strong>执行完之后，此时<strong>小猫thread</strong>释放了对象锁<code>object</code>，<strong>小狗thread</strong>才开始执行。当线程睡眠时间满后，不一定会立即得到执行，因为此时可能CPU正在执行其他的任务。所以说调用sleep方法相当于让线程进入阻塞状态。</p>\n</li>\n<li>没有同步锁<strong>synchronized(object) {}</strong>的结果：两个线程同时都在争抢时间片<br>  <img src=\"http://ozux0lqfa.bkt.clouddn.com/%E6%B2%A1%E6%9C%89%E5%90%8C%E6%AD%A5%E9%94%81%E7%9A%84%E7%BB%93%E6%9E%9C.png\" alt=\"\"><h3 id=\"yield-方法\"><a href=\"#yield-方法\" class=\"headerlink\" title=\"yield()方法\"></a>yield()方法</h3>调用yield方法会让当前线程交出CPU权限，让CPU去执行其他的线程。它跟sleep方法类似，同样不会释放锁。但是yield不能控制具体的交出CPU的时间，另外，yield方法只能让拥有相同优先级的线程有获取CPU执行时间的机会。注意，调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的。<h3 id=\"join-方法\"><a href=\"#join-方法\" class=\"headerlink\" title=\"join()方法\"></a>join()方法</h3>假如在main线程中，调用thread.join方法，则main方法会等待thread线程执行完毕或者等待一定的时间。如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的时间。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package club.sdll.blog.thread;</span><br><span class=\"line\">import java.io.IOException;</span><br><span class=\"line\">public class Test2 &#123;</span><br><span class=\"line\">    public static void main(String[] args) throws IOException  &#123;</span><br><span class=\"line\">        System.out.println(&quot;进入线程“&quot;+Thread.currentThread().getName()+&quot;”&quot;);</span><br><span class=\"line\">        Test2 test2 = new Test2();</span><br><span class=\"line\">        SThread thread = test2.new SThread();</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            System.out.println(&quot;线程“&quot;+Thread.currentThread().getName()+&quot;”等待&quot;);</span><br><span class=\"line\">            thread.join();</span><br><span class=\"line\">            System.out.println(&quot;线程“&quot;+Thread.currentThread().getName()+&quot;”继续执行&quot;);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            // TODO Auto-generated catch block</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">     </span><br><span class=\"line\">    class SThread extends Thread&#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            System.out.println(&quot;进入线程“&quot;+Thread.currentThread().getName()+&quot;”&quot;);</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                Thread.currentThread().sleep(5000);</span><br><span class=\"line\">                System.out.println(&quot;线程“&quot;+Thread.currentThread().getName() + &quot;”休眠5秒&quot;);</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                // TODO: handle exception</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(&quot;离开线程“&quot;+Thread.currentThread().getName()+&quot;”&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>控制台打印结果：<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/join%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95.png\" alt=\"\"></p>\n<h3 id=\"未完待续\"><a href=\"#未完待续\" class=\"headerlink\" title=\"未完待续\"></a>未完待续</h3><p><strong>参考文章：</strong><br><a href=\"https://www.cnblogs.com/franson-2016/p/5498221.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/franson-2016/p/5498221.html</a></p>\n","site":{"data":{}},"excerpt":"<p>Thread类在工作的过程中接触的少，也一直没花时间去细细阅读，Thread类是一个很重要的类，下面从Thread类的源码开刀喽。<br>","more":"<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public</span><br><span class=\"line\">class Thread implements Runnable &#123;</span><br><span class=\"line\">    /* Make sure registerNatives is the first thing &lt;clinit&gt; does. */</span><br><span class=\"line\">    private static native void registerNatives();</span><br><span class=\"line\">    static &#123;</span><br><span class=\"line\">        registerNatives();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private char        name[];         //线程名</span><br><span class=\"line\">    private int         priority;       //线程的优先级</span><br><span class=\"line\">    private Thread      threadQ;</span><br><span class=\"line\">    private long        eetop;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* Whether or not to single_step this thread. */</span><br><span class=\"line\">    private boolean     single_step;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* Whether or not the thread is a daemon thread. 是否为守护线程*/</span><br><span class=\"line\">    private boolean     daemon = false;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* JVM state 是否*/</span><br><span class=\"line\">    private boolean     stillborn = false;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* What will be run. 要执行的任务*/</span><br><span class=\"line\">    private Runnable target;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* The group of this thread */</span><br><span class=\"line\">    private ThreadGroup group;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* The context ClassLoader for this thread */</span><br><span class=\"line\">    private ClassLoader contextClassLoader;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* The inherited AccessControlContext of this thread */</span><br><span class=\"line\">    private AccessControlContext inheritedAccessControlContext;</span><br><span class=\"line\"></span><br><span class=\"line\">    、、、、</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"相关属性\"><a href=\"#相关属性\" class=\"headerlink\" title=\"相关属性\"></a>相关属性</h2><p>Thread类实现了Runnable接口，在Thread类中，有一些比较关键的属性，比如name是表示Thread的名字，可以通过Thread类的构造器中的参数来指定线程名字，priority表示线程的优先级（最大值为10，最小值为1，默认值为5），daemon表示线程是否是守护线程，target表示要执行的任务。</p>\n<h2 id=\"方法介绍\"><a href=\"#方法介绍\" class=\"headerlink\" title=\"方法介绍\"></a>方法介绍</h2><h3 id=\"start-方法用synchronized关键字修饰\"><a href=\"#start-方法用synchronized关键字修饰\" class=\"headerlink\" title=\"start()方法用synchronized关键字修饰\"></a>start()方法用synchronized关键字修饰</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public synchronized void start() &#123;&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：</p>\n<ol>\n<li><strong>代码块：</strong>被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；</li>\n<li><strong>方法：</strong>被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</li>\n<li><strong>静态：</strong>的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；</li>\n<li><p><strong>类：</strong>其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。<br>start()用来启动一个线程，当调用start方法后，系统才会开启一个新的线程来执行用户定义的子任务，在这个过程中，会为相应的线程分配需要的资源。</p>\n<h3 id=\"run-方法\"><a href=\"#run-方法\" class=\"headerlink\" title=\"run()方法\"></a>run()方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void run() &#123;</span><br><span class=\"line\">    if (target != null) &#123;</span><br><span class=\"line\">        target.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>run()方法是不需要用户来调用的，当通过start方法启动一个线程之后，当线程获得了CPU执行时间，便进入run方法体去执行具体的任务。注意，继承Thread类必须重写run方法，在run方法中定义具体要执行的任务。</p>\n<h3 id=\"sleep-方法-有两个重载的版本。\"><a href=\"#sleep-方法-有两个重载的版本。\" class=\"headerlink\" title=\"sleep()方法,有两个重载的版本。\"></a>sleep()方法,有两个重载的版本。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- public static native void sleep(long millis) throws InterruptedException;</span><br><span class=\"line\">- public static void sleep(long millis, int nanos)</span><br><span class=\"line\">  throws InterruptedException &#123;</span><br><span class=\"line\">      if (millis &lt; 0) &#123;</span><br><span class=\"line\">          throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (nanos &lt; 0 || nanos &gt; 999999) &#123;</span><br><span class=\"line\">          throw new IllegalArgumentException(</span><br><span class=\"line\">                              &quot;nanosecond timeout value out of range&quot;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (nanos &gt;= 500000 || (nanos != 0 &amp;&amp; millis == 0)) &#123;</span><br><span class=\"line\">          millis++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      sleep(millis);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>sleep相当于让线程睡眠，交出CPU，让CPU去执行其他的任务。但是有一点要非常注意，sleep方法不会释放锁，也就是说如果当前线程持有对某个对象的锁，则即使调用sleep方法，其他线程也无法访问这个对象。下面举个例子简单说明。</p>\n</li>\n</ol>\n<ul>\n<li><p>新建线程类SThread，继承Thread类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package club.sdll.blog.thread;</span><br><span class=\"line\">public class SThread extends Thread &#123;</span><br><span class=\"line\">    private static Object object = new Object();</span><br><span class=\"line\">    private static int count = 1; </span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        synchronized(object) &#123;</span><br><span class=\"line\">            System.out.println(&quot;start count  ===  &quot; + count);</span><br><span class=\"line\">            System.out.println(&quot;我是线程  ===  &quot; + Thread.currentThread().getName());</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + &quot;睡眠开始 === &quot; + count);</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                Thread.sleep(1000);</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + &quot;睡眠结束 === &quot; + count);</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">            System.out.println(&quot;end   count  ===  &quot; + count);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Test测试类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package club.sdll.blog.thread;</span><br><span class=\"line\">public class Test &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        SThread cat = new SThread();</span><br><span class=\"line\">        cat.setName(&quot;小猫&quot;);</span><br><span class=\"line\">        SThread dog = new SThread();</span><br><span class=\"line\">        dog.setName(&quot;小狗&quot;);</span><br><span class=\"line\">        cat.start();</span><br><span class=\"line\">        dog.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>有<strong>syschronized同步锁</strong>的情况测试结果：<br>  <img src=\"http://ozux0lqfa.bkt.clouddn.com/%E6%9C%89%E5%90%8C%E6%AD%A5%E9%94%81%E7%9A%84%E7%BB%93%E6%9E%9C.png\" alt=\"\"><br>  从上面输出结果可以看出，当<strong>小猫thread</strong>进入睡眠状态之后，<strong>小狗thread</strong>并没有去执行具体的任务。只有当<strong>小猫thread</strong>执行完之后，此时<strong>小猫thread</strong>释放了对象锁<code>object</code>，<strong>小狗thread</strong>才开始执行。当线程睡眠时间满后，不一定会立即得到执行，因为此时可能CPU正在执行其他的任务。所以说调用sleep方法相当于让线程进入阻塞状态。</p>\n</li>\n<li>没有同步锁<strong>synchronized(object) {}</strong>的结果：两个线程同时都在争抢时间片<br>  <img src=\"http://ozux0lqfa.bkt.clouddn.com/%E6%B2%A1%E6%9C%89%E5%90%8C%E6%AD%A5%E9%94%81%E7%9A%84%E7%BB%93%E6%9E%9C.png\" alt=\"\"><h3 id=\"yield-方法\"><a href=\"#yield-方法\" class=\"headerlink\" title=\"yield()方法\"></a>yield()方法</h3>调用yield方法会让当前线程交出CPU权限，让CPU去执行其他的线程。它跟sleep方法类似，同样不会释放锁。但是yield不能控制具体的交出CPU的时间，另外，yield方法只能让拥有相同优先级的线程有获取CPU执行时间的机会。注意，调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的。<h3 id=\"join-方法\"><a href=\"#join-方法\" class=\"headerlink\" title=\"join()方法\"></a>join()方法</h3>假如在main线程中，调用thread.join方法，则main方法会等待thread线程执行完毕或者等待一定的时间。如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的时间。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package club.sdll.blog.thread;</span><br><span class=\"line\">import java.io.IOException;</span><br><span class=\"line\">public class Test2 &#123;</span><br><span class=\"line\">    public static void main(String[] args) throws IOException  &#123;</span><br><span class=\"line\">        System.out.println(&quot;进入线程“&quot;+Thread.currentThread().getName()+&quot;”&quot;);</span><br><span class=\"line\">        Test2 test2 = new Test2();</span><br><span class=\"line\">        SThread thread = test2.new SThread();</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            System.out.println(&quot;线程“&quot;+Thread.currentThread().getName()+&quot;”等待&quot;);</span><br><span class=\"line\">            thread.join();</span><br><span class=\"line\">            System.out.println(&quot;线程“&quot;+Thread.currentThread().getName()+&quot;”继续执行&quot;);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            // TODO Auto-generated catch block</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">     </span><br><span class=\"line\">    class SThread extends Thread&#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            System.out.println(&quot;进入线程“&quot;+Thread.currentThread().getName()+&quot;”&quot;);</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                Thread.currentThread().sleep(5000);</span><br><span class=\"line\">                System.out.println(&quot;线程“&quot;+Thread.currentThread().getName() + &quot;”休眠5秒&quot;);</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                // TODO: handle exception</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(&quot;离开线程“&quot;+Thread.currentThread().getName()+&quot;”&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>控制台打印结果：<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/join%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95.png\" alt=\"\"></p>\n<h3 id=\"未完待续\"><a href=\"#未完待续\" class=\"headerlink\" title=\"未完待续\"></a>未完待续</h3><p><strong>参考文章：</strong><br><a href=\"https://www.cnblogs.com/franson-2016/p/5498221.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/franson-2016/p/5498221.html</a></p>"},{"title":"Try Your Best","abbrlink":"63e54bd-Try-Your-Best","date":"2019-11-12T15:24:33.000Z","_content":"\n\n\n时间其实挺快的，一眨眼11月了，眼看着距离过年就两个多月的时间了，一年又快要结束了......\n\n<!-- more -->\n\n- 学习\n\n  在学习的这件事上，多问自己问什么要这样做，为什么这样可以实现，还有别的实现方式吗？以刨根问底的方式层层的剥开问题，才能找到最佳的解决办法。\n\n  多看写优秀的书籍和优秀的作者博客，加深自己对某个方面的技能更加深入的理解。书籍之所以能够出版，作者肯定是花了些心思在上面的，尽可能多看写对自己有价值的书籍。\n\n  编程语言是开源的，框架源代码也是开源的，技术都在那里摆着，何不花些心思彻底把他理解透，从而避免自己在某些框架上只会用，而不知其内在的实现原理。\n\n- 生活\n\n  生活，每天每时每刻，其实都是生活，在这休息的几天，看了几本书，猛地意识到书籍上蕴含了好多的知识。我其实不怎么爱看书，大学那会也没养成看书的习惯，说来惭愧，好多本专业课的课本都是崭新的，毕业了后，买了几本更工作相关的书，也是看了一半留一半，也就不了来之了。其他品类的书也就没怎么看过了，不过，大学那会花了好多时间看了很多电影（豆瓣250系列等）和美剧，工作之后也就看的比较少了。\n\n  书，是个好东西，当你相对某些东西进行了解考证的的时候，找到类似的书籍其实比网络上片面的信息更加行之有效和准确。\n\n\n\n**文末推荐**\n\n我个人比较喜欢的一部电影：[荒野生存(Into The Wild)]( https://movie.douban.com/subject/1905462/ )\n\n![undefined](http://ww1.sinaimg.cn/large/8515e8c2ly1g8vpe74gwgj20u00lcgmc.jpg)\n\n![undefined](http://ww1.sinaimg.cn/large/8515e8c2ly1g8vpbnmapaj20j80csq32.jpg)\n\nI want to be a super tramp!\n\n（全文结束）\n\n","source":"_posts/Try-Your-Best.md","raw":"---\ntitle: Try Your Best\ntags:\n  - 生活感想\nabbrlink: 63e54bd-Try-Your-Best\ndate: 2019-11-12 23:24:33\n---\n\n\n\n时间其实挺快的，一眨眼11月了，眼看着距离过年就两个多月的时间了，一年又快要结束了......\n\n<!-- more -->\n\n- 学习\n\n  在学习的这件事上，多问自己问什么要这样做，为什么这样可以实现，还有别的实现方式吗？以刨根问底的方式层层的剥开问题，才能找到最佳的解决办法。\n\n  多看写优秀的书籍和优秀的作者博客，加深自己对某个方面的技能更加深入的理解。书籍之所以能够出版，作者肯定是花了些心思在上面的，尽可能多看写对自己有价值的书籍。\n\n  编程语言是开源的，框架源代码也是开源的，技术都在那里摆着，何不花些心思彻底把他理解透，从而避免自己在某些框架上只会用，而不知其内在的实现原理。\n\n- 生活\n\n  生活，每天每时每刻，其实都是生活，在这休息的几天，看了几本书，猛地意识到书籍上蕴含了好多的知识。我其实不怎么爱看书，大学那会也没养成看书的习惯，说来惭愧，好多本专业课的课本都是崭新的，毕业了后，买了几本更工作相关的书，也是看了一半留一半，也就不了来之了。其他品类的书也就没怎么看过了，不过，大学那会花了好多时间看了很多电影（豆瓣250系列等）和美剧，工作之后也就看的比较少了。\n\n  书，是个好东西，当你相对某些东西进行了解考证的的时候，找到类似的书籍其实比网络上片面的信息更加行之有效和准确。\n\n\n\n**文末推荐**\n\n我个人比较喜欢的一部电影：[荒野生存(Into The Wild)]( https://movie.douban.com/subject/1905462/ )\n\n![undefined](http://ww1.sinaimg.cn/large/8515e8c2ly1g8vpe74gwgj20u00lcgmc.jpg)\n\n![undefined](http://ww1.sinaimg.cn/large/8515e8c2ly1g8vpbnmapaj20j80csq32.jpg)\n\nI want to be a super tramp!\n\n（全文结束）\n\n","slug":"Try-Your-Best","published":1,"updated":"2019-11-12T16:10:52.044Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2w200vh000dmwd39xe0ly6j","content":"<p>时间其实挺快的，一眨眼11月了，眼看着距离过年就两个多月的时间了，一年又快要结束了……</p>\n<a id=\"more\"></a>\n<ul>\n<li><p>学习</p>\n<p>在学习的这件事上，多问自己问什么要这样做，为什么这样可以实现，还有别的实现方式吗？以刨根问底的方式层层的剥开问题，才能找到最佳的解决办法。</p>\n<p>多看写优秀的书籍和优秀的作者博客，加深自己对某个方面的技能更加深入的理解。书籍之所以能够出版，作者肯定是花了些心思在上面的，尽可能多看写对自己有价值的书籍。</p>\n<p>编程语言是开源的，框架源代码也是开源的，技术都在那里摆着，何不花些心思彻底把他理解透，从而避免自己在某些框架上只会用，而不知其内在的实现原理。</p>\n</li>\n<li><p>生活</p>\n<p>生活，每天每时每刻，其实都是生活，在这休息的几天，看了几本书，猛地意识到书籍上蕴含了好多的知识。我其实不怎么爱看书，大学那会也没养成看书的习惯，说来惭愧，好多本专业课的课本都是崭新的，毕业了后，买了几本更工作相关的书，也是看了一半留一半，也就不了来之了。其他品类的书也就没怎么看过了，不过，大学那会花了好多时间看了很多电影（豆瓣250系列等）和美剧，工作之后也就看的比较少了。</p>\n<p>书，是个好东西，当你相对某些东西进行了解考证的的时候，找到类似的书籍其实比网络上片面的信息更加行之有效和准确。</p>\n</li>\n</ul>\n<p><strong>文末推荐</strong></p>\n<p>我个人比较喜欢的一部电影：<a href=\"https://movie.douban.com/subject/1905462/\" target=\"_blank\" rel=\"noopener\">荒野生存(Into The Wild)</a></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/8515e8c2ly1g8vpe74gwgj20u00lcgmc.jpg\" alt=\"undefined\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/8515e8c2ly1g8vpbnmapaj20j80csq32.jpg\" alt=\"undefined\"></p>\n<p>I want to be a super tramp!</p>\n<p>（全文结束）</p>\n","site":{"data":{}},"excerpt":"<p>时间其实挺快的，一眨眼11月了，眼看着距离过年就两个多月的时间了，一年又快要结束了……</p>","more":"<ul>\n<li><p>学习</p>\n<p>在学习的这件事上，多问自己问什么要这样做，为什么这样可以实现，还有别的实现方式吗？以刨根问底的方式层层的剥开问题，才能找到最佳的解决办法。</p>\n<p>多看写优秀的书籍和优秀的作者博客，加深自己对某个方面的技能更加深入的理解。书籍之所以能够出版，作者肯定是花了些心思在上面的，尽可能多看写对自己有价值的书籍。</p>\n<p>编程语言是开源的，框架源代码也是开源的，技术都在那里摆着，何不花些心思彻底把他理解透，从而避免自己在某些框架上只会用，而不知其内在的实现原理。</p>\n</li>\n<li><p>生活</p>\n<p>生活，每天每时每刻，其实都是生活，在这休息的几天，看了几本书，猛地意识到书籍上蕴含了好多的知识。我其实不怎么爱看书，大学那会也没养成看书的习惯，说来惭愧，好多本专业课的课本都是崭新的，毕业了后，买了几本更工作相关的书，也是看了一半留一半，也就不了来之了。其他品类的书也就没怎么看过了，不过，大学那会花了好多时间看了很多电影（豆瓣250系列等）和美剧，工作之后也就看的比较少了。</p>\n<p>书，是个好东西，当你相对某些东西进行了解考证的的时候，找到类似的书籍其实比网络上片面的信息更加行之有效和准确。</p>\n</li>\n</ul>\n<p><strong>文末推荐</strong></p>\n<p>我个人比较喜欢的一部电影：<a href=\"https://movie.douban.com/subject/1905462/\" target=\"_blank\" rel=\"noopener\">荒野生存(Into The Wild)</a></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/8515e8c2ly1g8vpe74gwgj20u00lcgmc.jpg\" alt=\"undefined\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/8515e8c2ly1g8vpbnmapaj20j80csq32.jpg\" alt=\"undefined\"></p>\n<p>I want to be a super tramp!</p>\n<p>（全文结束）</p>"},{"title":"ZooKeeper的使用及其原理","abbrlink":"21a25d7a-zookeeper-use-principle","date":"2019-04-13T14:52:14.000Z","_content":"\n在项目中也一直在用dubbo，使用Zookeeper 作为注册中心，但对于的内在的一些原理，至今都没有正儿八经的了解过，只是纯粹把它作为一种工具在使用。当被人问到Zookeeper 的时候，整个人都是懵逼的，故写下此文。\n\n<!-- more -->\n\n#  一、ZooKeeper 概览\n\nZookeeper 分布式服务框架是Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等，设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。\n\n- 一个典型的分布式数据一致性解决方案；\n- 一个开源的分布式协调服务；\n- 顺序一致性：从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。\n- 原子性：所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。\n- 单一系统映像：无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。\n- 可靠性：一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。\n\n# 二、重要概念\n\n- ZooKeeper 本身就是一个分布式程序（只要半数以上节点存活，ZooKeeper 就能正常服务）。\n- 为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。\n- ZooKeeper 将数据保存在内存中，这也就保证了 高吞吐量和低延迟（但是内存限制了能够存储的容量不太大，此限制也是保持 Znode 中存储的数据量较小的进一步原因）。\n- ZooKeeper 是高性能的。在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）\n- ZooKeeper 有临时节点的概念。当创建临时节点的客户端会话一直保持活动，瞬时节点就一直存在。而当会话终结时，瞬时节点被删除。持久节点是指一旦这个 ZNode 被创建了，除非主动进行 ZNode 的移除操作，否则这个 ZNode 将一直保存在 Zookeeper 上。\n- ZooKeeper 底层其实只提供了两个功能：①管理（存储、读取）用户程序提交的数据；②为用户程序提交数据节点监听服务。\n\n## 2.1.会话（Session）\n\nSession 指的是 ZooKeeper  服务器与客户端会话。在 ZooKeeper 中，一个客户端连接是指客户端和服务器之间的一个 TCP 长连接。客户端启动的时候，首先会与服务器建立一个 TCP 连接，从第一次连接建立开始，客户端会话的生命周期也开始了。通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向 Zookeeper 服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的 Watch 事件通知。\n\nSession 的 sessionTimeout 值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在 sessionTimeout 规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。\n\n在为客户端创建会话之前，服务端首先会为每个客户端都分配一个 sessionID。由于 sessionID 是 Zookeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 sessionID 的。因此，无论是哪台服务器为客户端分配的 sessionID，都务必保证全局唯一。\n\n## 2.2.节点（Znode）\n\n在谈到分布式的时候，我们通常说的“节点\"是指组成集群的每一台机器。\n\n然而，在 ZooKeeper 中，“节点\"分为两类：\n\n- 第一类同样是指构成集群的机器，我们称之为机器节点。\n- 第二类则是指数据模型中的数据单元，我们称之为数据节点一ZNode。\n\nZooKeeper 将所有数据存储在内存中，数据模型是一棵树（Znode Tree)，由斜杠（/）的进行分割的路径，就是一个 Znode，例如/foo/path1。每个上都会保存自己的数据内容，同时还会保存一系列属性信息。\n\n在 Zookeeper 中，Node 可以分为持久节点和临时节点两类。所谓持久节点是指一旦这个 ZNode 被创建了，除非主动进行 ZNode 的移除操作，否则这个 ZNode 将一直保存在 ZooKeeper 上。而临时节点就不一样了，它的生命周期和客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。\n\n另外，ZooKeeper 还允许用户为每个节点添加一个特殊的属性：SEQUENTIAL。一旦节点被标记上这个属性，那么在这个节点被创建的时候，ZooKeeper 会自动在其节点名后面追加上一个整型数字，这个整型数字是一个由父节点维护的自增数字。\n\n## 2.3.节点（Version）\n\n在前面我们已经提到，Zookeeper 的每个 ZNode 上都会存储数据，对应于每个 ZNode，Zookeeper 都会为其维护一个叫作 Stat 的数据结构。\n\nStat 中记录了这个 ZNode 的三个数据版本，分别是：\n\n- version（当前 ZNode 的版本）\n- cversion（当前 ZNode 子节点的版本）\n- aversion（当前 ZNode 的 ACL 版本）\n\n## 2.4.事件监听器（Watcher）\n\nWatcher（事件监听器），是 ZooKeeper 中的一个很重要的特性。ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。\n\n## 2.5.ACL\n\nZooKeeper 采用 ACL（AccessControlLists）策略来进行权限控制，类似于  UNIX 文件系统的权限控制。\n\nZooKeeper 定义了 5 种权限，如下图：\n\n- CREATE 创建子节点权限\n- READ 获取节点数据和子节点列表的权限\n- WRITE 更新节点数据权限\n- DELETE 删除子节点权限\n- ADMIN 设置节点ACL的权限\n\n其中尤其需要注意的是，CREATE 和 DELETE 这两种权限都是针对子节点的权限控制。\n\n## 2.6.数据模型\n\n- ZooKeeper 允许分布式进程通过共享的层次结构命名空间进行相互协调，这与标准文件系统类似。\n- 命名空间由 ZooKeeper 中的数据寄存器组成，称为 Znode，这些类似于文件和目录。\n- 与为存储设计的典型文件系统不同，ZooKeeper 数据保存在内存中，这意味着 ZooKeeper 可以实现高吞吐量和低延迟。\n\n![](https://s1.51cto.com/oss/201809/12/08308a2ed38371a6fef72f281598b3df.jpg)\n\nZooKeeper 数据模型示例：\n\n```\n[zk: 10.1.39.43:4180(CONNECTED) 7] get /hello  \nworld  \ncZxid = 0x10000042c  \nctime = Fri May 17 17:57:33 CST 2013  \nmZxid = 0x10000042c  \nmtime = Fri May 17 17:57:33 CST 2013  \npZxid = 0x10000042c  \ncversion = 0  \ndataVersion = 0  \naclVersion = 0  \nephemeralOwner = 0x0  \ndataLength = 5  \nnumChildren = 0  \n```\n\n使用get命令获取指定节点的数据时, 同时也将返回该节点的状态信息, 称为Stat. 其包含如下字段:\n\n- czxid. 节点创建时的zxid.\n- mzxid. 节点最新一次更新发生时的zxid.\n- ctime. 节点创建时的时间戳.\n- mtime. 节点最新一次更新发生时的时间戳.\n- dataVersion. 节点数据的更新次数.\n- cversion. 其子节点的更新次数.\n- aclVersion. 节点ACL(授权信息)的更新次数.\n- ephemeralOwner. 如果该节点为ephemeral节点, ephemeralOwner值表示与该节点绑定的session id. 如果该节点不是ephemeral节点, ephemeralOwner值为0. 至于什么是ephemeral节点, 请看后面的讲述.\n- dataLength. 节点数据的字节数.\n- numChildren. 子节点个数.\n\n**字段描述**\n\n- zxid\n\nznode节点的状态信息中包含czxid和mzxid, 那么什么是zxid呢?\nZooKeeper状态的每一次改变, 都对应着一个递增的`Transaction id`, 该id称为zxid. 由于zxid的递增性质, 如果zxid1小于zxid2, 那么zxid1肯定先于zxid2发生. 创建任意节点, 或者更新任意节点的数据, 或者删除任意节点, 都会导致Zookeeper状态发生改变, 从而导致zxid的值增加.\n\n- session\n\n在client和server通信之前, 首先需要建立连接, 该连接称为session. 连接建立后, 如果发生连接超时, 授权失败, 或者显式关闭连接, 连接便处于CLOSED状态, 此时session结束.\n\n- 节点类型\n\n讲述节点状态的ephemeralOwner字段时, 提到过有的节点是ephemeral节点, 而有的并不是. 那么节点都具有哪些类型呢? 每种类型的节点又具有哪些特点呢?\n`persistent`. persistent节点不和特定的session绑定, 不会随着创建该节点的session的结束而消失, 而是一直存在, 除非该节点被显式删除.\n`ephemeral`. ephemeral节点是临时性的, 如果创建该节点的session结束了, 该节点就会被自动删除. ephemeral节点不能拥有子节点. 虽然ephemeral节点与创建它的session绑定, 但只要该该节点没有被删除, 其他session就可以读写该节点中关联的数据. 使用-e参数指定创建ephemeral节点.\n\n`sequence`. 严格的说, sequence并非节点类型中的一种. sequence节点既可以是ephemeral的, 也可以是persistent的. 创建sequence节点时, ZooKeeper server会在指定的节点名称后加上一个数字序列, 该数字序列是递增的. 因此可以多次创建相同的sequence节点, 而得到不同的节点. 使用-s参数指定创建sequence节点.\n\n- watch\n\nwatch的意思是监听感兴趣的事件. 在命令行中, 以下几个命令可以指定是否监听相应的事件.\n\nls命令. ls命令的第一个参数指定znode, 第二个参数如果为true, 则说明监听该znode的子节点的增减, 以及该znode本身的删除事件.\n\nget命令. get命令的第一个参数指定znode, 第二个参数如果为true, 则说明监听该znode的更新和删除事件.stat命令. stat命令用于获取znode的状态信息. 第一个参数指定znode, 如果第二个参数为true, 则监听该node的更新和删除事件.\n\n# 三、集群构建\n\n为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。\n\n## 3.1.集群角色介绍\n\n客户端使用这个 TCP 链接来发送请求、获取结果、获取监听事件以及发送心跳包。如果这个连接异常断开了，客户端可以连接到另外的机器上。ZooKeeper 官方提供的架构图：\n\n![](https://s4.51cto.com/oss/201809/12/a515a1458ba2bc659fd1c601740cdf53.jpg)\n\n上图中每一个 Server 代表一个安装 ZooKeeper 服务的服务器。组成 ZooKeeper 服务的服务器都会在内存中维护当前的服务器状态，并且每台服务器之间都互相保持着通信。集群间通过 Zab 协议（Zookeeper Atomic Broadcast）来保持数据的一致性。\n\n- 顺序访问\n\n  对于来自客户端的每个更新请求，ZooKeeper 都会分配一个全局唯一的递增编号。这个编号反应了所有事务操作的先后顺序，应用程序可以使用 ZooKeeper 这个特性来实现更高层次的同步原语。这个编号也叫做时间戳—zxid（ZooKeeper Transaction Id）。\n\n\n- 高性能\n\n  ZooKeeper 是高性能的。在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）\n\n最典型集群模式：Master/Slave 模式（主备模式）。在这种模式中，通常 Master 服务器作为主服务器提供写服务，其他的 Slave 服务器从服务器通过异步复制的方式获取 Master 服务器最新的数据提供读服务。但是，在 ZooKeeper 中没有选择传统的 Master/Slave 概念，而是引入了**Leader、Follower 和 Observer **三种角色。\n\n如下图所示：\n\n![](https://s5.51cto.com/oss/201809/12/96fea87c7024afd577376e7a4b26e460.jpg)\n\n- ZooKeeper 集群中的所有机器通过一个 Leader 选举过程来选定一台称为 “Leader” 的机器。\n- Leader 既可以为客户端提供写服务又能提供读服务。除了 Leader 外，Follower 和  Observer 都只能提供读服务。\n- Follower 和 Observer 唯一的区别在于 Observer 机器不参与 Leader 的选举过程，也不参与写操作的“过半写成功”策略，因此 Observer 机器可以在不影响写性能的情况下提升集群的读性能。\n\n![](https://s4.51cto.com/oss/201809/12/5e245feb8f8311195763d2abb3e27c20.jpg)\n\n\n\n## 3.1.ZAB 协议 & Paxos 算法\n\n- ZAB 协议 & Paxos 算法\n\n  Paxos 算法可以说是  ZooKeeper 的灵魂了。但是，ZooKeeper 并没有完全采用 Paxos 算法 ，而是使用 ZAB 协议作为其保证数据一致性的核心算法。\n\n  另外，在 ZooKeeper 的官方文档中也指出，ZAB 协议并不像 Paxos 算法那样，是一种通用的分布式一致性算法，它是一种特别为 ZooKeeper 设计的崩溃可恢复的原子消息广播算法。\n\n\n- ZAB 协议介绍\n\n  ZAB（ZooKeeper Atomic Broadcast 原子广播）协议是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议。在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性\n\n- ZAB 协议两种基本的模式\n\n  ZAB 协议包括两种基本的模式，分别是`崩溃恢复`和`消息广播`。\n\n  当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进入恢复模式并选举产生新的 Leader 服务器。当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该 Leader 服务器完成了状态同步之后，ZAB 协议就会退出恢复模式。\n\n  其中，所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和 Leader 服务器的数据状态保持一致。\n\n  当集群中已经有过半的 Follower 服务器完成了和 Leader 服务器的状态同步，那么整个服务框架就可以进人消息广播模式了。\n\n  当一台同样遵守 ZAB 协议的服务器启动后加入到集群中时，如果此时集群中已经存在一个 Leader 服务器在负责进行消息广播。那么新加入的服务器就会自觉地进人数据恢复模式：找到 Leader 所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。\n\n  正如上文介绍中所说的，ZooKeeper 设计成只允许唯一的一个 Leader 服务器来进行事务请求的处理。Leader 服务器在接收到客户端的事务请求后，会生成对应的事务提案并发起一轮广播协议。而如果集群中的其他机器接收到客户端的事务请求，那么这些非 Leader 服务器会首先将这个事务请求转发给 Leader 服务器。\n\n# 四、作为dubbo的注册中心\n\n- 为什么最好使用奇数台服务器构成 ZooKeeper 集群？我们知道在 ZooKeeper 中 Leader 选举算法采用了 Zab 协议。Zab 核心思想是当多数 Server 写成功，则任务数据写成功：\n\n  - 如果有 3 个 Server，则最多允许 1 个 Server 挂掉。\n  - 如果有 4 个 Server，则同样最多允许 1 个 Server 挂掉。\n  - 然 3 个或者 4 个 Server，同样最多允许 1 个 Server 挂掉，那么它们的可靠性是一样的。所以选择奇数个 ZooKeeper Server 即可，这里选择 3 个 Server。\n\n- 在 Dubbo 中使用 Zookeeper\n\n  Dubbo 使用 Zookeeper 用于服务的注册发现和配置管理，在 Zookeeper 中数据的组织由下图所示：\n\n  ![](https://cdn.nlark.com/lark/0/2018/jpeg/13615/1533281862290-08dd18e0-7950-4ff1-8de0-6dd66362e195.jpeg)\n\n首先，所有 Dubbo 相关的数据都组织在 `/duboo` 的根节点下。\n\n二级目录是服务名，如 `com.foo.BarService`。\n\n三级目录有两个子节点，分别是 `providers` 和 `consumers`，表示该服务的提供者和消费者。\n\n四级目录记录了与该服务相关的每一个应用实例的 URL 信息，在 `providers` 下的表示该服务的所有提供者，而在 `consumers` 下的表示该服务的所有消费者。举例说明，`com.foo.BarService` 的服务提供者在启动时将自己的 URL 信息注册到 `/dubbo/com.foo.BarService/providers` 下；同样的，服务消费者将自己的信息注册到相应的 `consumers` 下，同时，服务消费者会订阅其所对应的 `providers` 节点，以便能够感知到服务提供方地址列表的变化。\n\n\n\n**引用文章**\n\n- http://developer.51cto.com/art/201809/583184.htm\n- [http://jm.taobao.org/2018/10/30/%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%94%B9%E9%80%A0%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89-Dubbo-ZooKeeper/](http://jm.taobao.org/2018/10/30/%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%94%B9%E9%80%A0%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89-Dubbo-ZooKeeper/)\n- [https://coolxing.iteye.com/blog/1871328](https://coolxing.iteye.com/blog/1871328)","source":"_posts/ZooKeeper的使用及其原理.md","raw":"---\ntitle: ZooKeeper的使用及其原理\ntags:\n  - ZooKeeper\nabbrlink: 21a25d7a-zookeeper-use-principle\ndate: 2019-04-13 22:52:14\n---\n\n在项目中也一直在用dubbo，使用Zookeeper 作为注册中心，但对于的内在的一些原理，至今都没有正儿八经的了解过，只是纯粹把它作为一种工具在使用。当被人问到Zookeeper 的时候，整个人都是懵逼的，故写下此文。\n\n<!-- more -->\n\n#  一、ZooKeeper 概览\n\nZookeeper 分布式服务框架是Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等，设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。\n\n- 一个典型的分布式数据一致性解决方案；\n- 一个开源的分布式协调服务；\n- 顺序一致性：从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。\n- 原子性：所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。\n- 单一系统映像：无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。\n- 可靠性：一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。\n\n# 二、重要概念\n\n- ZooKeeper 本身就是一个分布式程序（只要半数以上节点存活，ZooKeeper 就能正常服务）。\n- 为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。\n- ZooKeeper 将数据保存在内存中，这也就保证了 高吞吐量和低延迟（但是内存限制了能够存储的容量不太大，此限制也是保持 Znode 中存储的数据量较小的进一步原因）。\n- ZooKeeper 是高性能的。在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）\n- ZooKeeper 有临时节点的概念。当创建临时节点的客户端会话一直保持活动，瞬时节点就一直存在。而当会话终结时，瞬时节点被删除。持久节点是指一旦这个 ZNode 被创建了，除非主动进行 ZNode 的移除操作，否则这个 ZNode 将一直保存在 Zookeeper 上。\n- ZooKeeper 底层其实只提供了两个功能：①管理（存储、读取）用户程序提交的数据；②为用户程序提交数据节点监听服务。\n\n## 2.1.会话（Session）\n\nSession 指的是 ZooKeeper  服务器与客户端会话。在 ZooKeeper 中，一个客户端连接是指客户端和服务器之间的一个 TCP 长连接。客户端启动的时候，首先会与服务器建立一个 TCP 连接，从第一次连接建立开始，客户端会话的生命周期也开始了。通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向 Zookeeper 服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的 Watch 事件通知。\n\nSession 的 sessionTimeout 值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在 sessionTimeout 规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。\n\n在为客户端创建会话之前，服务端首先会为每个客户端都分配一个 sessionID。由于 sessionID 是 Zookeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 sessionID 的。因此，无论是哪台服务器为客户端分配的 sessionID，都务必保证全局唯一。\n\n## 2.2.节点（Znode）\n\n在谈到分布式的时候，我们通常说的“节点\"是指组成集群的每一台机器。\n\n然而，在 ZooKeeper 中，“节点\"分为两类：\n\n- 第一类同样是指构成集群的机器，我们称之为机器节点。\n- 第二类则是指数据模型中的数据单元，我们称之为数据节点一ZNode。\n\nZooKeeper 将所有数据存储在内存中，数据模型是一棵树（Znode Tree)，由斜杠（/）的进行分割的路径，就是一个 Znode，例如/foo/path1。每个上都会保存自己的数据内容，同时还会保存一系列属性信息。\n\n在 Zookeeper 中，Node 可以分为持久节点和临时节点两类。所谓持久节点是指一旦这个 ZNode 被创建了，除非主动进行 ZNode 的移除操作，否则这个 ZNode 将一直保存在 ZooKeeper 上。而临时节点就不一样了，它的生命周期和客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。\n\n另外，ZooKeeper 还允许用户为每个节点添加一个特殊的属性：SEQUENTIAL。一旦节点被标记上这个属性，那么在这个节点被创建的时候，ZooKeeper 会自动在其节点名后面追加上一个整型数字，这个整型数字是一个由父节点维护的自增数字。\n\n## 2.3.节点（Version）\n\n在前面我们已经提到，Zookeeper 的每个 ZNode 上都会存储数据，对应于每个 ZNode，Zookeeper 都会为其维护一个叫作 Stat 的数据结构。\n\nStat 中记录了这个 ZNode 的三个数据版本，分别是：\n\n- version（当前 ZNode 的版本）\n- cversion（当前 ZNode 子节点的版本）\n- aversion（当前 ZNode 的 ACL 版本）\n\n## 2.4.事件监听器（Watcher）\n\nWatcher（事件监听器），是 ZooKeeper 中的一个很重要的特性。ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。\n\n## 2.5.ACL\n\nZooKeeper 采用 ACL（AccessControlLists）策略来进行权限控制，类似于  UNIX 文件系统的权限控制。\n\nZooKeeper 定义了 5 种权限，如下图：\n\n- CREATE 创建子节点权限\n- READ 获取节点数据和子节点列表的权限\n- WRITE 更新节点数据权限\n- DELETE 删除子节点权限\n- ADMIN 设置节点ACL的权限\n\n其中尤其需要注意的是，CREATE 和 DELETE 这两种权限都是针对子节点的权限控制。\n\n## 2.6.数据模型\n\n- ZooKeeper 允许分布式进程通过共享的层次结构命名空间进行相互协调，这与标准文件系统类似。\n- 命名空间由 ZooKeeper 中的数据寄存器组成，称为 Znode，这些类似于文件和目录。\n- 与为存储设计的典型文件系统不同，ZooKeeper 数据保存在内存中，这意味着 ZooKeeper 可以实现高吞吐量和低延迟。\n\n![](https://s1.51cto.com/oss/201809/12/08308a2ed38371a6fef72f281598b3df.jpg)\n\nZooKeeper 数据模型示例：\n\n```\n[zk: 10.1.39.43:4180(CONNECTED) 7] get /hello  \nworld  \ncZxid = 0x10000042c  \nctime = Fri May 17 17:57:33 CST 2013  \nmZxid = 0x10000042c  \nmtime = Fri May 17 17:57:33 CST 2013  \npZxid = 0x10000042c  \ncversion = 0  \ndataVersion = 0  \naclVersion = 0  \nephemeralOwner = 0x0  \ndataLength = 5  \nnumChildren = 0  \n```\n\n使用get命令获取指定节点的数据时, 同时也将返回该节点的状态信息, 称为Stat. 其包含如下字段:\n\n- czxid. 节点创建时的zxid.\n- mzxid. 节点最新一次更新发生时的zxid.\n- ctime. 节点创建时的时间戳.\n- mtime. 节点最新一次更新发生时的时间戳.\n- dataVersion. 节点数据的更新次数.\n- cversion. 其子节点的更新次数.\n- aclVersion. 节点ACL(授权信息)的更新次数.\n- ephemeralOwner. 如果该节点为ephemeral节点, ephemeralOwner值表示与该节点绑定的session id. 如果该节点不是ephemeral节点, ephemeralOwner值为0. 至于什么是ephemeral节点, 请看后面的讲述.\n- dataLength. 节点数据的字节数.\n- numChildren. 子节点个数.\n\n**字段描述**\n\n- zxid\n\nznode节点的状态信息中包含czxid和mzxid, 那么什么是zxid呢?\nZooKeeper状态的每一次改变, 都对应着一个递增的`Transaction id`, 该id称为zxid. 由于zxid的递增性质, 如果zxid1小于zxid2, 那么zxid1肯定先于zxid2发生. 创建任意节点, 或者更新任意节点的数据, 或者删除任意节点, 都会导致Zookeeper状态发生改变, 从而导致zxid的值增加.\n\n- session\n\n在client和server通信之前, 首先需要建立连接, 该连接称为session. 连接建立后, 如果发生连接超时, 授权失败, 或者显式关闭连接, 连接便处于CLOSED状态, 此时session结束.\n\n- 节点类型\n\n讲述节点状态的ephemeralOwner字段时, 提到过有的节点是ephemeral节点, 而有的并不是. 那么节点都具有哪些类型呢? 每种类型的节点又具有哪些特点呢?\n`persistent`. persistent节点不和特定的session绑定, 不会随着创建该节点的session的结束而消失, 而是一直存在, 除非该节点被显式删除.\n`ephemeral`. ephemeral节点是临时性的, 如果创建该节点的session结束了, 该节点就会被自动删除. ephemeral节点不能拥有子节点. 虽然ephemeral节点与创建它的session绑定, 但只要该该节点没有被删除, 其他session就可以读写该节点中关联的数据. 使用-e参数指定创建ephemeral节点.\n\n`sequence`. 严格的说, sequence并非节点类型中的一种. sequence节点既可以是ephemeral的, 也可以是persistent的. 创建sequence节点时, ZooKeeper server会在指定的节点名称后加上一个数字序列, 该数字序列是递增的. 因此可以多次创建相同的sequence节点, 而得到不同的节点. 使用-s参数指定创建sequence节点.\n\n- watch\n\nwatch的意思是监听感兴趣的事件. 在命令行中, 以下几个命令可以指定是否监听相应的事件.\n\nls命令. ls命令的第一个参数指定znode, 第二个参数如果为true, 则说明监听该znode的子节点的增减, 以及该znode本身的删除事件.\n\nget命令. get命令的第一个参数指定znode, 第二个参数如果为true, 则说明监听该znode的更新和删除事件.stat命令. stat命令用于获取znode的状态信息. 第一个参数指定znode, 如果第二个参数为true, 则监听该node的更新和删除事件.\n\n# 三、集群构建\n\n为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。\n\n## 3.1.集群角色介绍\n\n客户端使用这个 TCP 链接来发送请求、获取结果、获取监听事件以及发送心跳包。如果这个连接异常断开了，客户端可以连接到另外的机器上。ZooKeeper 官方提供的架构图：\n\n![](https://s4.51cto.com/oss/201809/12/a515a1458ba2bc659fd1c601740cdf53.jpg)\n\n上图中每一个 Server 代表一个安装 ZooKeeper 服务的服务器。组成 ZooKeeper 服务的服务器都会在内存中维护当前的服务器状态，并且每台服务器之间都互相保持着通信。集群间通过 Zab 协议（Zookeeper Atomic Broadcast）来保持数据的一致性。\n\n- 顺序访问\n\n  对于来自客户端的每个更新请求，ZooKeeper 都会分配一个全局唯一的递增编号。这个编号反应了所有事务操作的先后顺序，应用程序可以使用 ZooKeeper 这个特性来实现更高层次的同步原语。这个编号也叫做时间戳—zxid（ZooKeeper Transaction Id）。\n\n\n- 高性能\n\n  ZooKeeper 是高性能的。在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）\n\n最典型集群模式：Master/Slave 模式（主备模式）。在这种模式中，通常 Master 服务器作为主服务器提供写服务，其他的 Slave 服务器从服务器通过异步复制的方式获取 Master 服务器最新的数据提供读服务。但是，在 ZooKeeper 中没有选择传统的 Master/Slave 概念，而是引入了**Leader、Follower 和 Observer **三种角色。\n\n如下图所示：\n\n![](https://s5.51cto.com/oss/201809/12/96fea87c7024afd577376e7a4b26e460.jpg)\n\n- ZooKeeper 集群中的所有机器通过一个 Leader 选举过程来选定一台称为 “Leader” 的机器。\n- Leader 既可以为客户端提供写服务又能提供读服务。除了 Leader 外，Follower 和  Observer 都只能提供读服务。\n- Follower 和 Observer 唯一的区别在于 Observer 机器不参与 Leader 的选举过程，也不参与写操作的“过半写成功”策略，因此 Observer 机器可以在不影响写性能的情况下提升集群的读性能。\n\n![](https://s4.51cto.com/oss/201809/12/5e245feb8f8311195763d2abb3e27c20.jpg)\n\n\n\n## 3.1.ZAB 协议 & Paxos 算法\n\n- ZAB 协议 & Paxos 算法\n\n  Paxos 算法可以说是  ZooKeeper 的灵魂了。但是，ZooKeeper 并没有完全采用 Paxos 算法 ，而是使用 ZAB 协议作为其保证数据一致性的核心算法。\n\n  另外，在 ZooKeeper 的官方文档中也指出，ZAB 协议并不像 Paxos 算法那样，是一种通用的分布式一致性算法，它是一种特别为 ZooKeeper 设计的崩溃可恢复的原子消息广播算法。\n\n\n- ZAB 协议介绍\n\n  ZAB（ZooKeeper Atomic Broadcast 原子广播）协议是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议。在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性\n\n- ZAB 协议两种基本的模式\n\n  ZAB 协议包括两种基本的模式，分别是`崩溃恢复`和`消息广播`。\n\n  当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进入恢复模式并选举产生新的 Leader 服务器。当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该 Leader 服务器完成了状态同步之后，ZAB 协议就会退出恢复模式。\n\n  其中，所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和 Leader 服务器的数据状态保持一致。\n\n  当集群中已经有过半的 Follower 服务器完成了和 Leader 服务器的状态同步，那么整个服务框架就可以进人消息广播模式了。\n\n  当一台同样遵守 ZAB 协议的服务器启动后加入到集群中时，如果此时集群中已经存在一个 Leader 服务器在负责进行消息广播。那么新加入的服务器就会自觉地进人数据恢复模式：找到 Leader 所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。\n\n  正如上文介绍中所说的，ZooKeeper 设计成只允许唯一的一个 Leader 服务器来进行事务请求的处理。Leader 服务器在接收到客户端的事务请求后，会生成对应的事务提案并发起一轮广播协议。而如果集群中的其他机器接收到客户端的事务请求，那么这些非 Leader 服务器会首先将这个事务请求转发给 Leader 服务器。\n\n# 四、作为dubbo的注册中心\n\n- 为什么最好使用奇数台服务器构成 ZooKeeper 集群？我们知道在 ZooKeeper 中 Leader 选举算法采用了 Zab 协议。Zab 核心思想是当多数 Server 写成功，则任务数据写成功：\n\n  - 如果有 3 个 Server，则最多允许 1 个 Server 挂掉。\n  - 如果有 4 个 Server，则同样最多允许 1 个 Server 挂掉。\n  - 然 3 个或者 4 个 Server，同样最多允许 1 个 Server 挂掉，那么它们的可靠性是一样的。所以选择奇数个 ZooKeeper Server 即可，这里选择 3 个 Server。\n\n- 在 Dubbo 中使用 Zookeeper\n\n  Dubbo 使用 Zookeeper 用于服务的注册发现和配置管理，在 Zookeeper 中数据的组织由下图所示：\n\n  ![](https://cdn.nlark.com/lark/0/2018/jpeg/13615/1533281862290-08dd18e0-7950-4ff1-8de0-6dd66362e195.jpeg)\n\n首先，所有 Dubbo 相关的数据都组织在 `/duboo` 的根节点下。\n\n二级目录是服务名，如 `com.foo.BarService`。\n\n三级目录有两个子节点，分别是 `providers` 和 `consumers`，表示该服务的提供者和消费者。\n\n四级目录记录了与该服务相关的每一个应用实例的 URL 信息，在 `providers` 下的表示该服务的所有提供者，而在 `consumers` 下的表示该服务的所有消费者。举例说明，`com.foo.BarService` 的服务提供者在启动时将自己的 URL 信息注册到 `/dubbo/com.foo.BarService/providers` 下；同样的，服务消费者将自己的信息注册到相应的 `consumers` 下，同时，服务消费者会订阅其所对应的 `providers` 节点，以便能够感知到服务提供方地址列表的变化。\n\n\n\n**引用文章**\n\n- http://developer.51cto.com/art/201809/583184.htm\n- [http://jm.taobao.org/2018/10/30/%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%94%B9%E9%80%A0%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89-Dubbo-ZooKeeper/](http://jm.taobao.org/2018/10/30/%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%94%B9%E9%80%A0%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89-Dubbo-ZooKeeper/)\n- [https://coolxing.iteye.com/blog/1871328](https://coolxing.iteye.com/blog/1871328)","slug":"ZooKeeper的使用及其原理","published":1,"updated":"2019-04-13T14:57:08.094Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2w200vp000fmwd3kd36217v","content":"<p>在项目中也一直在用dubbo，使用Zookeeper 作为注册中心，但对于的内在的一些原理，至今都没有正儿八经的了解过，只是纯粹把它作为一种工具在使用。当被人问到Zookeeper 的时候，整个人都是懵逼的，故写下此文。</p>\n<a id=\"more\"></a>\n<h1 id=\"一、ZooKeeper-概览\"><a href=\"#一、ZooKeeper-概览\" class=\"headerlink\" title=\"一、ZooKeeper 概览\"></a>一、ZooKeeper 概览</h1><p>Zookeeper 分布式服务框架是Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等，设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</p>\n<ul>\n<li>一个典型的分布式数据一致性解决方案；</li>\n<li>一个开源的分布式协调服务；</li>\n<li>顺序一致性：从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。</li>\n<li>原子性：所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。</li>\n<li>单一系统映像：无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。</li>\n<li>可靠性：一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。</li>\n</ul>\n<h1 id=\"二、重要概念\"><a href=\"#二、重要概念\" class=\"headerlink\" title=\"二、重要概念\"></a>二、重要概念</h1><ul>\n<li>ZooKeeper 本身就是一个分布式程序（只要半数以上节点存活，ZooKeeper 就能正常服务）。</li>\n<li>为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。</li>\n<li>ZooKeeper 将数据保存在内存中，这也就保证了 高吞吐量和低延迟（但是内存限制了能够存储的容量不太大，此限制也是保持 Znode 中存储的数据量较小的进一步原因）。</li>\n<li>ZooKeeper 是高性能的。在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）</li>\n<li>ZooKeeper 有临时节点的概念。当创建临时节点的客户端会话一直保持活动，瞬时节点就一直存在。而当会话终结时，瞬时节点被删除。持久节点是指一旦这个 ZNode 被创建了，除非主动进行 ZNode 的移除操作，否则这个 ZNode 将一直保存在 Zookeeper 上。</li>\n<li>ZooKeeper 底层其实只提供了两个功能：①管理（存储、读取）用户程序提交的数据；②为用户程序提交数据节点监听服务。</li>\n</ul>\n<h2 id=\"2-1-会话（Session）\"><a href=\"#2-1-会话（Session）\" class=\"headerlink\" title=\"2.1.会话（Session）\"></a>2.1.会话（Session）</h2><p>Session 指的是 ZooKeeper  服务器与客户端会话。在 ZooKeeper 中，一个客户端连接是指客户端和服务器之间的一个 TCP 长连接。客户端启动的时候，首先会与服务器建立一个 TCP 连接，从第一次连接建立开始，客户端会话的生命周期也开始了。通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向 Zookeeper 服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的 Watch 事件通知。</p>\n<p>Session 的 sessionTimeout 值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在 sessionTimeout 规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。</p>\n<p>在为客户端创建会话之前，服务端首先会为每个客户端都分配一个 sessionID。由于 sessionID 是 Zookeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 sessionID 的。因此，无论是哪台服务器为客户端分配的 sessionID，都务必保证全局唯一。</p>\n<h2 id=\"2-2-节点（Znode）\"><a href=\"#2-2-节点（Znode）\" class=\"headerlink\" title=\"2.2.节点（Znode）\"></a>2.2.节点（Znode）</h2><p>在谈到分布式的时候，我们通常说的“节点”是指组成集群的每一台机器。</p>\n<p>然而，在 ZooKeeper 中，“节点”分为两类：</p>\n<ul>\n<li>第一类同样是指构成集群的机器，我们称之为机器节点。</li>\n<li>第二类则是指数据模型中的数据单元，我们称之为数据节点一ZNode。</li>\n</ul>\n<p>ZooKeeper 将所有数据存储在内存中，数据模型是一棵树（Znode Tree)，由斜杠（/）的进行分割的路径，就是一个 Znode，例如/foo/path1。每个上都会保存自己的数据内容，同时还会保存一系列属性信息。</p>\n<p>在 Zookeeper 中，Node 可以分为持久节点和临时节点两类。所谓持久节点是指一旦这个 ZNode 被创建了，除非主动进行 ZNode 的移除操作，否则这个 ZNode 将一直保存在 ZooKeeper 上。而临时节点就不一样了，它的生命周期和客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。</p>\n<p>另外，ZooKeeper 还允许用户为每个节点添加一个特殊的属性：SEQUENTIAL。一旦节点被标记上这个属性，那么在这个节点被创建的时候，ZooKeeper 会自动在其节点名后面追加上一个整型数字，这个整型数字是一个由父节点维护的自增数字。</p>\n<h2 id=\"2-3-节点（Version）\"><a href=\"#2-3-节点（Version）\" class=\"headerlink\" title=\"2.3.节点（Version）\"></a>2.3.节点（Version）</h2><p>在前面我们已经提到，Zookeeper 的每个 ZNode 上都会存储数据，对应于每个 ZNode，Zookeeper 都会为其维护一个叫作 Stat 的数据结构。</p>\n<p>Stat 中记录了这个 ZNode 的三个数据版本，分别是：</p>\n<ul>\n<li>version（当前 ZNode 的版本）</li>\n<li>cversion（当前 ZNode 子节点的版本）</li>\n<li>aversion（当前 ZNode 的 ACL 版本）</li>\n</ul>\n<h2 id=\"2-4-事件监听器（Watcher）\"><a href=\"#2-4-事件监听器（Watcher）\" class=\"headerlink\" title=\"2.4.事件监听器（Watcher）\"></a>2.4.事件监听器（Watcher）</h2><p>Watcher（事件监听器），是 ZooKeeper 中的一个很重要的特性。ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。</p>\n<h2 id=\"2-5-ACL\"><a href=\"#2-5-ACL\" class=\"headerlink\" title=\"2.5.ACL\"></a>2.5.ACL</h2><p>ZooKeeper 采用 ACL（AccessControlLists）策略来进行权限控制，类似于  UNIX 文件系统的权限控制。</p>\n<p>ZooKeeper 定义了 5 种权限，如下图：</p>\n<ul>\n<li>CREATE 创建子节点权限</li>\n<li>READ 获取节点数据和子节点列表的权限</li>\n<li>WRITE 更新节点数据权限</li>\n<li>DELETE 删除子节点权限</li>\n<li>ADMIN 设置节点ACL的权限</li>\n</ul>\n<p>其中尤其需要注意的是，CREATE 和 DELETE 这两种权限都是针对子节点的权限控制。</p>\n<h2 id=\"2-6-数据模型\"><a href=\"#2-6-数据模型\" class=\"headerlink\" title=\"2.6.数据模型\"></a>2.6.数据模型</h2><ul>\n<li>ZooKeeper 允许分布式进程通过共享的层次结构命名空间进行相互协调，这与标准文件系统类似。</li>\n<li>命名空间由 ZooKeeper 中的数据寄存器组成，称为 Znode，这些类似于文件和目录。</li>\n<li>与为存储设计的典型文件系统不同，ZooKeeper 数据保存在内存中，这意味着 ZooKeeper 可以实现高吞吐量和低延迟。</li>\n</ul>\n<p><img src=\"https://s1.51cto.com/oss/201809/12/08308a2ed38371a6fef72f281598b3df.jpg\" alt=\"\"></p>\n<p>ZooKeeper 数据模型示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[zk: 10.1.39.43:4180(CONNECTED) 7] get /hello  </span><br><span class=\"line\">world  </span><br><span class=\"line\">cZxid = 0x10000042c  </span><br><span class=\"line\">ctime = Fri May 17 17:57:33 CST 2013  </span><br><span class=\"line\">mZxid = 0x10000042c  </span><br><span class=\"line\">mtime = Fri May 17 17:57:33 CST 2013  </span><br><span class=\"line\">pZxid = 0x10000042c  </span><br><span class=\"line\">cversion = 0  </span><br><span class=\"line\">dataVersion = 0  </span><br><span class=\"line\">aclVersion = 0  </span><br><span class=\"line\">ephemeralOwner = 0x0  </span><br><span class=\"line\">dataLength = 5  </span><br><span class=\"line\">numChildren = 0</span><br></pre></td></tr></table></figure>\n<p>使用get命令获取指定节点的数据时, 同时也将返回该节点的状态信息, 称为Stat. 其包含如下字段:</p>\n<ul>\n<li>czxid. 节点创建时的zxid.</li>\n<li>mzxid. 节点最新一次更新发生时的zxid.</li>\n<li>ctime. 节点创建时的时间戳.</li>\n<li>mtime. 节点最新一次更新发生时的时间戳.</li>\n<li>dataVersion. 节点数据的更新次数.</li>\n<li>cversion. 其子节点的更新次数.</li>\n<li>aclVersion. 节点ACL(授权信息)的更新次数.</li>\n<li>ephemeralOwner. 如果该节点为ephemeral节点, ephemeralOwner值表示与该节点绑定的session id. 如果该节点不是ephemeral节点, ephemeralOwner值为0. 至于什么是ephemeral节点, 请看后面的讲述.</li>\n<li>dataLength. 节点数据的字节数.</li>\n<li>numChildren. 子节点个数.</li>\n</ul>\n<p><strong>字段描述</strong></p>\n<ul>\n<li>zxid</li>\n</ul>\n<p>znode节点的状态信息中包含czxid和mzxid, 那么什么是zxid呢?<br>ZooKeeper状态的每一次改变, 都对应着一个递增的<code>Transaction id</code>, 该id称为zxid. 由于zxid的递增性质, 如果zxid1小于zxid2, 那么zxid1肯定先于zxid2发生. 创建任意节点, 或者更新任意节点的数据, 或者删除任意节点, 都会导致Zookeeper状态发生改变, 从而导致zxid的值增加.</p>\n<ul>\n<li>session</li>\n</ul>\n<p>在client和server通信之前, 首先需要建立连接, 该连接称为session. 连接建立后, 如果发生连接超时, 授权失败, 或者显式关闭连接, 连接便处于CLOSED状态, 此时session结束.</p>\n<ul>\n<li>节点类型</li>\n</ul>\n<p>讲述节点状态的ephemeralOwner字段时, 提到过有的节点是ephemeral节点, 而有的并不是. 那么节点都具有哪些类型呢? 每种类型的节点又具有哪些特点呢?<br><code>persistent</code>. persistent节点不和特定的session绑定, 不会随着创建该节点的session的结束而消失, 而是一直存在, 除非该节点被显式删除.<br><code>ephemeral</code>. ephemeral节点是临时性的, 如果创建该节点的session结束了, 该节点就会被自动删除. ephemeral节点不能拥有子节点. 虽然ephemeral节点与创建它的session绑定, 但只要该该节点没有被删除, 其他session就可以读写该节点中关联的数据. 使用-e参数指定创建ephemeral节点.</p>\n<p><code>sequence</code>. 严格的说, sequence并非节点类型中的一种. sequence节点既可以是ephemeral的, 也可以是persistent的. 创建sequence节点时, ZooKeeper server会在指定的节点名称后加上一个数字序列, 该数字序列是递增的. 因此可以多次创建相同的sequence节点, 而得到不同的节点. 使用-s参数指定创建sequence节点.</p>\n<ul>\n<li>watch</li>\n</ul>\n<p>watch的意思是监听感兴趣的事件. 在命令行中, 以下几个命令可以指定是否监听相应的事件.</p>\n<p>ls命令. ls命令的第一个参数指定znode, 第二个参数如果为true, 则说明监听该znode的子节点的增减, 以及该znode本身的删除事件.</p>\n<p>get命令. get命令的第一个参数指定znode, 第二个参数如果为true, 则说明监听该znode的更新和删除事件.stat命令. stat命令用于获取znode的状态信息. 第一个参数指定znode, 如果第二个参数为true, 则监听该node的更新和删除事件.</p>\n<h1 id=\"三、集群构建\"><a href=\"#三、集群构建\" class=\"headerlink\" title=\"三、集群构建\"></a>三、集群构建</h1><p>为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。</p>\n<h2 id=\"3-1-集群角色介绍\"><a href=\"#3-1-集群角色介绍\" class=\"headerlink\" title=\"3.1.集群角色介绍\"></a>3.1.集群角色介绍</h2><p>客户端使用这个 TCP 链接来发送请求、获取结果、获取监听事件以及发送心跳包。如果这个连接异常断开了，客户端可以连接到另外的机器上。ZooKeeper 官方提供的架构图：</p>\n<p><img src=\"https://s4.51cto.com/oss/201809/12/a515a1458ba2bc659fd1c601740cdf53.jpg\" alt=\"\"></p>\n<p>上图中每一个 Server 代表一个安装 ZooKeeper 服务的服务器。组成 ZooKeeper 服务的服务器都会在内存中维护当前的服务器状态，并且每台服务器之间都互相保持着通信。集群间通过 Zab 协议（Zookeeper Atomic Broadcast）来保持数据的一致性。</p>\n<ul>\n<li><p>顺序访问</p>\n<p>对于来自客户端的每个更新请求，ZooKeeper 都会分配一个全局唯一的递增编号。这个编号反应了所有事务操作的先后顺序，应用程序可以使用 ZooKeeper 这个特性来实现更高层次的同步原语。这个编号也叫做时间戳—zxid（ZooKeeper Transaction Id）。</p>\n</li>\n</ul>\n<ul>\n<li><p>高性能</p>\n<p>ZooKeeper 是高性能的。在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）</p>\n</li>\n</ul>\n<p>最典型集群模式：Master/Slave 模式（主备模式）。在这种模式中，通常 Master 服务器作为主服务器提供写服务，其他的 Slave 服务器从服务器通过异步复制的方式获取 Master 服务器最新的数据提供读服务。但是，在 ZooKeeper 中没有选择传统的 Master/Slave 概念，而是引入了<strong>Leader、Follower 和 Observer </strong>三种角色。</p>\n<p>如下图所示：</p>\n<p><img src=\"https://s5.51cto.com/oss/201809/12/96fea87c7024afd577376e7a4b26e460.jpg\" alt=\"\"></p>\n<ul>\n<li>ZooKeeper 集群中的所有机器通过一个 Leader 选举过程来选定一台称为 “Leader” 的机器。</li>\n<li>Leader 既可以为客户端提供写服务又能提供读服务。除了 Leader 外，Follower 和  Observer 都只能提供读服务。</li>\n<li>Follower 和 Observer 唯一的区别在于 Observer 机器不参与 Leader 的选举过程，也不参与写操作的“过半写成功”策略，因此 Observer 机器可以在不影响写性能的情况下提升集群的读性能。</li>\n</ul>\n<p><img src=\"https://s4.51cto.com/oss/201809/12/5e245feb8f8311195763d2abb3e27c20.jpg\" alt=\"\"></p>\n<h2 id=\"3-1-ZAB-协议-amp-Paxos-算法\"><a href=\"#3-1-ZAB-协议-amp-Paxos-算法\" class=\"headerlink\" title=\"3.1.ZAB 协议 &amp; Paxos 算法\"></a>3.1.ZAB 协议 &amp; Paxos 算法</h2><ul>\n<li><p>ZAB 协议 &amp; Paxos 算法</p>\n<p>Paxos 算法可以说是  ZooKeeper 的灵魂了。但是，ZooKeeper 并没有完全采用 Paxos 算法 ，而是使用 ZAB 协议作为其保证数据一致性的核心算法。</p>\n<p>另外，在 ZooKeeper 的官方文档中也指出，ZAB 协议并不像 Paxos 算法那样，是一种通用的分布式一致性算法，它是一种特别为 ZooKeeper 设计的崩溃可恢复的原子消息广播算法。</p>\n</li>\n</ul>\n<ul>\n<li><p>ZAB 协议介绍</p>\n<p>ZAB（ZooKeeper Atomic Broadcast 原子广播）协议是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议。在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性</p>\n</li>\n<li><p>ZAB 协议两种基本的模式</p>\n<p>ZAB 协议包括两种基本的模式，分别是<code>崩溃恢复</code>和<code>消息广播</code>。</p>\n<p>当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进入恢复模式并选举产生新的 Leader 服务器。当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该 Leader 服务器完成了状态同步之后，ZAB 协议就会退出恢复模式。</p>\n<p>其中，所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和 Leader 服务器的数据状态保持一致。</p>\n<p>当集群中已经有过半的 Follower 服务器完成了和 Leader 服务器的状态同步，那么整个服务框架就可以进人消息广播模式了。</p>\n<p>当一台同样遵守 ZAB 协议的服务器启动后加入到集群中时，如果此时集群中已经存在一个 Leader 服务器在负责进行消息广播。那么新加入的服务器就会自觉地进人数据恢复模式：找到 Leader 所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。</p>\n<p>正如上文介绍中所说的，ZooKeeper 设计成只允许唯一的一个 Leader 服务器来进行事务请求的处理。Leader 服务器在接收到客户端的事务请求后，会生成对应的事务提案并发起一轮广播协议。而如果集群中的其他机器接收到客户端的事务请求，那么这些非 Leader 服务器会首先将这个事务请求转发给 Leader 服务器。</p>\n</li>\n</ul>\n<h1 id=\"四、作为dubbo的注册中心\"><a href=\"#四、作为dubbo的注册中心\" class=\"headerlink\" title=\"四、作为dubbo的注册中心\"></a>四、作为dubbo的注册中心</h1><ul>\n<li><p>为什么最好使用奇数台服务器构成 ZooKeeper 集群？我们知道在 ZooKeeper 中 Leader 选举算法采用了 Zab 协议。Zab 核心思想是当多数 Server 写成功，则任务数据写成功：</p>\n<ul>\n<li>如果有 3 个 Server，则最多允许 1 个 Server 挂掉。</li>\n<li>如果有 4 个 Server，则同样最多允许 1 个 Server 挂掉。</li>\n<li>然 3 个或者 4 个 Server，同样最多允许 1 个 Server 挂掉，那么它们的可靠性是一样的。所以选择奇数个 ZooKeeper Server 即可，这里选择 3 个 Server。</li>\n</ul>\n</li>\n<li><p>在 Dubbo 中使用 Zookeeper</p>\n<p>Dubbo 使用 Zookeeper 用于服务的注册发现和配置管理，在 Zookeeper 中数据的组织由下图所示：</p>\n<p><img src=\"https://cdn.nlark.com/lark/0/2018/jpeg/13615/1533281862290-08dd18e0-7950-4ff1-8de0-6dd66362e195.jpeg\" alt=\"\"></p>\n</li>\n</ul>\n<p>首先，所有 Dubbo 相关的数据都组织在 <code>/duboo</code> 的根节点下。</p>\n<p>二级目录是服务名，如 <code>com.foo.BarService</code>。</p>\n<p>三级目录有两个子节点，分别是 <code>providers</code> 和 <code>consumers</code>，表示该服务的提供者和消费者。</p>\n<p>四级目录记录了与该服务相关的每一个应用实例的 URL 信息，在 <code>providers</code> 下的表示该服务的所有提供者，而在 <code>consumers</code> 下的表示该服务的所有消费者。举例说明，<code>com.foo.BarService</code> 的服务提供者在启动时将自己的 URL 信息注册到 <code>/dubbo/com.foo.BarService/providers</code> 下；同样的，服务消费者将自己的信息注册到相应的 <code>consumers</code> 下，同时，服务消费者会订阅其所对应的 <code>providers</code> 节点，以便能够感知到服务提供方地址列表的变化。</p>\n<p><strong>引用文章</strong></p>\n<ul>\n<li><a href=\"http://developer.51cto.com/art/201809/583184.htm\" target=\"_blank\" rel=\"noopener\">http://developer.51cto.com/art/201809/583184.htm</a></li>\n<li><a href=\"http://jm.taobao.org/2018/10/30/%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%94%B9%E9%80%A0%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89-Dubbo-ZooKeeper/\" target=\"_blank\" rel=\"noopener\">http://jm.taobao.org/2018/10/30/%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%94%B9%E9%80%A0%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89-Dubbo-ZooKeeper/</a></li>\n<li><a href=\"https://coolxing.iteye.com/blog/1871328\" target=\"_blank\" rel=\"noopener\">https://coolxing.iteye.com/blog/1871328</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>在项目中也一直在用dubbo，使用Zookeeper 作为注册中心，但对于的内在的一些原理，至今都没有正儿八经的了解过，只是纯粹把它作为一种工具在使用。当被人问到Zookeeper 的时候，整个人都是懵逼的，故写下此文。</p>","more":"<h1 id=\"一、ZooKeeper-概览\"><a href=\"#一、ZooKeeper-概览\" class=\"headerlink\" title=\"一、ZooKeeper 概览\"></a>一、ZooKeeper 概览</h1><p>Zookeeper 分布式服务框架是Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等，设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</p>\n<ul>\n<li>一个典型的分布式数据一致性解决方案；</li>\n<li>一个开源的分布式协调服务；</li>\n<li>顺序一致性：从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。</li>\n<li>原子性：所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。</li>\n<li>单一系统映像：无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。</li>\n<li>可靠性：一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。</li>\n</ul>\n<h1 id=\"二、重要概念\"><a href=\"#二、重要概念\" class=\"headerlink\" title=\"二、重要概念\"></a>二、重要概念</h1><ul>\n<li>ZooKeeper 本身就是一个分布式程序（只要半数以上节点存活，ZooKeeper 就能正常服务）。</li>\n<li>为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。</li>\n<li>ZooKeeper 将数据保存在内存中，这也就保证了 高吞吐量和低延迟（但是内存限制了能够存储的容量不太大，此限制也是保持 Znode 中存储的数据量较小的进一步原因）。</li>\n<li>ZooKeeper 是高性能的。在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）</li>\n<li>ZooKeeper 有临时节点的概念。当创建临时节点的客户端会话一直保持活动，瞬时节点就一直存在。而当会话终结时，瞬时节点被删除。持久节点是指一旦这个 ZNode 被创建了，除非主动进行 ZNode 的移除操作，否则这个 ZNode 将一直保存在 Zookeeper 上。</li>\n<li>ZooKeeper 底层其实只提供了两个功能：①管理（存储、读取）用户程序提交的数据；②为用户程序提交数据节点监听服务。</li>\n</ul>\n<h2 id=\"2-1-会话（Session）\"><a href=\"#2-1-会话（Session）\" class=\"headerlink\" title=\"2.1.会话（Session）\"></a>2.1.会话（Session）</h2><p>Session 指的是 ZooKeeper  服务器与客户端会话。在 ZooKeeper 中，一个客户端连接是指客户端和服务器之间的一个 TCP 长连接。客户端启动的时候，首先会与服务器建立一个 TCP 连接，从第一次连接建立开始，客户端会话的生命周期也开始了。通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向 Zookeeper 服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的 Watch 事件通知。</p>\n<p>Session 的 sessionTimeout 值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在 sessionTimeout 规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。</p>\n<p>在为客户端创建会话之前，服务端首先会为每个客户端都分配一个 sessionID。由于 sessionID 是 Zookeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 sessionID 的。因此，无论是哪台服务器为客户端分配的 sessionID，都务必保证全局唯一。</p>\n<h2 id=\"2-2-节点（Znode）\"><a href=\"#2-2-节点（Znode）\" class=\"headerlink\" title=\"2.2.节点（Znode）\"></a>2.2.节点（Znode）</h2><p>在谈到分布式的时候，我们通常说的“节点”是指组成集群的每一台机器。</p>\n<p>然而，在 ZooKeeper 中，“节点”分为两类：</p>\n<ul>\n<li>第一类同样是指构成集群的机器，我们称之为机器节点。</li>\n<li>第二类则是指数据模型中的数据单元，我们称之为数据节点一ZNode。</li>\n</ul>\n<p>ZooKeeper 将所有数据存储在内存中，数据模型是一棵树（Znode Tree)，由斜杠（/）的进行分割的路径，就是一个 Znode，例如/foo/path1。每个上都会保存自己的数据内容，同时还会保存一系列属性信息。</p>\n<p>在 Zookeeper 中，Node 可以分为持久节点和临时节点两类。所谓持久节点是指一旦这个 ZNode 被创建了，除非主动进行 ZNode 的移除操作，否则这个 ZNode 将一直保存在 ZooKeeper 上。而临时节点就不一样了，它的生命周期和客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。</p>\n<p>另外，ZooKeeper 还允许用户为每个节点添加一个特殊的属性：SEQUENTIAL。一旦节点被标记上这个属性，那么在这个节点被创建的时候，ZooKeeper 会自动在其节点名后面追加上一个整型数字，这个整型数字是一个由父节点维护的自增数字。</p>\n<h2 id=\"2-3-节点（Version）\"><a href=\"#2-3-节点（Version）\" class=\"headerlink\" title=\"2.3.节点（Version）\"></a>2.3.节点（Version）</h2><p>在前面我们已经提到，Zookeeper 的每个 ZNode 上都会存储数据，对应于每个 ZNode，Zookeeper 都会为其维护一个叫作 Stat 的数据结构。</p>\n<p>Stat 中记录了这个 ZNode 的三个数据版本，分别是：</p>\n<ul>\n<li>version（当前 ZNode 的版本）</li>\n<li>cversion（当前 ZNode 子节点的版本）</li>\n<li>aversion（当前 ZNode 的 ACL 版本）</li>\n</ul>\n<h2 id=\"2-4-事件监听器（Watcher）\"><a href=\"#2-4-事件监听器（Watcher）\" class=\"headerlink\" title=\"2.4.事件监听器（Watcher）\"></a>2.4.事件监听器（Watcher）</h2><p>Watcher（事件监听器），是 ZooKeeper 中的一个很重要的特性。ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。</p>\n<h2 id=\"2-5-ACL\"><a href=\"#2-5-ACL\" class=\"headerlink\" title=\"2.5.ACL\"></a>2.5.ACL</h2><p>ZooKeeper 采用 ACL（AccessControlLists）策略来进行权限控制，类似于  UNIX 文件系统的权限控制。</p>\n<p>ZooKeeper 定义了 5 种权限，如下图：</p>\n<ul>\n<li>CREATE 创建子节点权限</li>\n<li>READ 获取节点数据和子节点列表的权限</li>\n<li>WRITE 更新节点数据权限</li>\n<li>DELETE 删除子节点权限</li>\n<li>ADMIN 设置节点ACL的权限</li>\n</ul>\n<p>其中尤其需要注意的是，CREATE 和 DELETE 这两种权限都是针对子节点的权限控制。</p>\n<h2 id=\"2-6-数据模型\"><a href=\"#2-6-数据模型\" class=\"headerlink\" title=\"2.6.数据模型\"></a>2.6.数据模型</h2><ul>\n<li>ZooKeeper 允许分布式进程通过共享的层次结构命名空间进行相互协调，这与标准文件系统类似。</li>\n<li>命名空间由 ZooKeeper 中的数据寄存器组成，称为 Znode，这些类似于文件和目录。</li>\n<li>与为存储设计的典型文件系统不同，ZooKeeper 数据保存在内存中，这意味着 ZooKeeper 可以实现高吞吐量和低延迟。</li>\n</ul>\n<p><img src=\"https://s1.51cto.com/oss/201809/12/08308a2ed38371a6fef72f281598b3df.jpg\" alt=\"\"></p>\n<p>ZooKeeper 数据模型示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[zk: 10.1.39.43:4180(CONNECTED) 7] get /hello  </span><br><span class=\"line\">world  </span><br><span class=\"line\">cZxid = 0x10000042c  </span><br><span class=\"line\">ctime = Fri May 17 17:57:33 CST 2013  </span><br><span class=\"line\">mZxid = 0x10000042c  </span><br><span class=\"line\">mtime = Fri May 17 17:57:33 CST 2013  </span><br><span class=\"line\">pZxid = 0x10000042c  </span><br><span class=\"line\">cversion = 0  </span><br><span class=\"line\">dataVersion = 0  </span><br><span class=\"line\">aclVersion = 0  </span><br><span class=\"line\">ephemeralOwner = 0x0  </span><br><span class=\"line\">dataLength = 5  </span><br><span class=\"line\">numChildren = 0</span><br></pre></td></tr></table></figure>\n<p>使用get命令获取指定节点的数据时, 同时也将返回该节点的状态信息, 称为Stat. 其包含如下字段:</p>\n<ul>\n<li>czxid. 节点创建时的zxid.</li>\n<li>mzxid. 节点最新一次更新发生时的zxid.</li>\n<li>ctime. 节点创建时的时间戳.</li>\n<li>mtime. 节点最新一次更新发生时的时间戳.</li>\n<li>dataVersion. 节点数据的更新次数.</li>\n<li>cversion. 其子节点的更新次数.</li>\n<li>aclVersion. 节点ACL(授权信息)的更新次数.</li>\n<li>ephemeralOwner. 如果该节点为ephemeral节点, ephemeralOwner值表示与该节点绑定的session id. 如果该节点不是ephemeral节点, ephemeralOwner值为0. 至于什么是ephemeral节点, 请看后面的讲述.</li>\n<li>dataLength. 节点数据的字节数.</li>\n<li>numChildren. 子节点个数.</li>\n</ul>\n<p><strong>字段描述</strong></p>\n<ul>\n<li>zxid</li>\n</ul>\n<p>znode节点的状态信息中包含czxid和mzxid, 那么什么是zxid呢?<br>ZooKeeper状态的每一次改变, 都对应着一个递增的<code>Transaction id</code>, 该id称为zxid. 由于zxid的递增性质, 如果zxid1小于zxid2, 那么zxid1肯定先于zxid2发生. 创建任意节点, 或者更新任意节点的数据, 或者删除任意节点, 都会导致Zookeeper状态发生改变, 从而导致zxid的值增加.</p>\n<ul>\n<li>session</li>\n</ul>\n<p>在client和server通信之前, 首先需要建立连接, 该连接称为session. 连接建立后, 如果发生连接超时, 授权失败, 或者显式关闭连接, 连接便处于CLOSED状态, 此时session结束.</p>\n<ul>\n<li>节点类型</li>\n</ul>\n<p>讲述节点状态的ephemeralOwner字段时, 提到过有的节点是ephemeral节点, 而有的并不是. 那么节点都具有哪些类型呢? 每种类型的节点又具有哪些特点呢?<br><code>persistent</code>. persistent节点不和特定的session绑定, 不会随着创建该节点的session的结束而消失, 而是一直存在, 除非该节点被显式删除.<br><code>ephemeral</code>. ephemeral节点是临时性的, 如果创建该节点的session结束了, 该节点就会被自动删除. ephemeral节点不能拥有子节点. 虽然ephemeral节点与创建它的session绑定, 但只要该该节点没有被删除, 其他session就可以读写该节点中关联的数据. 使用-e参数指定创建ephemeral节点.</p>\n<p><code>sequence</code>. 严格的说, sequence并非节点类型中的一种. sequence节点既可以是ephemeral的, 也可以是persistent的. 创建sequence节点时, ZooKeeper server会在指定的节点名称后加上一个数字序列, 该数字序列是递增的. 因此可以多次创建相同的sequence节点, 而得到不同的节点. 使用-s参数指定创建sequence节点.</p>\n<ul>\n<li>watch</li>\n</ul>\n<p>watch的意思是监听感兴趣的事件. 在命令行中, 以下几个命令可以指定是否监听相应的事件.</p>\n<p>ls命令. ls命令的第一个参数指定znode, 第二个参数如果为true, 则说明监听该znode的子节点的增减, 以及该znode本身的删除事件.</p>\n<p>get命令. get命令的第一个参数指定znode, 第二个参数如果为true, 则说明监听该znode的更新和删除事件.stat命令. stat命令用于获取znode的状态信息. 第一个参数指定znode, 如果第二个参数为true, 则监听该node的更新和删除事件.</p>\n<h1 id=\"三、集群构建\"><a href=\"#三、集群构建\" class=\"headerlink\" title=\"三、集群构建\"></a>三、集群构建</h1><p>为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。</p>\n<h2 id=\"3-1-集群角色介绍\"><a href=\"#3-1-集群角色介绍\" class=\"headerlink\" title=\"3.1.集群角色介绍\"></a>3.1.集群角色介绍</h2><p>客户端使用这个 TCP 链接来发送请求、获取结果、获取监听事件以及发送心跳包。如果这个连接异常断开了，客户端可以连接到另外的机器上。ZooKeeper 官方提供的架构图：</p>\n<p><img src=\"https://s4.51cto.com/oss/201809/12/a515a1458ba2bc659fd1c601740cdf53.jpg\" alt=\"\"></p>\n<p>上图中每一个 Server 代表一个安装 ZooKeeper 服务的服务器。组成 ZooKeeper 服务的服务器都会在内存中维护当前的服务器状态，并且每台服务器之间都互相保持着通信。集群间通过 Zab 协议（Zookeeper Atomic Broadcast）来保持数据的一致性。</p>\n<ul>\n<li><p>顺序访问</p>\n<p>对于来自客户端的每个更新请求，ZooKeeper 都会分配一个全局唯一的递增编号。这个编号反应了所有事务操作的先后顺序，应用程序可以使用 ZooKeeper 这个特性来实现更高层次的同步原语。这个编号也叫做时间戳—zxid（ZooKeeper Transaction Id）。</p>\n</li>\n</ul>\n<ul>\n<li><p>高性能</p>\n<p>ZooKeeper 是高性能的。在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）</p>\n</li>\n</ul>\n<p>最典型集群模式：Master/Slave 模式（主备模式）。在这种模式中，通常 Master 服务器作为主服务器提供写服务，其他的 Slave 服务器从服务器通过异步复制的方式获取 Master 服务器最新的数据提供读服务。但是，在 ZooKeeper 中没有选择传统的 Master/Slave 概念，而是引入了<strong>Leader、Follower 和 Observer </strong>三种角色。</p>\n<p>如下图所示：</p>\n<p><img src=\"https://s5.51cto.com/oss/201809/12/96fea87c7024afd577376e7a4b26e460.jpg\" alt=\"\"></p>\n<ul>\n<li>ZooKeeper 集群中的所有机器通过一个 Leader 选举过程来选定一台称为 “Leader” 的机器。</li>\n<li>Leader 既可以为客户端提供写服务又能提供读服务。除了 Leader 外，Follower 和  Observer 都只能提供读服务。</li>\n<li>Follower 和 Observer 唯一的区别在于 Observer 机器不参与 Leader 的选举过程，也不参与写操作的“过半写成功”策略，因此 Observer 机器可以在不影响写性能的情况下提升集群的读性能。</li>\n</ul>\n<p><img src=\"https://s4.51cto.com/oss/201809/12/5e245feb8f8311195763d2abb3e27c20.jpg\" alt=\"\"></p>\n<h2 id=\"3-1-ZAB-协议-amp-Paxos-算法\"><a href=\"#3-1-ZAB-协议-amp-Paxos-算法\" class=\"headerlink\" title=\"3.1.ZAB 协议 &amp; Paxos 算法\"></a>3.1.ZAB 协议 &amp; Paxos 算法</h2><ul>\n<li><p>ZAB 协议 &amp; Paxos 算法</p>\n<p>Paxos 算法可以说是  ZooKeeper 的灵魂了。但是，ZooKeeper 并没有完全采用 Paxos 算法 ，而是使用 ZAB 协议作为其保证数据一致性的核心算法。</p>\n<p>另外，在 ZooKeeper 的官方文档中也指出，ZAB 协议并不像 Paxos 算法那样，是一种通用的分布式一致性算法，它是一种特别为 ZooKeeper 设计的崩溃可恢复的原子消息广播算法。</p>\n</li>\n</ul>\n<ul>\n<li><p>ZAB 协议介绍</p>\n<p>ZAB（ZooKeeper Atomic Broadcast 原子广播）协议是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议。在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性</p>\n</li>\n<li><p>ZAB 协议两种基本的模式</p>\n<p>ZAB 协议包括两种基本的模式，分别是<code>崩溃恢复</code>和<code>消息广播</code>。</p>\n<p>当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进入恢复模式并选举产生新的 Leader 服务器。当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该 Leader 服务器完成了状态同步之后，ZAB 协议就会退出恢复模式。</p>\n<p>其中，所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和 Leader 服务器的数据状态保持一致。</p>\n<p>当集群中已经有过半的 Follower 服务器完成了和 Leader 服务器的状态同步，那么整个服务框架就可以进人消息广播模式了。</p>\n<p>当一台同样遵守 ZAB 协议的服务器启动后加入到集群中时，如果此时集群中已经存在一个 Leader 服务器在负责进行消息广播。那么新加入的服务器就会自觉地进人数据恢复模式：找到 Leader 所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。</p>\n<p>正如上文介绍中所说的，ZooKeeper 设计成只允许唯一的一个 Leader 服务器来进行事务请求的处理。Leader 服务器在接收到客户端的事务请求后，会生成对应的事务提案并发起一轮广播协议。而如果集群中的其他机器接收到客户端的事务请求，那么这些非 Leader 服务器会首先将这个事务请求转发给 Leader 服务器。</p>\n</li>\n</ul>\n<h1 id=\"四、作为dubbo的注册中心\"><a href=\"#四、作为dubbo的注册中心\" class=\"headerlink\" title=\"四、作为dubbo的注册中心\"></a>四、作为dubbo的注册中心</h1><ul>\n<li><p>为什么最好使用奇数台服务器构成 ZooKeeper 集群？我们知道在 ZooKeeper 中 Leader 选举算法采用了 Zab 协议。Zab 核心思想是当多数 Server 写成功，则任务数据写成功：</p>\n<ul>\n<li>如果有 3 个 Server，则最多允许 1 个 Server 挂掉。</li>\n<li>如果有 4 个 Server，则同样最多允许 1 个 Server 挂掉。</li>\n<li>然 3 个或者 4 个 Server，同样最多允许 1 个 Server 挂掉，那么它们的可靠性是一样的。所以选择奇数个 ZooKeeper Server 即可，这里选择 3 个 Server。</li>\n</ul>\n</li>\n<li><p>在 Dubbo 中使用 Zookeeper</p>\n<p>Dubbo 使用 Zookeeper 用于服务的注册发现和配置管理，在 Zookeeper 中数据的组织由下图所示：</p>\n<p><img src=\"https://cdn.nlark.com/lark/0/2018/jpeg/13615/1533281862290-08dd18e0-7950-4ff1-8de0-6dd66362e195.jpeg\" alt=\"\"></p>\n</li>\n</ul>\n<p>首先，所有 Dubbo 相关的数据都组织在 <code>/duboo</code> 的根节点下。</p>\n<p>二级目录是服务名，如 <code>com.foo.BarService</code>。</p>\n<p>三级目录有两个子节点，分别是 <code>providers</code> 和 <code>consumers</code>，表示该服务的提供者和消费者。</p>\n<p>四级目录记录了与该服务相关的每一个应用实例的 URL 信息，在 <code>providers</code> 下的表示该服务的所有提供者，而在 <code>consumers</code> 下的表示该服务的所有消费者。举例说明，<code>com.foo.BarService</code> 的服务提供者在启动时将自己的 URL 信息注册到 <code>/dubbo/com.foo.BarService/providers</code> 下；同样的，服务消费者将自己的信息注册到相应的 <code>consumers</code> 下，同时，服务消费者会订阅其所对应的 <code>providers</code> 节点，以便能够感知到服务提供方地址列表的变化。</p>\n<p><strong>引用文章</strong></p>\n<ul>\n<li><a href=\"http://developer.51cto.com/art/201809/583184.htm\" target=\"_blank\" rel=\"noopener\">http://developer.51cto.com/art/201809/583184.htm</a></li>\n<li><a href=\"http://jm.taobao.org/2018/10/30/%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%94%B9%E9%80%A0%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89-Dubbo-ZooKeeper/\" target=\"_blank\" rel=\"noopener\">http://jm.taobao.org/2018/10/30/%E6%9C%8D%E5%8A%A1%E5%8C%96%E6%94%B9%E9%80%A0%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89-Dubbo-ZooKeeper/</a></li>\n<li><a href=\"https://coolxing.iteye.com/blog/1871328\" target=\"_blank\" rel=\"noopener\">https://coolxing.iteye.com/blog/1871328</a></li>\n</ul>"},{"title":"git命令介绍","abbrlink":"5220878b-git-command-introduction","date":"2018-01-11T14:00:32.000Z","_content":"`git`的命令跟`Linus系统`的命令部分是一样的，因为创作者是同一个人 **Linus Torvalds**，本文主要是为了记录下学习git的过程以及常用的命令。如果是初学者，请拖到文章末尾，点击参考引用处的链接。\n<!-- more -->\n### 一、操控文件夹\n- 创建文件夹\n`$ mkdir learngit`\n- 进入文件夹\n`$ cd learngit`\n- 显示当前路径\n```\n$ pwd   \n/Users/michael/learngit\n```\n### 二、初始化仓库及操控文件\n- 把这个目录变成Git可以管理的仓库\n```\n$ git init\nInitialized empty Git repository in f:/dev-doc/gitlearn/.git/\n```\n此时会生成一个`.git`目录，默认是被隐藏了的，可使用`ls -ah`进行查看。\n- 在当前目录新建 .txt 文件后填写一些内容，然后把文件添加到版本库(暂存区stage)中。\n`git add readme.txt`\n- 提交(暂存区stage)上一步添加的内容\n`git commit -m \"第一次提交readme.txt\"`\n- 时刻掌握仓库当前的状态\n`git status`\n-   查看difference\n`git diff`\n- 查看从最近到最远的提交日志\n```\ngit log\n$ git log --pretty=oneline  //优雅展示\n```\n\n### 三、版本回退\n在 Git 中，用`HEAD`表示当前版本,上一个版本就是`HEAD^`，上上一个版本就是`HEAD^^`，当然往上100个版本可以简写成`HEAD~100`\n```\ngit reset --hard HEAD^\n```\n当刚才那个版本回退了，又不想回退了，通过commit id进行回退（前提：刚才那个命令行对话框还没有关闭） \n```\ngit reset --hard <版本号>\n//版本号没必要写全，前几位就可以了，Git会自动去找\n```\nGit 的版本回退速度非常快，因为 Git 在内部有个指向当前版本的 HEAD 指针，当你回退版本的时候，Git 仅仅是把 HEAD 从指向你回退的版本。\n- 查看命令历史，以便确定要回到未来的哪个版本\n`git reflog`\n- 撤销文件在工作区的修改,让这个文件回到最近一次`git commit`或`git add`时的状态\n`git checkout -- readme.txt` 命令中的`--`别漏了。\n- 把暂存区的修改撤销掉，重新放回工作区\n`git reset HEAD readme.txt`\ngit reset命令既可以**回退版本**，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。\n- 删除文件\n```\nrm haha.txt  //删除文件，还未添加到 暂存区stage \ngit rm haha.txt //删除文件后同时添加到暂存区stage\n```\n\n### 四、远程仓库\n- 关联远程仓库\n```\ngit remote add origin git@git.coding.net:shandianlala/LearnGit.git\ngit push -u origin master  //第一次带上-u,后续不用\ngit pull git@git.coding.net:shandianlala/LearnGit.git\ngit push origin master\n```\n- 克隆远程仓库\n`git clone git@git.coding.net:shandianlala/LearnGit.git`\n\n\n### 五、分支策略\n- 分支\n```\n查看分支：git branch\n创建分支：git branch <name>\n切换分支：git checkout <name>\n创建+切换分支：git checkout -b <name>\n合并某分支到当前分支：git merge <name>\n删除分支：git branch -d <name>\n\ngit log --graph --pretty=oneline --abbrev-commit  //分支合并图\ngit log --graph //分支合并图\n//打印日志太多按 q 退出查看，按 space 空格下一页日志。\n```\n- 分支合并策略\n```\ngit merge --no-ff -m \"merge with no-ff\" dev\n//准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward\n//因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。\n```\n合并分支时，加上`--no-ff`参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而`fast forward`合并就看不出来曾经做过合并。\n\n- 开发一个新feature，最好新建一个分支；\n- 如果要丢弃一个没有被合并过的分支，可以通过`git branch -D <branchName>`强行删除。\n- 查看远程库信息，使用`git remote -v`；\n- 本地新建的分支如果不推送到远程，对其他人就是不可见的；\n- 从本地推送分支，使用`git push origin branch-name`，如果推送失败，先用`git pull`抓取远程的新提交；\n- 在本地创建和远程分支对应的分支，使用`git checkout -b branch-name origin/branch-name`，本地和远程分支的名称最好一致；\n- 建立本地分支和远程分支的关联，使用`git branch --set-upstream branch-name origin/branch-name`；\n- 从远程抓取分支，使用`git pull`，如果有冲突，要先处理冲突。\n\n\n### 六、标签\n- 命令`git tag <name> [commitId]`用于新建一个标签，默认为`HEAD`，也可以指定一个`commit id`；\n- `git tag -a <tagname> -m \"打个标签...\"`可以指定标签信息；\n- `git tag -s <tagname> -m \"打个标签...\"`可以用PGP签名标签；\n- 命令`git tag`可以查看所有标签。\n- 命令`git push origin <tagname>`可以推送一个本地标签；\n- 命令`git push origin --tags`可以推送全部未推送过的本地标签；\n- 命令`git tag -d <tagname>`可以删除一个本地标签；\n- 命令`git push origin :refs/tags/<tagname>`可以删除一个远程标签（先删除本地，在远程）。\n\n\n> 所有的版本控制系统，其实只能跟踪文本文件的改动，而图片、视频、word这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从99KB改成了178KB，但到底改了哪些，版本控制系统不知道，也没法知道。\n \n**参考**\nhttps://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000","source":"_posts/git命令介绍.md","raw":"---\ntitle: git命令介绍\nabbrlink: 5220878b-git-command-introduction\ndate: 2018-01-11 22:00:32\ntags:\n---\n`git`的命令跟`Linus系统`的命令部分是一样的，因为创作者是同一个人 **Linus Torvalds**，本文主要是为了记录下学习git的过程以及常用的命令。如果是初学者，请拖到文章末尾，点击参考引用处的链接。\n<!-- more -->\n### 一、操控文件夹\n- 创建文件夹\n`$ mkdir learngit`\n- 进入文件夹\n`$ cd learngit`\n- 显示当前路径\n```\n$ pwd   \n/Users/michael/learngit\n```\n### 二、初始化仓库及操控文件\n- 把这个目录变成Git可以管理的仓库\n```\n$ git init\nInitialized empty Git repository in f:/dev-doc/gitlearn/.git/\n```\n此时会生成一个`.git`目录，默认是被隐藏了的，可使用`ls -ah`进行查看。\n- 在当前目录新建 .txt 文件后填写一些内容，然后把文件添加到版本库(暂存区stage)中。\n`git add readme.txt`\n- 提交(暂存区stage)上一步添加的内容\n`git commit -m \"第一次提交readme.txt\"`\n- 时刻掌握仓库当前的状态\n`git status`\n-   查看difference\n`git diff`\n- 查看从最近到最远的提交日志\n```\ngit log\n$ git log --pretty=oneline  //优雅展示\n```\n\n### 三、版本回退\n在 Git 中，用`HEAD`表示当前版本,上一个版本就是`HEAD^`，上上一个版本就是`HEAD^^`，当然往上100个版本可以简写成`HEAD~100`\n```\ngit reset --hard HEAD^\n```\n当刚才那个版本回退了，又不想回退了，通过commit id进行回退（前提：刚才那个命令行对话框还没有关闭） \n```\ngit reset --hard <版本号>\n//版本号没必要写全，前几位就可以了，Git会自动去找\n```\nGit 的版本回退速度非常快，因为 Git 在内部有个指向当前版本的 HEAD 指针，当你回退版本的时候，Git 仅仅是把 HEAD 从指向你回退的版本。\n- 查看命令历史，以便确定要回到未来的哪个版本\n`git reflog`\n- 撤销文件在工作区的修改,让这个文件回到最近一次`git commit`或`git add`时的状态\n`git checkout -- readme.txt` 命令中的`--`别漏了。\n- 把暂存区的修改撤销掉，重新放回工作区\n`git reset HEAD readme.txt`\ngit reset命令既可以**回退版本**，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。\n- 删除文件\n```\nrm haha.txt  //删除文件，还未添加到 暂存区stage \ngit rm haha.txt //删除文件后同时添加到暂存区stage\n```\n\n### 四、远程仓库\n- 关联远程仓库\n```\ngit remote add origin git@git.coding.net:shandianlala/LearnGit.git\ngit push -u origin master  //第一次带上-u,后续不用\ngit pull git@git.coding.net:shandianlala/LearnGit.git\ngit push origin master\n```\n- 克隆远程仓库\n`git clone git@git.coding.net:shandianlala/LearnGit.git`\n\n\n### 五、分支策略\n- 分支\n```\n查看分支：git branch\n创建分支：git branch <name>\n切换分支：git checkout <name>\n创建+切换分支：git checkout -b <name>\n合并某分支到当前分支：git merge <name>\n删除分支：git branch -d <name>\n\ngit log --graph --pretty=oneline --abbrev-commit  //分支合并图\ngit log --graph //分支合并图\n//打印日志太多按 q 退出查看，按 space 空格下一页日志。\n```\n- 分支合并策略\n```\ngit merge --no-ff -m \"merge with no-ff\" dev\n//准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward\n//因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。\n```\n合并分支时，加上`--no-ff`参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而`fast forward`合并就看不出来曾经做过合并。\n\n- 开发一个新feature，最好新建一个分支；\n- 如果要丢弃一个没有被合并过的分支，可以通过`git branch -D <branchName>`强行删除。\n- 查看远程库信息，使用`git remote -v`；\n- 本地新建的分支如果不推送到远程，对其他人就是不可见的；\n- 从本地推送分支，使用`git push origin branch-name`，如果推送失败，先用`git pull`抓取远程的新提交；\n- 在本地创建和远程分支对应的分支，使用`git checkout -b branch-name origin/branch-name`，本地和远程分支的名称最好一致；\n- 建立本地分支和远程分支的关联，使用`git branch --set-upstream branch-name origin/branch-name`；\n- 从远程抓取分支，使用`git pull`，如果有冲突，要先处理冲突。\n\n\n### 六、标签\n- 命令`git tag <name> [commitId]`用于新建一个标签，默认为`HEAD`，也可以指定一个`commit id`；\n- `git tag -a <tagname> -m \"打个标签...\"`可以指定标签信息；\n- `git tag -s <tagname> -m \"打个标签...\"`可以用PGP签名标签；\n- 命令`git tag`可以查看所有标签。\n- 命令`git push origin <tagname>`可以推送一个本地标签；\n- 命令`git push origin --tags`可以推送全部未推送过的本地标签；\n- 命令`git tag -d <tagname>`可以删除一个本地标签；\n- 命令`git push origin :refs/tags/<tagname>`可以删除一个远程标签（先删除本地，在远程）。\n\n\n> 所有的版本控制系统，其实只能跟踪文本文件的改动，而图片、视频、word这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从99KB改成了178KB，但到底改了哪些，版本控制系统不知道，也没法知道。\n \n**参考**\nhttps://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000","slug":"git命令介绍","published":1,"updated":"2018-01-11T14:45:50.339Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2w200vv000hmwd3zihda5z1","content":"<p><code>git</code>的命令跟<code>Linus系统</code>的命令部分是一样的，因为创作者是同一个人 <strong>Linus Torvalds</strong>，本文主要是为了记录下学习git的过程以及常用的命令。如果是初学者，请拖到文章末尾，点击参考引用处的链接。<br><a id=\"more\"></a></p>\n<h3 id=\"一、操控文件夹\"><a href=\"#一、操控文件夹\" class=\"headerlink\" title=\"一、操控文件夹\"></a>一、操控文件夹</h3><ul>\n<li>创建文件夹<br><code>$ mkdir learngit</code></li>\n<li>进入文件夹<br><code>$ cd learngit</code></li>\n<li>显示当前路径<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pwd   </span><br><span class=\"line\">/Users/michael/learngit</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"二、初始化仓库及操控文件\"><a href=\"#二、初始化仓库及操控文件\" class=\"headerlink\" title=\"二、初始化仓库及操控文件\"></a>二、初始化仓库及操控文件</h3><ul>\n<li>把这个目录变成Git可以管理的仓库<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git init</span><br><span class=\"line\">Initialized empty Git repository in f:/dev-doc/gitlearn/.git/</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>此时会生成一个<code>.git</code>目录，默认是被隐藏了的，可使用<code>ls -ah</code>进行查看。</p>\n<ul>\n<li>在当前目录新建 .txt 文件后填写一些内容，然后把文件添加到版本库(暂存区stage)中。<br><code>git add readme.txt</code></li>\n<li>提交(暂存区stage)上一步添加的内容<br><code>git commit -m &quot;第一次提交readme.txt&quot;</code></li>\n<li>时刻掌握仓库当前的状态<br><code>git status</code></li>\n<li>查看difference<br><code>git diff</code></li>\n<li>查看从最近到最远的提交日志<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log</span><br><span class=\"line\">$ git log --pretty=oneline  //优雅展示</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"三、版本回退\"><a href=\"#三、版本回退\" class=\"headerlink\" title=\"三、版本回退\"></a>三、版本回退</h3><p>在 Git 中，用<code>HEAD</code>表示当前版本,上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本可以简写成<code>HEAD~100</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard HEAD^</span><br></pre></td></tr></table></figure></p>\n<p>当刚才那个版本回退了，又不想回退了，通过commit id进行回退（前提：刚才那个命令行对话框还没有关闭）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard &lt;版本号&gt;</span><br><span class=\"line\">//版本号没必要写全，前几位就可以了，Git会自动去找</span><br></pre></td></tr></table></figure></p>\n<p>Git 的版本回退速度非常快，因为 Git 在内部有个指向当前版本的 HEAD 指针，当你回退版本的时候，Git 仅仅是把 HEAD 从指向你回退的版本。</p>\n<ul>\n<li>查看命令历史，以便确定要回到未来的哪个版本<br><code>git reflog</code></li>\n<li>撤销文件在工作区的修改,让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态<br><code>git checkout -- readme.txt</code> 命令中的<code>--</code>别漏了。</li>\n<li>把暂存区的修改撤销掉，重新放回工作区<br><code>git reset HEAD readme.txt</code><br>git reset命令既可以<strong>回退版本</strong>，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。</li>\n<li>删除文件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm haha.txt  //删除文件，还未添加到 暂存区stage </span><br><span class=\"line\">git rm haha.txt //删除文件后同时添加到暂存区stage</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"四、远程仓库\"><a href=\"#四、远程仓库\" class=\"headerlink\" title=\"四、远程仓库\"></a>四、远程仓库</h3><ul>\n<li><p>关联远程仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin git@git.coding.net:shandianlala/LearnGit.git</span><br><span class=\"line\">git push -u origin master  //第一次带上-u,后续不用</span><br><span class=\"line\">git pull git@git.coding.net:shandianlala/LearnGit.git</span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>克隆远程仓库<br><code>git clone git@git.coding.net:shandianlala/LearnGit.git</code></p>\n</li>\n</ul>\n<h3 id=\"五、分支策略\"><a href=\"#五、分支策略\" class=\"headerlink\" title=\"五、分支策略\"></a>五、分支策略</h3><ul>\n<li><p>分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查看分支：git branch</span><br><span class=\"line\">创建分支：git branch &lt;name&gt;</span><br><span class=\"line\">切换分支：git checkout &lt;name&gt;</span><br><span class=\"line\">创建+切换分支：git checkout -b &lt;name&gt;</span><br><span class=\"line\">合并某分支到当前分支：git merge &lt;name&gt;</span><br><span class=\"line\">删除分支：git branch -d &lt;name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">git log --graph --pretty=oneline --abbrev-commit  //分支合并图</span><br><span class=\"line\">git log --graph //分支合并图</span><br><span class=\"line\">//打印日志太多按 q 退出查看，按 space 空格下一页日志。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>分支合并策略</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br><span class=\"line\">//准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward</span><br><span class=\"line\">//因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p>\n<ul>\n<li>开发一个新feature，最好新建一个分支；</li>\n<li>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;branchName&gt;</code>强行删除。</li>\n<li>查看远程库信息，使用<code>git remote -v</code>；</li>\n<li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li>\n<li>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</li>\n<li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</li>\n<li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</li>\n<li>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</li>\n</ul>\n<h3 id=\"六、标签\"><a href=\"#六、标签\" class=\"headerlink\" title=\"六、标签\"></a>六、标签</h3><ul>\n<li>命令<code>git tag &lt;name&gt; [commitId]</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个<code>commit id</code>；</li>\n<li><code>git tag -a &lt;tagname&gt; -m &quot;打个标签...&quot;</code>可以指定标签信息；</li>\n<li><code>git tag -s &lt;tagname&gt; -m &quot;打个标签...&quot;</code>可以用PGP签名标签；</li>\n<li>命令<code>git tag</code>可以查看所有标签。</li>\n<li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li>\n<li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li>\n<li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li>\n<li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签（先删除本地，在远程）。</li>\n</ul>\n<blockquote>\n<p>所有的版本控制系统，其实只能跟踪文本文件的改动，而图片、视频、word这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从99KB改成了178KB，但到底改了哪些，版本控制系统不知道，也没法知道。</p>\n</blockquote>\n<p><strong>参考</strong><br><a href=\"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" target=\"_blank\" rel=\"noopener\">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a></p>\n","site":{"data":{}},"excerpt":"<p><code>git</code>的命令跟<code>Linus系统</code>的命令部分是一样的，因为创作者是同一个人 <strong>Linus Torvalds</strong>，本文主要是为了记录下学习git的过程以及常用的命令。如果是初学者，请拖到文章末尾，点击参考引用处的链接。<br>","more":"</p>\n<h3 id=\"一、操控文件夹\"><a href=\"#一、操控文件夹\" class=\"headerlink\" title=\"一、操控文件夹\"></a>一、操控文件夹</h3><ul>\n<li>创建文件夹<br><code>$ mkdir learngit</code></li>\n<li>进入文件夹<br><code>$ cd learngit</code></li>\n<li>显示当前路径<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pwd   </span><br><span class=\"line\">/Users/michael/learngit</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"二、初始化仓库及操控文件\"><a href=\"#二、初始化仓库及操控文件\" class=\"headerlink\" title=\"二、初始化仓库及操控文件\"></a>二、初始化仓库及操控文件</h3><ul>\n<li>把这个目录变成Git可以管理的仓库<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git init</span><br><span class=\"line\">Initialized empty Git repository in f:/dev-doc/gitlearn/.git/</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>此时会生成一个<code>.git</code>目录，默认是被隐藏了的，可使用<code>ls -ah</code>进行查看。</p>\n<ul>\n<li>在当前目录新建 .txt 文件后填写一些内容，然后把文件添加到版本库(暂存区stage)中。<br><code>git add readme.txt</code></li>\n<li>提交(暂存区stage)上一步添加的内容<br><code>git commit -m &quot;第一次提交readme.txt&quot;</code></li>\n<li>时刻掌握仓库当前的状态<br><code>git status</code></li>\n<li>查看difference<br><code>git diff</code></li>\n<li>查看从最近到最远的提交日志<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log</span><br><span class=\"line\">$ git log --pretty=oneline  //优雅展示</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"三、版本回退\"><a href=\"#三、版本回退\" class=\"headerlink\" title=\"三、版本回退\"></a>三、版本回退</h3><p>在 Git 中，用<code>HEAD</code>表示当前版本,上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本可以简写成<code>HEAD~100</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard HEAD^</span><br></pre></td></tr></table></figure></p>\n<p>当刚才那个版本回退了，又不想回退了，通过commit id进行回退（前提：刚才那个命令行对话框还没有关闭）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --hard &lt;版本号&gt;</span><br><span class=\"line\">//版本号没必要写全，前几位就可以了，Git会自动去找</span><br></pre></td></tr></table></figure></p>\n<p>Git 的版本回退速度非常快，因为 Git 在内部有个指向当前版本的 HEAD 指针，当你回退版本的时候，Git 仅仅是把 HEAD 从指向你回退的版本。</p>\n<ul>\n<li>查看命令历史，以便确定要回到未来的哪个版本<br><code>git reflog</code></li>\n<li>撤销文件在工作区的修改,让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态<br><code>git checkout -- readme.txt</code> 命令中的<code>--</code>别漏了。</li>\n<li>把暂存区的修改撤销掉，重新放回工作区<br><code>git reset HEAD readme.txt</code><br>git reset命令既可以<strong>回退版本</strong>，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。</li>\n<li>删除文件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm haha.txt  //删除文件，还未添加到 暂存区stage </span><br><span class=\"line\">git rm haha.txt //删除文件后同时添加到暂存区stage</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"四、远程仓库\"><a href=\"#四、远程仓库\" class=\"headerlink\" title=\"四、远程仓库\"></a>四、远程仓库</h3><ul>\n<li><p>关联远程仓库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin git@git.coding.net:shandianlala/LearnGit.git</span><br><span class=\"line\">git push -u origin master  //第一次带上-u,后续不用</span><br><span class=\"line\">git pull git@git.coding.net:shandianlala/LearnGit.git</span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>克隆远程仓库<br><code>git clone git@git.coding.net:shandianlala/LearnGit.git</code></p>\n</li>\n</ul>\n<h3 id=\"五、分支策略\"><a href=\"#五、分支策略\" class=\"headerlink\" title=\"五、分支策略\"></a>五、分支策略</h3><ul>\n<li><p>分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查看分支：git branch</span><br><span class=\"line\">创建分支：git branch &lt;name&gt;</span><br><span class=\"line\">切换分支：git checkout &lt;name&gt;</span><br><span class=\"line\">创建+切换分支：git checkout -b &lt;name&gt;</span><br><span class=\"line\">合并某分支到当前分支：git merge &lt;name&gt;</span><br><span class=\"line\">删除分支：git branch -d &lt;name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">git log --graph --pretty=oneline --abbrev-commit  //分支合并图</span><br><span class=\"line\">git log --graph //分支合并图</span><br><span class=\"line\">//打印日志太多按 q 退出查看，按 space 空格下一页日志。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>分支合并策略</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br><span class=\"line\">//准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward</span><br><span class=\"line\">//因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p>\n<ul>\n<li>开发一个新feature，最好新建一个分支；</li>\n<li>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;branchName&gt;</code>强行删除。</li>\n<li>查看远程库信息，使用<code>git remote -v</code>；</li>\n<li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li>\n<li>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</li>\n<li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</li>\n<li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</li>\n<li>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</li>\n</ul>\n<h3 id=\"六、标签\"><a href=\"#六、标签\" class=\"headerlink\" title=\"六、标签\"></a>六、标签</h3><ul>\n<li>命令<code>git tag &lt;name&gt; [commitId]</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个<code>commit id</code>；</li>\n<li><code>git tag -a &lt;tagname&gt; -m &quot;打个标签...&quot;</code>可以指定标签信息；</li>\n<li><code>git tag -s &lt;tagname&gt; -m &quot;打个标签...&quot;</code>可以用PGP签名标签；</li>\n<li>命令<code>git tag</code>可以查看所有标签。</li>\n<li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li>\n<li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li>\n<li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li>\n<li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签（先删除本地，在远程）。</li>\n</ul>\n<blockquote>\n<p>所有的版本控制系统，其实只能跟踪文本文件的改动，而图片、视频、word这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从99KB改成了178KB，但到底改了哪些，版本控制系统不知道，也没法知道。</p>\n</blockquote>\n<p><strong>参考</strong><br><a href=\"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" target=\"_blank\" rel=\"noopener\">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a></p>"},{"title":"Hello World","abbrlink":"4a17b156","date":"2017-11-22T02:56:44.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n<!-- more -->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\nabbrlink: 4a17b156\ndate: 2017-11-22 10:56:44\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n<!-- more -->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2017-12-30T12:51:21.265Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2w200w1000kmwd3fw3zlh9h","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.<br><a id=\"more\"></a></p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.<br>","more":"</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>"},{"title":"hexo博客安装教程","abbrlink":"fac581d3-hexo-install","date":"2017-12-30T14:04:05.000Z","_content":"其实一直都没有准备写这个安装教程，是因为一个搞程序的估计大家都会这些，看看文档大概都能明白；今天写这个教程的缘由是因为想把搭建在公司分配的电脑上的博客迁移到自己的电脑上来，毕竟公司的电脑不是自己的，所以，你们懂就好。哈哈！\n<!-- more -->\n### 1.下载git安装\n[windows环境git安装包下载](https://git-scm.com/download/win)\n\n### 2. 下载Node.js安装\n[windows环境Node.js安装包下载](http://nodejs.org/)\n\n### 3.安装好git后，在本地目录hexo(没有的话新建一个)，在文件夹里面点鼠标右键，选择`Git Bash`\n输入命令： \n`npm install -g hexo-cli`\n\n### 4.验证是否安装成功，可以看下版本\n`hexo version`\n\n### 5.初始化环境\n命令：\n`hexo init .`\n\n### 6.“.” 是当前目录，\n初始化后，目录下会自动生成一些文件\n\n### 7.再用命令(可省略)\n`npm isntall` 安装一遍\n\n### 8.启动服务（电脑可能会弹防火墙，确定即可）\n命令:\n`hexo server`\n\n### 9.好了，现在可以访问了 ： \n`http://localhost:4000/` （命令结果提示是`http://0.0.0.0:4000/`）\n\n### 10.打开hexo目录下的_config.yml文件，最后一行那块\n```\n------------修改开始--------------------\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repo: git@github.com:shandianlala/shandianlala.github.io.git\n  branch: master\n  message: '站点更新:{{now(\"YYYY-MM-DD HH/mm/ss\")}}'\n------------修改结束--------------------\n```\n\n10-1、配置本机全局git环境(都是命令)\n`git config --global user.email \"you@example.com\"`\n`git config --global user.name \"Your Name\"`\n\n### 11.生成SSH秘钥\n命令：\n`ssh-keygen -t rsa -C example@gmail.com`\n`-C`后面跟住你在github的用户名邮箱，这样公钥才会被github认可\n\n- 11-1.如果没有报错，提示（enter file in which to save the key），一路回车enter\n\n- 11-2.搜索电脑里的文件：id_rsa.pub\n用notpad++记事本打开,全选里面的内容，复制。\n\n- 11-3.打开  https://github.com/settings/keys\n点击 New SSH key 按钮，title输入框自定义，把刚才复制的内容粘贴到key输入框；\n\n- 11-4.测试连接GitHub、coding\nssh -T git@github.com\nssh -T git@git.coding.net\n提示输入yes/no,输入yes,回车。\n\n### 12.使用命令（即 hexo generate 和 hexo deploy）\nhexo g  \nhexo d  \n\n- 12-1.执行 hexo d 后报错，ERROR Deployer not found: git; 如果没有报错跳过进行下一步\n解决：npm install hexo-deployer-git --save\n然后再次执行  \n`hexo d`\n\n13.生成并发布到github，发布后再github会看到，打开地址访问 yourname.github.io  \n\n14.结束","source":"_posts/hexo博客安装教程.md","raw":"---\ntitle: hexo博客安装教程\nabbrlink: fac581d3-hexo-install\ndate: 2017-12-30 22:04:05\ntags: [hexo博客配置,教程]\n---\n其实一直都没有准备写这个安装教程，是因为一个搞程序的估计大家都会这些，看看文档大概都能明白；今天写这个教程的缘由是因为想把搭建在公司分配的电脑上的博客迁移到自己的电脑上来，毕竟公司的电脑不是自己的，所以，你们懂就好。哈哈！\n<!-- more -->\n### 1.下载git安装\n[windows环境git安装包下载](https://git-scm.com/download/win)\n\n### 2. 下载Node.js安装\n[windows环境Node.js安装包下载](http://nodejs.org/)\n\n### 3.安装好git后，在本地目录hexo(没有的话新建一个)，在文件夹里面点鼠标右键，选择`Git Bash`\n输入命令： \n`npm install -g hexo-cli`\n\n### 4.验证是否安装成功，可以看下版本\n`hexo version`\n\n### 5.初始化环境\n命令：\n`hexo init .`\n\n### 6.“.” 是当前目录，\n初始化后，目录下会自动生成一些文件\n\n### 7.再用命令(可省略)\n`npm isntall` 安装一遍\n\n### 8.启动服务（电脑可能会弹防火墙，确定即可）\n命令:\n`hexo server`\n\n### 9.好了，现在可以访问了 ： \n`http://localhost:4000/` （命令结果提示是`http://0.0.0.0:4000/`）\n\n### 10.打开hexo目录下的_config.yml文件，最后一行那块\n```\n------------修改开始--------------------\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repo: git@github.com:shandianlala/shandianlala.github.io.git\n  branch: master\n  message: '站点更新:{{now(\"YYYY-MM-DD HH/mm/ss\")}}'\n------------修改结束--------------------\n```\n\n10-1、配置本机全局git环境(都是命令)\n`git config --global user.email \"you@example.com\"`\n`git config --global user.name \"Your Name\"`\n\n### 11.生成SSH秘钥\n命令：\n`ssh-keygen -t rsa -C example@gmail.com`\n`-C`后面跟住你在github的用户名邮箱，这样公钥才会被github认可\n\n- 11-1.如果没有报错，提示（enter file in which to save the key），一路回车enter\n\n- 11-2.搜索电脑里的文件：id_rsa.pub\n用notpad++记事本打开,全选里面的内容，复制。\n\n- 11-3.打开  https://github.com/settings/keys\n点击 New SSH key 按钮，title输入框自定义，把刚才复制的内容粘贴到key输入框；\n\n- 11-4.测试连接GitHub、coding\nssh -T git@github.com\nssh -T git@git.coding.net\n提示输入yes/no,输入yes,回车。\n\n### 12.使用命令（即 hexo generate 和 hexo deploy）\nhexo g  \nhexo d  \n\n- 12-1.执行 hexo d 后报错，ERROR Deployer not found: git; 如果没有报错跳过进行下一步\n解决：npm install hexo-deployer-git --save\n然后再次执行  \n`hexo d`\n\n13.生成并发布到github，发布后再github会看到，打开地址访问 yourname.github.io  \n\n14.结束","slug":"hexo博客安装教程","published":1,"updated":"2018-01-02T13:17:35.753Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2w200w7000mmwd3jv113d2e","content":"<p>其实一直都没有准备写这个安装教程，是因为一个搞程序的估计大家都会这些，看看文档大概都能明白；今天写这个教程的缘由是因为想把搭建在公司分配的电脑上的博客迁移到自己的电脑上来，毕竟公司的电脑不是自己的，所以，你们懂就好。哈哈！<br><a id=\"more\"></a></p>\n<h3 id=\"1-下载git安装\"><a href=\"#1-下载git安装\" class=\"headerlink\" title=\"1.下载git安装\"></a>1.下载git安装</h3><p><a href=\"https://git-scm.com/download/win\" target=\"_blank\" rel=\"noopener\">windows环境git安装包下载</a></p>\n<h3 id=\"2-下载Node-js安装\"><a href=\"#2-下载Node-js安装\" class=\"headerlink\" title=\"2. 下载Node.js安装\"></a>2. 下载Node.js安装</h3><p><a href=\"http://nodejs.org/\" target=\"_blank\" rel=\"noopener\">windows环境Node.js安装包下载</a></p>\n<h3 id=\"3-安装好git后，在本地目录hexo-没有的话新建一个-，在文件夹里面点鼠标右键，选择Git-Bash\"><a href=\"#3-安装好git后，在本地目录hexo-没有的话新建一个-，在文件夹里面点鼠标右键，选择Git-Bash\" class=\"headerlink\" title=\"3.安装好git后，在本地目录hexo(没有的话新建一个)，在文件夹里面点鼠标右键，选择Git Bash\"></a>3.安装好git后，在本地目录hexo(没有的话新建一个)，在文件夹里面点鼠标右键，选择<code>Git Bash</code></h3><p>输入命令：<br><code>npm install -g hexo-cli</code></p>\n<h3 id=\"4-验证是否安装成功，可以看下版本\"><a href=\"#4-验证是否安装成功，可以看下版本\" class=\"headerlink\" title=\"4.验证是否安装成功，可以看下版本\"></a>4.验证是否安装成功，可以看下版本</h3><p><code>hexo version</code></p>\n<h3 id=\"5-初始化环境\"><a href=\"#5-初始化环境\" class=\"headerlink\" title=\"5.初始化环境\"></a>5.初始化环境</h3><p>命令：<br><code>hexo init .</code></p>\n<h3 id=\"6-“-”-是当前目录，\"><a href=\"#6-“-”-是当前目录，\" class=\"headerlink\" title=\"6.“.” 是当前目录，\"></a>6.“.” 是当前目录，</h3><p>初始化后，目录下会自动生成一些文件</p>\n<h3 id=\"7-再用命令-可省略\"><a href=\"#7-再用命令-可省略\" class=\"headerlink\" title=\"7.再用命令(可省略)\"></a>7.再用命令(可省略)</h3><p><code>npm isntall</code> 安装一遍</p>\n<h3 id=\"8-启动服务（电脑可能会弹防火墙，确定即可）\"><a href=\"#8-启动服务（电脑可能会弹防火墙，确定即可）\" class=\"headerlink\" title=\"8.启动服务（电脑可能会弹防火墙，确定即可）\"></a>8.启动服务（电脑可能会弹防火墙，确定即可）</h3><p>命令:<br><code>hexo server</code></p>\n<h3 id=\"9-好了，现在可以访问了-：\"><a href=\"#9-好了，现在可以访问了-：\" class=\"headerlink\" title=\"9.好了，现在可以访问了 ：\"></a>9.好了，现在可以访问了 ：</h3><p><code>http://localhost:4000/</code> （命令结果提示是<code>http://0.0.0.0:4000/</code>）</p>\n<h3 id=\"10-打开hexo目录下的-config-yml文件，最后一行那块\"><a href=\"#10-打开hexo目录下的-config-yml文件，最后一行那块\" class=\"headerlink\" title=\"10.打开hexo目录下的_config.yml文件，最后一行那块\"></a>10.打开hexo目录下的_config.yml文件，最后一行那块</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">------------修改开始--------------------</span><br><span class=\"line\"># Deployment</span><br><span class=\"line\">## Docs: https://hexo.io/docs/deployment.html</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: git@github.com:shandianlala/shandianlala.github.io.git</span><br><span class=\"line\">  branch: master</span><br><span class=\"line\">  message: &apos;站点更新:&#123;&#123;now(&quot;YYYY-MM-DD HH/mm/ss&quot;)&#125;&#125;&apos;</span><br><span class=\"line\">------------修改结束--------------------</span><br></pre></td></tr></table></figure>\n<p>10-1、配置本机全局git环境(都是命令)<br><code>git config --global user.email &quot;you@example.com&quot;</code><br><code>git config --global user.name &quot;Your Name&quot;</code></p>\n<h3 id=\"11-生成SSH秘钥\"><a href=\"#11-生成SSH秘钥\" class=\"headerlink\" title=\"11.生成SSH秘钥\"></a>11.生成SSH秘钥</h3><p>命令：<br><code>ssh-keygen -t rsa -C example@gmail.com</code><br><code>-C</code>后面跟住你在github的用户名邮箱，这样公钥才会被github认可</p>\n<ul>\n<li><p>11-1.如果没有报错，提示（enter file in which to save the key），一路回车enter</p>\n</li>\n<li><p>11-2.搜索电脑里的文件：id_rsa.pub<br>用notpad++记事本打开,全选里面的内容，复制。</p>\n</li>\n<li><p>11-3.打开  <a href=\"https://github.com/settings/keys\" target=\"_blank\" rel=\"noopener\">https://github.com/settings/keys</a><br>点击 New SSH key 按钮，title输入框自定义，把刚才复制的内容粘贴到key输入框；</p>\n</li>\n<li><p>11-4.测试连接GitHub、coding<br>ssh -T git@github.com<br>ssh -T git@git.coding.net<br>提示输入yes/no,输入yes,回车。</p>\n</li>\n</ul>\n<h3 id=\"12-使用命令（即-hexo-generate-和-hexo-deploy）\"><a href=\"#12-使用命令（即-hexo-generate-和-hexo-deploy）\" class=\"headerlink\" title=\"12.使用命令（即 hexo generate 和 hexo deploy）\"></a>12.使用命令（即 hexo generate 和 hexo deploy）</h3><p>hexo g<br>hexo d  </p>\n<ul>\n<li>12-1.执行 hexo d 后报错，ERROR Deployer not found: git; 如果没有报错跳过进行下一步<br>解决：npm install hexo-deployer-git –save<br>然后再次执行<br><code>hexo d</code></li>\n</ul>\n<p>13.生成并发布到github，发布后再github会看到，打开地址访问 yourname.github.io  </p>\n<p>14.结束</p>\n","site":{"data":{}},"excerpt":"<p>其实一直都没有准备写这个安装教程，是因为一个搞程序的估计大家都会这些，看看文档大概都能明白；今天写这个教程的缘由是因为想把搭建在公司分配的电脑上的博客迁移到自己的电脑上来，毕竟公司的电脑不是自己的，所以，你们懂就好。哈哈！<br>","more":"</p>\n<h3 id=\"1-下载git安装\"><a href=\"#1-下载git安装\" class=\"headerlink\" title=\"1.下载git安装\"></a>1.下载git安装</h3><p><a href=\"https://git-scm.com/download/win\" target=\"_blank\" rel=\"noopener\">windows环境git安装包下载</a></p>\n<h3 id=\"2-下载Node-js安装\"><a href=\"#2-下载Node-js安装\" class=\"headerlink\" title=\"2. 下载Node.js安装\"></a>2. 下载Node.js安装</h3><p><a href=\"http://nodejs.org/\" target=\"_blank\" rel=\"noopener\">windows环境Node.js安装包下载</a></p>\n<h3 id=\"3-安装好git后，在本地目录hexo-没有的话新建一个-，在文件夹里面点鼠标右键，选择Git-Bash\"><a href=\"#3-安装好git后，在本地目录hexo-没有的话新建一个-，在文件夹里面点鼠标右键，选择Git-Bash\" class=\"headerlink\" title=\"3.安装好git后，在本地目录hexo(没有的话新建一个)，在文件夹里面点鼠标右键，选择Git Bash\"></a>3.安装好git后，在本地目录hexo(没有的话新建一个)，在文件夹里面点鼠标右键，选择<code>Git Bash</code></h3><p>输入命令：<br><code>npm install -g hexo-cli</code></p>\n<h3 id=\"4-验证是否安装成功，可以看下版本\"><a href=\"#4-验证是否安装成功，可以看下版本\" class=\"headerlink\" title=\"4.验证是否安装成功，可以看下版本\"></a>4.验证是否安装成功，可以看下版本</h3><p><code>hexo version</code></p>\n<h3 id=\"5-初始化环境\"><a href=\"#5-初始化环境\" class=\"headerlink\" title=\"5.初始化环境\"></a>5.初始化环境</h3><p>命令：<br><code>hexo init .</code></p>\n<h3 id=\"6-“-”-是当前目录，\"><a href=\"#6-“-”-是当前目录，\" class=\"headerlink\" title=\"6.“.” 是当前目录，\"></a>6.“.” 是当前目录，</h3><p>初始化后，目录下会自动生成一些文件</p>\n<h3 id=\"7-再用命令-可省略\"><a href=\"#7-再用命令-可省略\" class=\"headerlink\" title=\"7.再用命令(可省略)\"></a>7.再用命令(可省略)</h3><p><code>npm isntall</code> 安装一遍</p>\n<h3 id=\"8-启动服务（电脑可能会弹防火墙，确定即可）\"><a href=\"#8-启动服务（电脑可能会弹防火墙，确定即可）\" class=\"headerlink\" title=\"8.启动服务（电脑可能会弹防火墙，确定即可）\"></a>8.启动服务（电脑可能会弹防火墙，确定即可）</h3><p>命令:<br><code>hexo server</code></p>\n<h3 id=\"9-好了，现在可以访问了-：\"><a href=\"#9-好了，现在可以访问了-：\" class=\"headerlink\" title=\"9.好了，现在可以访问了 ：\"></a>9.好了，现在可以访问了 ：</h3><p><code>http://localhost:4000/</code> （命令结果提示是<code>http://0.0.0.0:4000/</code>）</p>\n<h3 id=\"10-打开hexo目录下的-config-yml文件，最后一行那块\"><a href=\"#10-打开hexo目录下的-config-yml文件，最后一行那块\" class=\"headerlink\" title=\"10.打开hexo目录下的_config.yml文件，最后一行那块\"></a>10.打开hexo目录下的_config.yml文件，最后一行那块</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">------------修改开始--------------------</span><br><span class=\"line\"># Deployment</span><br><span class=\"line\">## Docs: https://hexo.io/docs/deployment.html</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: git@github.com:shandianlala/shandianlala.github.io.git</span><br><span class=\"line\">  branch: master</span><br><span class=\"line\">  message: &apos;站点更新:&#123;&#123;now(&quot;YYYY-MM-DD HH/mm/ss&quot;)&#125;&#125;&apos;</span><br><span class=\"line\">------------修改结束--------------------</span><br></pre></td></tr></table></figure>\n<p>10-1、配置本机全局git环境(都是命令)<br><code>git config --global user.email &quot;you@example.com&quot;</code><br><code>git config --global user.name &quot;Your Name&quot;</code></p>\n<h3 id=\"11-生成SSH秘钥\"><a href=\"#11-生成SSH秘钥\" class=\"headerlink\" title=\"11.生成SSH秘钥\"></a>11.生成SSH秘钥</h3><p>命令：<br><code>ssh-keygen -t rsa -C example@gmail.com</code><br><code>-C</code>后面跟住你在github的用户名邮箱，这样公钥才会被github认可</p>\n<ul>\n<li><p>11-1.如果没有报错，提示（enter file in which to save the key），一路回车enter</p>\n</li>\n<li><p>11-2.搜索电脑里的文件：id_rsa.pub<br>用notpad++记事本打开,全选里面的内容，复制。</p>\n</li>\n<li><p>11-3.打开  <a href=\"https://github.com/settings/keys\" target=\"_blank\" rel=\"noopener\">https://github.com/settings/keys</a><br>点击 New SSH key 按钮，title输入框自定义，把刚才复制的内容粘贴到key输入框；</p>\n</li>\n<li><p>11-4.测试连接GitHub、coding<br>ssh -T git@github.com<br>ssh -T git@git.coding.net<br>提示输入yes/no,输入yes,回车。</p>\n</li>\n</ul>\n<h3 id=\"12-使用命令（即-hexo-generate-和-hexo-deploy）\"><a href=\"#12-使用命令（即-hexo-generate-和-hexo-deploy）\" class=\"headerlink\" title=\"12.使用命令（即 hexo generate 和 hexo deploy）\"></a>12.使用命令（即 hexo generate 和 hexo deploy）</h3><p>hexo g<br>hexo d  </p>\n<ul>\n<li>12-1.执行 hexo d 后报错，ERROR Deployer not found: git; 如果没有报错跳过进行下一步<br>解决：npm install hexo-deployer-git –save<br>然后再次执行<br><code>hexo d</code></li>\n</ul>\n<p>13.生成并发布到github，发布后再github会看到，打开地址访问 yourname.github.io  </p>\n<p>14.结束</p>"},{"title":"hexo博客更换电脑后配置教程","abbrlink":"99f8ffac-hexo-blog-change-computer-teach","date":"2017-12-27T13:25:57.000Z","_content":"更换电脑了，需要把hexo博客从一台电脑迁移到另外一台电脑上，该怎么在新电脑上配置 hexo 博客环境呢？\n<!-- more -->\n在网上也查了好些资料，但遇到好多坑，以下教程会清空掉原来的 commit 记录，因为我发现在迁移前我的 commit 有好多次的，迁移后打开 github 发现 commit 只有1次，但**博客内容不影响**。\n\n### 一、准备工作\n- 系统安装 Node.js 和 Git，如果你看到此文，说明这个步骤你是会的，这里就不多讲了，不会的请移步到[hexo博客安装教程](http://sdll.club/blogs/fac581d3-hexo-install/)。\n- 本文中的所有命令均在 Git Bash 中执行，而不是在 CMD 中。\n- 拷贝旧电脑中的整个 hexo 博客目录\n![博客目录](http://ozux0lqfa.bkt.clouddn.com/hexo%E5%8D%9A%E5%AE%A2%E6%A0%B9%E7%9B%AE%E5%BD%95.jpg)\n\n\n### 二、在新环境上（新电脑）部署新的 Hexo\nNode.js 和 Git 安装好后，接着开始以下步骤。\n- 在你想要部署 hexo 博客的文件夹里面空白处，点击鼠标右键，选择`git bash`，运行命令：\n```\nhexo init\n```\n命令执行完后，会生成一个新的 Hexo 目录。\n- 将拷贝的 packge.json 文件复制到新生成的 hexo 目录下，覆盖原来的 packge.json 文件。\n- 执行以下命令： \n```\nnpm install\n```\n安装相关依赖包。\n- 拷贝相关文件夹和文件到**新电脑的对应目录**中\n```\n需要拷贝以下文件夹：\n旧电脑的 hexo/source 文件夹里的所有文件到 新电脑的 hexo/source；\nhexo/scaffolds\nhexo/themes/ 你的主题文件夹 \n需要拷贝文件：\nhexo/_config.yml\npackge.json  \n```\n文件替换好了之后，开始下一步\n### 三、查看效果及部署。\n- 运行 `hexo g` 生成博客。\n- 运行 `hexo server` 查看博客。\n- 打开 `http://localhost:4000/`，没问题的话，执行下一步。\n- 执行 `hexo d` 推送到远程仓库部署。\n### 四、结束语\n至此，博客的整个迁移过程完美结束。我想说 `git`真的很重要！！！\n\n**参考**\nhttps://www.cnblogs.com/JinyaoLi/p/4672376.html","source":"_posts/hexo博客更换电脑后配置教程.md","raw":"---\ntitle: hexo博客更换电脑后配置教程\nabbrlink: 99f8ffac-hexo-blog-change-computer-teach\ndate: 2017-12-27 21:25:57\ntags: [配置,hexo博客配置]\n---\n更换电脑了，需要把hexo博客从一台电脑迁移到另外一台电脑上，该怎么在新电脑上配置 hexo 博客环境呢？\n<!-- more -->\n在网上也查了好些资料，但遇到好多坑，以下教程会清空掉原来的 commit 记录，因为我发现在迁移前我的 commit 有好多次的，迁移后打开 github 发现 commit 只有1次，但**博客内容不影响**。\n\n### 一、准备工作\n- 系统安装 Node.js 和 Git，如果你看到此文，说明这个步骤你是会的，这里就不多讲了，不会的请移步到[hexo博客安装教程](http://sdll.club/blogs/fac581d3-hexo-install/)。\n- 本文中的所有命令均在 Git Bash 中执行，而不是在 CMD 中。\n- 拷贝旧电脑中的整个 hexo 博客目录\n![博客目录](http://ozux0lqfa.bkt.clouddn.com/hexo%E5%8D%9A%E5%AE%A2%E6%A0%B9%E7%9B%AE%E5%BD%95.jpg)\n\n\n### 二、在新环境上（新电脑）部署新的 Hexo\nNode.js 和 Git 安装好后，接着开始以下步骤。\n- 在你想要部署 hexo 博客的文件夹里面空白处，点击鼠标右键，选择`git bash`，运行命令：\n```\nhexo init\n```\n命令执行完后，会生成一个新的 Hexo 目录。\n- 将拷贝的 packge.json 文件复制到新生成的 hexo 目录下，覆盖原来的 packge.json 文件。\n- 执行以下命令： \n```\nnpm install\n```\n安装相关依赖包。\n- 拷贝相关文件夹和文件到**新电脑的对应目录**中\n```\n需要拷贝以下文件夹：\n旧电脑的 hexo/source 文件夹里的所有文件到 新电脑的 hexo/source；\nhexo/scaffolds\nhexo/themes/ 你的主题文件夹 \n需要拷贝文件：\nhexo/_config.yml\npackge.json  \n```\n文件替换好了之后，开始下一步\n### 三、查看效果及部署。\n- 运行 `hexo g` 生成博客。\n- 运行 `hexo server` 查看博客。\n- 打开 `http://localhost:4000/`，没问题的话，执行下一步。\n- 执行 `hexo d` 推送到远程仓库部署。\n### 四、结束语\n至此，博客的整个迁移过程完美结束。我想说 `git`真的很重要！！！\n\n**参考**\nhttps://www.cnblogs.com/JinyaoLi/p/4672376.html","slug":"hexo博客更换电脑后配置教程","published":1,"updated":"2018-01-02T14:26:12.149Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2w200wc000omwd3wgmldymh","content":"<p>更换电脑了，需要把hexo博客从一台电脑迁移到另外一台电脑上，该怎么在新电脑上配置 hexo 博客环境呢？<br><a id=\"more\"></a><br>在网上也查了好些资料，但遇到好多坑，以下教程会清空掉原来的 commit 记录，因为我发现在迁移前我的 commit 有好多次的，迁移后打开 github 发现 commit 只有1次，但<strong>博客内容不影响</strong>。</p>\n<h3 id=\"一、准备工作\"><a href=\"#一、准备工作\" class=\"headerlink\" title=\"一、准备工作\"></a>一、准备工作</h3><ul>\n<li>系统安装 Node.js 和 Git，如果你看到此文，说明这个步骤你是会的，这里就不多讲了，不会的请移步到<a href=\"http://sdll.club/blogs/fac581d3-hexo-install/\">hexo博客安装教程</a>。</li>\n<li>本文中的所有命令均在 Git Bash 中执行，而不是在 CMD 中。</li>\n<li>拷贝旧电脑中的整个 hexo 博客目录<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/hexo%E5%8D%9A%E5%AE%A2%E6%A0%B9%E7%9B%AE%E5%BD%95.jpg\" alt=\"博客目录\"></li>\n</ul>\n<h3 id=\"二、在新环境上（新电脑）部署新的-Hexo\"><a href=\"#二、在新环境上（新电脑）部署新的-Hexo\" class=\"headerlink\" title=\"二、在新环境上（新电脑）部署新的 Hexo\"></a>二、在新环境上（新电脑）部署新的 Hexo</h3><p>Node.js 和 Git 安装好后，接着开始以下步骤。</p>\n<ul>\n<li>在你想要部署 hexo 博客的文件夹里面空白处，点击鼠标右键，选择<code>git bash</code>，运行命令：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>命令执行完后，会生成一个新的 Hexo 目录。</p>\n<ul>\n<li>将拷贝的 packge.json 文件复制到新生成的 hexo 目录下，覆盖原来的 packge.json 文件。</li>\n<li>执行以下命令： <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>安装相关依赖包。</p>\n<ul>\n<li>拷贝相关文件夹和文件到<strong>新电脑的对应目录</strong>中<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">需要拷贝以下文件夹：</span><br><span class=\"line\">旧电脑的 hexo/source 文件夹里的所有文件到 新电脑的 hexo/source；</span><br><span class=\"line\">hexo/scaffolds</span><br><span class=\"line\">hexo/themes/ 你的主题文件夹 </span><br><span class=\"line\">需要拷贝文件：</span><br><span class=\"line\">hexo/_config.yml</span><br><span class=\"line\">packge.json</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>文件替换好了之后，开始下一步</p>\n<h3 id=\"三、查看效果及部署。\"><a href=\"#三、查看效果及部署。\" class=\"headerlink\" title=\"三、查看效果及部署。\"></a>三、查看效果及部署。</h3><ul>\n<li>运行 <code>hexo g</code> 生成博客。</li>\n<li>运行 <code>hexo server</code> 查看博客。</li>\n<li>打开 <code>http://localhost:4000/</code>，没问题的话，执行下一步。</li>\n<li>执行 <code>hexo d</code> 推送到远程仓库部署。<h3 id=\"四、结束语\"><a href=\"#四、结束语\" class=\"headerlink\" title=\"四、结束语\"></a>四、结束语</h3>至此，博客的整个迁移过程完美结束。我想说 <code>git</code>真的很重要！！！</li>\n</ul>\n<p><strong>参考</strong><br><a href=\"https://www.cnblogs.com/JinyaoLi/p/4672376.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/JinyaoLi/p/4672376.html</a></p>\n","site":{"data":{}},"excerpt":"<p>更换电脑了，需要把hexo博客从一台电脑迁移到另外一台电脑上，该怎么在新电脑上配置 hexo 博客环境呢？<br>","more":"<br>在网上也查了好些资料，但遇到好多坑，以下教程会清空掉原来的 commit 记录，因为我发现在迁移前我的 commit 有好多次的，迁移后打开 github 发现 commit 只有1次，但<strong>博客内容不影响</strong>。</p>\n<h3 id=\"一、准备工作\"><a href=\"#一、准备工作\" class=\"headerlink\" title=\"一、准备工作\"></a>一、准备工作</h3><ul>\n<li>系统安装 Node.js 和 Git，如果你看到此文，说明这个步骤你是会的，这里就不多讲了，不会的请移步到<a href=\"http://sdll.club/blogs/fac581d3-hexo-install/\">hexo博客安装教程</a>。</li>\n<li>本文中的所有命令均在 Git Bash 中执行，而不是在 CMD 中。</li>\n<li>拷贝旧电脑中的整个 hexo 博客目录<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/hexo%E5%8D%9A%E5%AE%A2%E6%A0%B9%E7%9B%AE%E5%BD%95.jpg\" alt=\"博客目录\"></li>\n</ul>\n<h3 id=\"二、在新环境上（新电脑）部署新的-Hexo\"><a href=\"#二、在新环境上（新电脑）部署新的-Hexo\" class=\"headerlink\" title=\"二、在新环境上（新电脑）部署新的 Hexo\"></a>二、在新环境上（新电脑）部署新的 Hexo</h3><p>Node.js 和 Git 安装好后，接着开始以下步骤。</p>\n<ul>\n<li>在你想要部署 hexo 博客的文件夹里面空白处，点击鼠标右键，选择<code>git bash</code>，运行命令：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>命令执行完后，会生成一个新的 Hexo 目录。</p>\n<ul>\n<li>将拷贝的 packge.json 文件复制到新生成的 hexo 目录下，覆盖原来的 packge.json 文件。</li>\n<li>执行以下命令： <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>安装相关依赖包。</p>\n<ul>\n<li>拷贝相关文件夹和文件到<strong>新电脑的对应目录</strong>中<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">需要拷贝以下文件夹：</span><br><span class=\"line\">旧电脑的 hexo/source 文件夹里的所有文件到 新电脑的 hexo/source；</span><br><span class=\"line\">hexo/scaffolds</span><br><span class=\"line\">hexo/themes/ 你的主题文件夹 </span><br><span class=\"line\">需要拷贝文件：</span><br><span class=\"line\">hexo/_config.yml</span><br><span class=\"line\">packge.json</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>文件替换好了之后，开始下一步</p>\n<h3 id=\"三、查看效果及部署。\"><a href=\"#三、查看效果及部署。\" class=\"headerlink\" title=\"三、查看效果及部署。\"></a>三、查看效果及部署。</h3><ul>\n<li>运行 <code>hexo g</code> 生成博客。</li>\n<li>运行 <code>hexo server</code> 查看博客。</li>\n<li>打开 <code>http://localhost:4000/</code>，没问题的话，执行下一步。</li>\n<li>执行 <code>hexo d</code> 推送到远程仓库部署。<h3 id=\"四、结束语\"><a href=\"#四、结束语\" class=\"headerlink\" title=\"四、结束语\"></a>四、结束语</h3>至此，博客的整个迁移过程完美结束。我想说 <code>git</code>真的很重要！！！</li>\n</ul>\n<p><strong>参考</strong><br><a href=\"https://www.cnblogs.com/JinyaoLi/p/4672376.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/JinyaoLi/p/4672376.html</a></p>"},{"title":"hexo的yilia主题配置地址收藏","abbrlink":"37159b1b","date":"2017-11-25T02:56:44.000Z","_content":"\nhexo主题的相关配置，记录下来。\n<!-- more -->\n- [codingnet评论功能配置](https://www.hearain.club/2017/11/07/Hexo%E7%9A%84yilia%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96-%E5%A2%9E%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/)\n- [文章阅读量配置](https://www.hearain.club/2017/02/27/Hexo%E7%9A%84yilia%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96-%E5%A2%9E%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F/)\n- [Github page && Coding page配置](http://redredleaf.me/%E6%88%91%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%E7%AB%99%E5%88%9B%E5%BB%BA%E5%8E%86%E7%A8%8B%E4%B8%80.html#more)\n- [文章链接唯一化配置](http://muyunyun.cn/posts/f55182c5/#more)\n- [百度baidu_url_submit的url主动推送](http://blog.csdn.net/jameshadoop/article/details/53323083)","source":"_posts/hexo的yilia主题配置地址收藏.md","raw":"---\ntitle: hexo的yilia主题配置地址收藏\ntags:\n  - hexo博客配置\nabbrlink: 37159b1b\ndate: 2017-11-25 10:56:44\n---\n\nhexo主题的相关配置，记录下来。\n<!-- more -->\n- [codingnet评论功能配置](https://www.hearain.club/2017/11/07/Hexo%E7%9A%84yilia%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96-%E5%A2%9E%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/)\n- [文章阅读量配置](https://www.hearain.club/2017/02/27/Hexo%E7%9A%84yilia%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96-%E5%A2%9E%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F/)\n- [Github page && Coding page配置](http://redredleaf.me/%E6%88%91%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%E7%AB%99%E5%88%9B%E5%BB%BA%E5%8E%86%E7%A8%8B%E4%B8%80.html#more)\n- [文章链接唯一化配置](http://muyunyun.cn/posts/f55182c5/#more)\n- [百度baidu_url_submit的url主动推送](http://blog.csdn.net/jameshadoop/article/details/53323083)","slug":"hexo的yilia主题配置地址收藏","published":1,"updated":"2017-12-15T01:28:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2w200wi000qmwd3fly6yg02","content":"<p>hexo主题的相关配置，记录下来。<br><a id=\"more\"></a></p>\n<ul>\n<li><a href=\"https://www.hearain.club/2017/11/07/Hexo%E7%9A%84yilia%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96-%E5%A2%9E%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/\" target=\"_blank\" rel=\"noopener\">codingnet评论功能配置</a></li>\n<li><a href=\"https://www.hearain.club/2017/02/27/Hexo%E7%9A%84yilia%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96-%E5%A2%9E%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F/\" target=\"_blank\" rel=\"noopener\">文章阅读量配置</a></li>\n<li><a href=\"http://redredleaf.me/%E6%88%91%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%E7%AB%99%E5%88%9B%E5%BB%BA%E5%8E%86%E7%A8%8B%E4%B8%80.html#more\" target=\"_blank\" rel=\"noopener\">Github page &amp;&amp; Coding page配置</a></li>\n<li><a href=\"http://muyunyun.cn/posts/f55182c5/#more\" target=\"_blank\" rel=\"noopener\">文章链接唯一化配置</a></li>\n<li><a href=\"http://blog.csdn.net/jameshadoop/article/details/53323083\" target=\"_blank\" rel=\"noopener\">百度baidu_url_submit的url主动推送</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>hexo主题的相关配置，记录下来。<br>","more":"</p>\n<ul>\n<li><a href=\"https://www.hearain.club/2017/11/07/Hexo%E7%9A%84yilia%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96-%E5%A2%9E%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/\" target=\"_blank\" rel=\"noopener\">codingnet评论功能配置</a></li>\n<li><a href=\"https://www.hearain.club/2017/02/27/Hexo%E7%9A%84yilia%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96-%E5%A2%9E%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F/\" target=\"_blank\" rel=\"noopener\">文章阅读量配置</a></li>\n<li><a href=\"http://redredleaf.me/%E6%88%91%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%E7%AB%99%E5%88%9B%E5%BB%BA%E5%8E%86%E7%A8%8B%E4%B8%80.html#more\" target=\"_blank\" rel=\"noopener\">Github page &amp;&amp; Coding page配置</a></li>\n<li><a href=\"http://muyunyun.cn/posts/f55182c5/#more\" target=\"_blank\" rel=\"noopener\">文章链接唯一化配置</a></li>\n<li><a href=\"http://blog.csdn.net/jameshadoop/article/details/53323083\" target=\"_blank\" rel=\"noopener\">百度baidu_url_submit的url主动推送</a></li>\n</ul>"},{"title":"http请求接口数据乱码","abbrlink":"922954aa","date":"2017-11-30T14:07:29.000Z","_content":"\n今天因为项目里的一个天气接口挂掉了，然后更换新的接口，发现了一个较稳定、免费的接口；但在用java解析数据的时候，始终是乱码,很头疼，以此记录。\n<!-- more -->\n- **天气接口地址** \n    [天气接口地址](http://wthrcdn.etouch.cn/WeatherApi?city=%E7%8F%A0%E6%B5%B7)\n> 天气接口返回的数据\n![](http://ozux0lqfa.bkt.clouddn.com/%E4%B8%AD%E5%8D%8E%E4%B8%87%E5%B9%B4%E5%8E%86%E5%A4%A9%E6%B0%94%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E7%9A%84%E6%95%B0%E6%8D%AE.png)\n> 后台java代码\n```\nURL url = new URL(\"http://wthrcdn.etouch.cn/WeatherApi?city=\" + cityName); \nconnectionData = url.openConnection();\nconnectionData.setConnectTimeout(1000);\ntry { \n    br = new BufferedReader(\n        new InputStreamReader(connectionData.getInputStream(), \"UTF-8\")); \n    sb = new StringBuilder(); \n    String line = null; \n    while ((line = br.readLine()) != null) \n        sb.append(line); \n} catch (SocketTimeoutException e) { \n    System.out.println(\"连接超时\"); \n} catch (FileNotFoundException e) { \n    System.out.println(\"加载文件出错\"); \n} \nString datas = sb.toString();  \n```\n但`datas`里面的数据是乱码，很是头疼。\n- 仔细检查，发现问题\n![](http://ozux0lqfa.bkt.clouddn.com/%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B9%B1%E7%A0%81%E6%B3%A8%E6%84%8F%E7%9C%8B%E8%BF%94%E5%9B%9E%E7%9A%84%E4%BF%A1%E6%81%AF%E7%BC%96%E7%A0%81.png)\n每次请求返回的数据的 Content Encoding是**gzip**;故需要**GZIPInputStream**封装下`connectionData.getInputStream()`。\n调整如下：\n```\nbr = new BufferedReader(new InputStreamReader(\n            new GZIPInputStream(connectionData.getInputStream()), \"UTF-8\")); \n```\n再次调试表示问题解决了，在使用第三方提供的接口的时候要注意他们返回信息的编码格式，然后使用对应的编码格式解析,谨记！\n\n\n\n","source":"_posts/http请求接口数据乱码.md","raw":"---\ntitle: http请求接口数据乱码\ntags:\n  - 乱码\n  - JAVA\n  - HTTP\nabbrlink: 922954aa\ndate: 2017-11-30 22:07:29\n---\n\n今天因为项目里的一个天气接口挂掉了，然后更换新的接口，发现了一个较稳定、免费的接口；但在用java解析数据的时候，始终是乱码,很头疼，以此记录。\n<!-- more -->\n- **天气接口地址** \n    [天气接口地址](http://wthrcdn.etouch.cn/WeatherApi?city=%E7%8F%A0%E6%B5%B7)\n> 天气接口返回的数据\n![](http://ozux0lqfa.bkt.clouddn.com/%E4%B8%AD%E5%8D%8E%E4%B8%87%E5%B9%B4%E5%8E%86%E5%A4%A9%E6%B0%94%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E7%9A%84%E6%95%B0%E6%8D%AE.png)\n> 后台java代码\n```\nURL url = new URL(\"http://wthrcdn.etouch.cn/WeatherApi?city=\" + cityName); \nconnectionData = url.openConnection();\nconnectionData.setConnectTimeout(1000);\ntry { \n    br = new BufferedReader(\n        new InputStreamReader(connectionData.getInputStream(), \"UTF-8\")); \n    sb = new StringBuilder(); \n    String line = null; \n    while ((line = br.readLine()) != null) \n        sb.append(line); \n} catch (SocketTimeoutException e) { \n    System.out.println(\"连接超时\"); \n} catch (FileNotFoundException e) { \n    System.out.println(\"加载文件出错\"); \n} \nString datas = sb.toString();  \n```\n但`datas`里面的数据是乱码，很是头疼。\n- 仔细检查，发现问题\n![](http://ozux0lqfa.bkt.clouddn.com/%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B9%B1%E7%A0%81%E6%B3%A8%E6%84%8F%E7%9C%8B%E8%BF%94%E5%9B%9E%E7%9A%84%E4%BF%A1%E6%81%AF%E7%BC%96%E7%A0%81.png)\n每次请求返回的数据的 Content Encoding是**gzip**;故需要**GZIPInputStream**封装下`connectionData.getInputStream()`。\n调整如下：\n```\nbr = new BufferedReader(new InputStreamReader(\n            new GZIPInputStream(connectionData.getInputStream()), \"UTF-8\")); \n```\n再次调试表示问题解决了，在使用第三方提供的接口的时候要注意他们返回信息的编码格式，然后使用对应的编码格式解析,谨记！\n\n\n\n","slug":"http请求接口数据乱码","published":1,"updated":"2017-12-14T13:55:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2w200wo000rmwd3el17fc07","content":"<p>今天因为项目里的一个天气接口挂掉了，然后更换新的接口，发现了一个较稳定、免费的接口；但在用java解析数据的时候，始终是乱码,很头疼，以此记录。<br><a id=\"more\"></a></p>\n<ul>\n<li><strong>天气接口地址</strong><br>  <a href=\"http://wthrcdn.etouch.cn/WeatherApi?city=%E7%8F%A0%E6%B5%B7\" target=\"_blank\" rel=\"noopener\">天气接口地址</a><blockquote>\n<p>天气接口返回的数据<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/%E4%B8%AD%E5%8D%8E%E4%B8%87%E5%B9%B4%E5%8E%86%E5%A4%A9%E6%B0%94%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E7%9A%84%E6%95%B0%E6%8D%AE.png\" alt=\"\"><br>后台java代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">URL url = new URL(&quot;http://wthrcdn.etouch.cn/WeatherApi?city=&quot; + cityName); </span><br><span class=\"line\">connectionData = url.openConnection();</span><br><span class=\"line\">connectionData.setConnectTimeout(1000);</span><br><span class=\"line\">try &#123; </span><br><span class=\"line\">    br = new BufferedReader(</span><br><span class=\"line\">        new InputStreamReader(connectionData.getInputStream(), &quot;UTF-8&quot;)); </span><br><span class=\"line\">    sb = new StringBuilder(); </span><br><span class=\"line\">    String line = null; </span><br><span class=\"line\">    while ((line = br.readLine()) != null) </span><br><span class=\"line\">        sb.append(line); </span><br><span class=\"line\">&#125; catch (SocketTimeoutException e) &#123; </span><br><span class=\"line\">    System.out.println(&quot;连接超时&quot;); </span><br><span class=\"line\">&#125; catch (FileNotFoundException e) &#123; </span><br><span class=\"line\">    System.out.println(&quot;加载文件出错&quot;); </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">String datas = sb.toString();</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n<p>但<code>datas</code>里面的数据是乱码，很是头疼。</p>\n<ul>\n<li>仔细检查，发现问题<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B9%B1%E7%A0%81%E6%B3%A8%E6%84%8F%E7%9C%8B%E8%BF%94%E5%9B%9E%E7%9A%84%E4%BF%A1%E6%81%AF%E7%BC%96%E7%A0%81.png\" alt=\"\"><br>每次请求返回的数据的 Content Encoding是<strong>gzip</strong>;故需要<strong>GZIPInputStream</strong>封装下<code>connectionData.getInputStream()</code>。<br>调整如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">br = new BufferedReader(new InputStreamReader(</span><br><span class=\"line\">            new GZIPInputStream(connectionData.getInputStream()), &quot;UTF-8&quot;));</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>再次调试表示问题解决了，在使用第三方提供的接口的时候要注意他们返回信息的编码格式，然后使用对应的编码格式解析,谨记！</p>\n","site":{"data":{}},"excerpt":"<p>今天因为项目里的一个天气接口挂掉了，然后更换新的接口，发现了一个较稳定、免费的接口；但在用java解析数据的时候，始终是乱码,很头疼，以此记录。<br>","more":"</p>\n<ul>\n<li><strong>天气接口地址</strong><br>  <a href=\"http://wthrcdn.etouch.cn/WeatherApi?city=%E7%8F%A0%E6%B5%B7\" target=\"_blank\" rel=\"noopener\">天气接口地址</a><blockquote>\n<p>天气接口返回的数据<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/%E4%B8%AD%E5%8D%8E%E4%B8%87%E5%B9%B4%E5%8E%86%E5%A4%A9%E6%B0%94%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E7%9A%84%E6%95%B0%E6%8D%AE.png\" alt=\"\"><br>后台java代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">URL url = new URL(&quot;http://wthrcdn.etouch.cn/WeatherApi?city=&quot; + cityName); </span><br><span class=\"line\">connectionData = url.openConnection();</span><br><span class=\"line\">connectionData.setConnectTimeout(1000);</span><br><span class=\"line\">try &#123; </span><br><span class=\"line\">    br = new BufferedReader(</span><br><span class=\"line\">        new InputStreamReader(connectionData.getInputStream(), &quot;UTF-8&quot;)); </span><br><span class=\"line\">    sb = new StringBuilder(); </span><br><span class=\"line\">    String line = null; </span><br><span class=\"line\">    while ((line = br.readLine()) != null) </span><br><span class=\"line\">        sb.append(line); </span><br><span class=\"line\">&#125; catch (SocketTimeoutException e) &#123; </span><br><span class=\"line\">    System.out.println(&quot;连接超时&quot;); </span><br><span class=\"line\">&#125; catch (FileNotFoundException e) &#123; </span><br><span class=\"line\">    System.out.println(&quot;加载文件出错&quot;); </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">String datas = sb.toString();</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n<p>但<code>datas</code>里面的数据是乱码，很是头疼。</p>\n<ul>\n<li>仔细检查，发现问题<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B9%B1%E7%A0%81%E6%B3%A8%E6%84%8F%E7%9C%8B%E8%BF%94%E5%9B%9E%E7%9A%84%E4%BF%A1%E6%81%AF%E7%BC%96%E7%A0%81.png\" alt=\"\"><br>每次请求返回的数据的 Content Encoding是<strong>gzip</strong>;故需要<strong>GZIPInputStream</strong>封装下<code>connectionData.getInputStream()</code>。<br>调整如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">br = new BufferedReader(new InputStreamReader(</span><br><span class=\"line\">            new GZIPInputStream(connectionData.getInputStream()), &quot;UTF-8&quot;));</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>再次调试表示问题解决了，在使用第三方提供的接口的时候要注意他们返回信息的编码格式，然后使用对应的编码格式解析,谨记！</p>"},{"title":"java web项目中设置session会话超时的时间","abbrlink":"e95b6d7d","date":"2017-12-18T12:12:39.000Z","_content":"一般系统登录后，都会设置一个当前session失效的时间，以确保在用户长时间不与服务器交互，自动退出登录，销毁session，下面我罗列三种具体设置的方法：\n<!-- more -->\n### 一、在web容器中设置session失效的时间（以tomcat为例）\n在`apache-tomcat-8.0.72\\conf\\web.xml`中设置，以下是`apache-tomcat-8.0.72`中默认配置：\n```\n<session-config>\n    <session-timeout>30</session-timeout>\n</session-config>\n```\ntomcat默认session超时时间为30分钟，可以根据需要修改，负数或0为不限制session失效时间。\n### 二、在项目工程的web.xml中设置session失效的时间\n```\n<session-config>\n    <session-timeout>1</session-timeout>\n</session-config>\n```\n这里配置1分钟后session失效。\n### 三、通过java代码设置session失效的时间\n```\nrequest.getSession().setMaxInactiveInterval(1*60);//以秒为单位，即在没有活动1分钟后，session将失效\n```\n**注意：**三种方式优先等级：`1 < 2 < 3`\n\n### 四、监听session失效\n这里就需要用到监听器了，当session因为某种原因失效后，监听器就可以监听到，然后执行监听器中定义好的程序就可以了；监听器接口为：`HttpSessionListener`，有`sessionCreated()`和`sessionDestroyed()`两个方法，自己可以新建一个类实现`HttpSessionListener`接口，然后分别重写这两个方法：\n- `sessionCreated()`方法：\n在session创建完毕后执行的；\n- `sessionDestroyed()`方法：\n在session失效时执行的；\n#### 示例代码\n```\npackage com.sdll.blog.utils;\nimport javax.servlet.http.HttpSessionEvent;\nimport javax.servlet.http.HttpSessionListener;\n\n/**\n * session监听器类，监听sesssion的创建和失效\n * @author chengxw\n */\npublic class UserOnlineListener implements HttpSessionListener{\n\n    @Override\n    public void sessionCreated(HttpSessionEvent se) {\n\n        System.out.println(\"session is sessionCreated ======================session创建完毕\");\n    }\n\n    @Override\n    public void sessionDestroyed(HttpSessionEvent se) {\n\n        System.out.println(\"session is sessionDestroyed =====================session销毁完毕\");\n    }\n}\n```\n上面的监听器类写好后，在项目工程的`web.xml`添加`listener`进行声明，如下：\n```\n<listener>\n    <listener-class>com.sdll.blog.utils.UserOnlineListener</listener-class>\n</listener>\n```\n\n**参考：**\nhttps://www.cnblogs.com/diewufeixian/p/4221747.html","source":"_posts/java-web项目中设置session会话超时的时间.md","raw":"---\ntitle: java web项目中设置session会话超时的时间\nabbrlink: e95b6d7d\ndate: 2017-12-18 20:12:39\ntags: [JAVA]\n---\n一般系统登录后，都会设置一个当前session失效的时间，以确保在用户长时间不与服务器交互，自动退出登录，销毁session，下面我罗列三种具体设置的方法：\n<!-- more -->\n### 一、在web容器中设置session失效的时间（以tomcat为例）\n在`apache-tomcat-8.0.72\\conf\\web.xml`中设置，以下是`apache-tomcat-8.0.72`中默认配置：\n```\n<session-config>\n    <session-timeout>30</session-timeout>\n</session-config>\n```\ntomcat默认session超时时间为30分钟，可以根据需要修改，负数或0为不限制session失效时间。\n### 二、在项目工程的web.xml中设置session失效的时间\n```\n<session-config>\n    <session-timeout>1</session-timeout>\n</session-config>\n```\n这里配置1分钟后session失效。\n### 三、通过java代码设置session失效的时间\n```\nrequest.getSession().setMaxInactiveInterval(1*60);//以秒为单位，即在没有活动1分钟后，session将失效\n```\n**注意：**三种方式优先等级：`1 < 2 < 3`\n\n### 四、监听session失效\n这里就需要用到监听器了，当session因为某种原因失效后，监听器就可以监听到，然后执行监听器中定义好的程序就可以了；监听器接口为：`HttpSessionListener`，有`sessionCreated()`和`sessionDestroyed()`两个方法，自己可以新建一个类实现`HttpSessionListener`接口，然后分别重写这两个方法：\n- `sessionCreated()`方法：\n在session创建完毕后执行的；\n- `sessionDestroyed()`方法：\n在session失效时执行的；\n#### 示例代码\n```\npackage com.sdll.blog.utils;\nimport javax.servlet.http.HttpSessionEvent;\nimport javax.servlet.http.HttpSessionListener;\n\n/**\n * session监听器类，监听sesssion的创建和失效\n * @author chengxw\n */\npublic class UserOnlineListener implements HttpSessionListener{\n\n    @Override\n    public void sessionCreated(HttpSessionEvent se) {\n\n        System.out.println(\"session is sessionCreated ======================session创建完毕\");\n    }\n\n    @Override\n    public void sessionDestroyed(HttpSessionEvent se) {\n\n        System.out.println(\"session is sessionDestroyed =====================session销毁完毕\");\n    }\n}\n```\n上面的监听器类写好后，在项目工程的`web.xml`添加`listener`进行声明，如下：\n```\n<listener>\n    <listener-class>com.sdll.blog.utils.UserOnlineListener</listener-class>\n</listener>\n```\n\n**参考：**\nhttps://www.cnblogs.com/diewufeixian/p/4221747.html","slug":"java-web项目中设置session会话超时的时间","published":1,"updated":"2017-12-19T00:44:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2w200wt000tmwd3kw0b6mll","content":"<p>一般系统登录后，都会设置一个当前session失效的时间，以确保在用户长时间不与服务器交互，自动退出登录，销毁session，下面我罗列三种具体设置的方法：<br><a id=\"more\"></a></p>\n<h3 id=\"一、在web容器中设置session失效的时间（以tomcat为例）\"><a href=\"#一、在web容器中设置session失效的时间（以tomcat为例）\" class=\"headerlink\" title=\"一、在web容器中设置session失效的时间（以tomcat为例）\"></a>一、在web容器中设置session失效的时间（以tomcat为例）</h3><p>在<code>apache-tomcat-8.0.72\\conf\\web.xml</code>中设置，以下是<code>apache-tomcat-8.0.72</code>中默认配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;session-config&gt;</span><br><span class=\"line\">    &lt;session-timeout&gt;30&lt;/session-timeout&gt;</span><br><span class=\"line\">&lt;/session-config&gt;</span><br></pre></td></tr></table></figure></p>\n<p>tomcat默认session超时时间为30分钟，可以根据需要修改，负数或0为不限制session失效时间。</p>\n<h3 id=\"二、在项目工程的web-xml中设置session失效的时间\"><a href=\"#二、在项目工程的web-xml中设置session失效的时间\" class=\"headerlink\" title=\"二、在项目工程的web.xml中设置session失效的时间\"></a>二、在项目工程的web.xml中设置session失效的时间</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;session-config&gt;</span><br><span class=\"line\">    &lt;session-timeout&gt;1&lt;/session-timeout&gt;</span><br><span class=\"line\">&lt;/session-config&gt;</span><br></pre></td></tr></table></figure>\n<p>这里配置1分钟后session失效。</p>\n<h3 id=\"三、通过java代码设置session失效的时间\"><a href=\"#三、通过java代码设置session失效的时间\" class=\"headerlink\" title=\"三、通过java代码设置session失效的时间\"></a>三、通过java代码设置session失效的时间</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.getSession().setMaxInactiveInterval(1*60);//以秒为单位，即在没有活动1分钟后，session将失效</span><br></pre></td></tr></table></figure>\n<p><strong>注意：</strong>三种方式优先等级：<code>1 &lt; 2 &lt; 3</code></p>\n<h3 id=\"四、监听session失效\"><a href=\"#四、监听session失效\" class=\"headerlink\" title=\"四、监听session失效\"></a>四、监听session失效</h3><p>这里就需要用到监听器了，当session因为某种原因失效后，监听器就可以监听到，然后执行监听器中定义好的程序就可以了；监听器接口为：<code>HttpSessionListener</code>，有<code>sessionCreated()</code>和<code>sessionDestroyed()</code>两个方法，自己可以新建一个类实现<code>HttpSessionListener</code>接口，然后分别重写这两个方法：</p>\n<ul>\n<li><code>sessionCreated()</code>方法：<br>在session创建完毕后执行的；</li>\n<li><code>sessionDestroyed()</code>方法：<br>在session失效时执行的；<h4 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.sdll.blog.utils;</span><br><span class=\"line\">import javax.servlet.http.HttpSessionEvent;</span><br><span class=\"line\">import javax.servlet.http.HttpSessionListener;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * session监听器类，监听sesssion的创建和失效</span><br><span class=\"line\"> * @author chengxw</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class UserOnlineListener implements HttpSessionListener&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void sessionCreated(HttpSessionEvent se) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;session is sessionCreated ======================session创建完毕&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void sessionDestroyed(HttpSessionEvent se) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;session is sessionDestroyed =====================session销毁完毕&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上面的监听器类写好后，在项目工程的<code>web.xml</code>添加<code>listener</code>进行声明，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;listener&gt;</span><br><span class=\"line\">    &lt;listener-class&gt;com.sdll.blog.utils.UserOnlineListener&lt;/listener-class&gt;</span><br><span class=\"line\">&lt;/listener&gt;</span><br></pre></td></tr></table></figure></p>\n<p><strong>参考：</strong><br><a href=\"https://www.cnblogs.com/diewufeixian/p/4221747.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/diewufeixian/p/4221747.html</a></p>\n","site":{"data":{}},"excerpt":"<p>一般系统登录后，都会设置一个当前session失效的时间，以确保在用户长时间不与服务器交互，自动退出登录，销毁session，下面我罗列三种具体设置的方法：<br>","more":"</p>\n<h3 id=\"一、在web容器中设置session失效的时间（以tomcat为例）\"><a href=\"#一、在web容器中设置session失效的时间（以tomcat为例）\" class=\"headerlink\" title=\"一、在web容器中设置session失效的时间（以tomcat为例）\"></a>一、在web容器中设置session失效的时间（以tomcat为例）</h3><p>在<code>apache-tomcat-8.0.72\\conf\\web.xml</code>中设置，以下是<code>apache-tomcat-8.0.72</code>中默认配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;session-config&gt;</span><br><span class=\"line\">    &lt;session-timeout&gt;30&lt;/session-timeout&gt;</span><br><span class=\"line\">&lt;/session-config&gt;</span><br></pre></td></tr></table></figure></p>\n<p>tomcat默认session超时时间为30分钟，可以根据需要修改，负数或0为不限制session失效时间。</p>\n<h3 id=\"二、在项目工程的web-xml中设置session失效的时间\"><a href=\"#二、在项目工程的web-xml中设置session失效的时间\" class=\"headerlink\" title=\"二、在项目工程的web.xml中设置session失效的时间\"></a>二、在项目工程的web.xml中设置session失效的时间</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;session-config&gt;</span><br><span class=\"line\">    &lt;session-timeout&gt;1&lt;/session-timeout&gt;</span><br><span class=\"line\">&lt;/session-config&gt;</span><br></pre></td></tr></table></figure>\n<p>这里配置1分钟后session失效。</p>\n<h3 id=\"三、通过java代码设置session失效的时间\"><a href=\"#三、通过java代码设置session失效的时间\" class=\"headerlink\" title=\"三、通过java代码设置session失效的时间\"></a>三、通过java代码设置session失效的时间</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.getSession().setMaxInactiveInterval(1*60);//以秒为单位，即在没有活动1分钟后，session将失效</span><br></pre></td></tr></table></figure>\n<p><strong>注意：</strong>三种方式优先等级：<code>1 &lt; 2 &lt; 3</code></p>\n<h3 id=\"四、监听session失效\"><a href=\"#四、监听session失效\" class=\"headerlink\" title=\"四、监听session失效\"></a>四、监听session失效</h3><p>这里就需要用到监听器了，当session因为某种原因失效后，监听器就可以监听到，然后执行监听器中定义好的程序就可以了；监听器接口为：<code>HttpSessionListener</code>，有<code>sessionCreated()</code>和<code>sessionDestroyed()</code>两个方法，自己可以新建一个类实现<code>HttpSessionListener</code>接口，然后分别重写这两个方法：</p>\n<ul>\n<li><code>sessionCreated()</code>方法：<br>在session创建完毕后执行的；</li>\n<li><code>sessionDestroyed()</code>方法：<br>在session失效时执行的；<h4 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.sdll.blog.utils;</span><br><span class=\"line\">import javax.servlet.http.HttpSessionEvent;</span><br><span class=\"line\">import javax.servlet.http.HttpSessionListener;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * session监听器类，监听sesssion的创建和失效</span><br><span class=\"line\"> * @author chengxw</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class UserOnlineListener implements HttpSessionListener&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void sessionCreated(HttpSessionEvent se) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;session is sessionCreated ======================session创建完毕&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void sessionDestroyed(HttpSessionEvent se) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;session is sessionDestroyed =====================session销毁完毕&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上面的监听器类写好后，在项目工程的<code>web.xml</code>添加<code>listener</code>进行声明，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;listener&gt;</span><br><span class=\"line\">    &lt;listener-class&gt;com.sdll.blog.utils.UserOnlineListener&lt;/listener-class&gt;</span><br><span class=\"line\">&lt;/listener&gt;</span><br></pre></td></tr></table></figure></p>\n<p><strong>参考：</strong><br><a href=\"https://www.cnblogs.com/diewufeixian/p/4221747.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/diewufeixian/p/4221747.html</a></p>"},{"title":"mybatis官方文档","abbrlink":"21b75e70-mybatis-official-document","date":"2018-04-12T13:34:17.000Z","_content":"### 一、由来\n项目中也一直用到`mybatis`,但自我感觉还是没有学到精髓，故准备花些时间撸一遍它的官方文档,加深印象，同时撸一遍源码，了解它的工作原理。\n<!-- more -->\n### 二、文档解读\nMyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。\n- 未完待续","source":"_posts/mybatis官方文档.md","raw":"---\ntitle: mybatis官方文档\ntags:\n  - JAVA\n  - 框架\n  - mybatis\nabbrlink: 21b75e70-mybatis-official-document\ndate: 2018-04-12 21:34:17\n---\n### 一、由来\n项目中也一直用到`mybatis`,但自我感觉还是没有学到精髓，故准备花些时间撸一遍它的官方文档,加深印象，同时撸一遍源码，了解它的工作原理。\n<!-- more -->\n### 二、文档解读\nMyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。\n- 未完待续","slug":"mybatis官方文档","published":1,"updated":"2018-05-23T01:37:42.097Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2w200wy000umwd300xub7cy","content":"<h3 id=\"一、由来\"><a href=\"#一、由来\" class=\"headerlink\" title=\"一、由来\"></a>一、由来</h3><p>项目中也一直用到<code>mybatis</code>,但自我感觉还是没有学到精髓，故准备花些时间撸一遍它的官方文档,加深印象，同时撸一遍源码，了解它的工作原理。<br><a id=\"more\"></a></p>\n<h3 id=\"二、文档解读\"><a href=\"#二、文档解读\" class=\"headerlink\" title=\"二、文档解读\"></a>二、文档解读</h3><p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p>\n<ul>\n<li>未完待续</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"一、由来\"><a href=\"#一、由来\" class=\"headerlink\" title=\"一、由来\"></a>一、由来</h3><p>项目中也一直用到<code>mybatis</code>,但自我感觉还是没有学到精髓，故准备花些时间撸一遍它的官方文档,加深印象，同时撸一遍源码，了解它的工作原理。<br>","more":"</p>\n<h3 id=\"二、文档解读\"><a href=\"#二、文档解读\" class=\"headerlink\" title=\"二、文档解读\"></a>二、文档解读</h3><p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p>\n<ul>\n<li>未完待续</li>\n</ul>"},{"title":"shiro验证框架","abbrlink":"61afe343-shiro-authority-frame","date":"2018-03-23T01:20:17.000Z","_content":"Apache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码学和会话管理。使用Shiro的易于理解的API,您可以快速、轻松地获得任何应用程序,从最小的移动应用程序到最大的网络和企业应用程序。\n<!-- more -->\n### 配置介绍\n- shiro 添加 pom.xml 相关依赖\n```\n<!-- Shiro SECURITY begin -->\n    <dependency>\n        <groupId>org.apache.shiro</groupId>\n        <artifactId>shiro-core</artifactId>\n        <version>${shiro.version}</version>\n    </dependency>\n    <dependency>\n        <groupId>org.apache.shiro</groupId>\n        <artifactId>shiro-spring</artifactId>\n        <version>${shiro.version}</version>\n    </dependency>\n    <dependency>\n        <groupId>org.apache.shiro</groupId>\n        <artifactId>shiro-web</artifactId>\n        <version>${shiro.version}</version>\n    </dependency>\n    <dependency>\n        <groupId>org.apache.shiro</groupId>\n        <artifactId>shiro-ehcache</artifactId>\n        <version>${shiro.version}</version>\n    </dependency>\n    <dependency>\n        <groupId>org.apache.shiro</groupId>\n        <artifactId>shiro-quartz</artifactId>\n        <version>${shiro.version}</version>\n    </dependency>\n<!-- Shiro SECURITY end -->\n```\n- web.xml配置shrio\n```\n<!-- Shiro安全管理   begin-->\n    <filter>\n        <filter-name>shiroFilter</filter-name>\n        <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>\n        <init-param>\n            <param-name>targetFilterLifecycle</param-name>\n            <param-value>true</param-value>\n        </init-param>\n    </filter>\n    <filter-mapping>\n        <filter-name>shiroFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n    <!-- Shiro安全管理    end -->\n```\n在web.xml中加载spring配置文件applicationContext.xml,在spring配置文件中导入加载shiro.xml，如下所示。\n```\n<import resource=\"../shiro/shiro.xml\"/>\n```\n- shiro.xml 配置文件\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:jee=\"http://www.springframework.org/schema/jee\"\n    xmlns:tx=\"http://www.springframework.org/schema/tx\"\n    xmlns:util=\"http://www.springframework.org/schema/util\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.0.xsd\"\n    default-lazy-init=\"true\">\n    <description>Shiro Configuration</description>\n\n    <bean id=\"customRealm\" class=\"club.sdll.shiro.CustomRealm\">\n        <property name=\"credentialsMatcher\" ref=\"customCredentialsMatcher\" />\n    </bean>\n\n    <bean id=\"customCredentialsMatcher\" class=\"club.sdll.shiro.CustomCredentialsMatcher\">\n    </bean>\n        \n    <bean id=\"simpleCookie\" class=\"org.apache.shiro.web.servlet.SimpleCookie\">\n       <constructor-arg name=\"name\" value=\"rememberMe\"></constructor-arg>\n       <property name=\"maxAge\" value=\"2592000\"/>\n    </bean>\n    \n    <bean id=\"cookieRememberMeManager\" class=\"org.apache.shiro.web.mgt.CookieRememberMeManager\">\n       <property name=\"cookie\" ref=\"simpleCookie\"></property>\n    </bean>\n\n    <bean id=\"securityWebManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\">\n        <property name=\"realm\" ref=\"customRealm\" />\n        <property name=\"cacheManager\" ref=\"cacheManager\" />\n        <property name=\"rememberMeManager\" ref=\"cookieRememberMeManager\"></property>\n    </bean>\n    \n    <bean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\">\n        <property name=\"securityManager\" ref=\"securityWebManager\" />\n        <property name=\"loginUrl\" value=\"/index.jsp?toTop=true\" />\n        <property name=\"successUrl\" value=\"/index.jsp\" />\n        <property name=\"unauthorizedUrl\" value=\"/index.jsp\" />\n\n        <property name=\"filters\">\n            <util:map>\n                <entry key=\"authc\">\n                    <bean\n                        class=\"org.apache.shiro.web.filter.authc.FormAuthenticationFilter\" />\n                </entry>\n            </util:map>\n        </property>\n        <property name=\"filterChainDefinitions\"><!--authc  -->\n            <value>\n                /resources/** = anon\n                /common/** = anon\n                /plugins/framework/** = anon\n                /plugins/login/** = anon\n                /plugins/sysmgr/**  = authc\n                /plugins/comm/**  = authc\n                /plugins/business/**  = authc\n                /sysmgr/** = authc\n                /business/** = authc\n                /comm/** = authc\n                /main/** = authc  <!-- 用户必须登录才能访问 -->\n                /login/** = anon <!-- 任何人都可以访问 -->\n                /kaptcha/** = anon\n        <!--    /authc/admin =roles[admin]  需要用户有用admin权限才能访问 -->\n            </value>\n        </property>\n    </bean>\n    \n    <bean id=\"cacheManager\" class=\"org.apache.shiro.cache.MemoryConstrainedCacheManager\" />\n    <bean id=\"lifecycleBeanPostProcessor\" class=\"org.apache.shiro.spring.LifecycleBeanPostProcessor\" />\n</beans>\n```\n- 自定义realm 类继承 `AuthorizingRealm`\n```\n/**\n * \n */\npackage club.sdll.blog.sysmgr.shiro;\n\nimport org.apache.shiro.authc.AuthenticationException;\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.SimpleAuthenticationInfo;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.authz.SimpleAuthorizationInfo;\nimport org.apache.shiro.realm.AuthorizingRealm;\nimport org.apache.shiro.subject.PrincipalCollection;\nimport org.springframework.beans.factory.annotation.Autowired;\n\nimport com.eshore.icthala.sysmgr.pojo.bean.authority.SysUser;\nimport com.eshore.icthala.sysmgr.service.authority.ISysUserService;\n\n/**\n * \n * Shiro领域\n */\npublic class CustomRealm extends AuthorizingRealm {\n    \n    @Autowired ISysUserService sysUserService;\n\n    /**\n     * 授权验证\n     */\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n         //Object object = this.getAvailablePrincipal(principals);\n         SimpleAuthorizationInfo principal = new SimpleAuthorizationInfo(); \n         //principal.setRoles(new HashSet<String>());\n         //principal.setStringPermissions(new HashSet<String>(){});\n        return principal;\n    }\n\n    /**\n     * 获取登录验证信息\n     */\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n        AuthenticationInfo athcInfo = null;\n        UsernamePasswordToken athcToken = (UsernamePasswordToken) token;\n        try {\n            SysUser sysUser = sysUserService.getUserByLoginName(athcToken.getUsername());\n            if(null!=sysUser){  //验证是否存在用户\n                athcInfo =  new SimpleAuthenticationInfo(sysUser.getLoginName(),sysUser.getLoginPwd(), getName());\n            }\n            return athcInfo;\n        } catch (Exception ex) {\n            throw new AuthenticationException(ex);\n        }\n    }\n\n}\n\n```\n- shiro证书匹配\n```\n/**\n * \n */\npackage club.sdll.blog.sysmgr.shiro;\n\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.authc.credential.SimpleCredentialsMatcher;\n\nimport com.eshore.icthala.common.utils.crypt.MD5Util;\n\n/**\n * @author chengxiwang\n * 2017年09月13日 下午2:56:55\n * shiro证书匹配\n */\npublic class CustomCredentialsMatcher extends SimpleCredentialsMatcher {\n    /**\n     * 登录密码验证\n     */\n    @Override\n    public boolean doCredentialsMatch(AuthenticationToken token,AuthenticationInfo info) {\n        UsernamePasswordToken authcToken = (UsernamePasswordToken) token;\n        String passwordFromAthcToken = String.valueOf(authcToken.getPassword()); //\n        Object accountCredentials = null;\n        try {\n            accountCredentials = MD5Util.crypt(getCredentials(info).toString());\n        } catch (Exception e) {\n            return Boolean.FALSE.booleanValue();\n        }\n        return equals(passwordFromAthcToken, accountCredentials);\n    }\n\n}\n```\n\n### 二、使用\n```\n/**\n * \n * 登录操作\n * @param page\n * @return\n * @throws ControllerException\n * @throws UtilException\n */\n@RequestMapping(value = \"loginOn\", method = { RequestMethod.GET})\n    public ModelAndView loginOn(LoginForm loginForm,RedirectAttributes attrs) throws ControllerException{\n         try {\n             //验证验证码\n            if(!checkKaptcha(loginForm)){\n                attrs.addFlashAttribute(\"message\", \"验证码错误!\");\n                return toLogin(attrs);\n            }\n            //验证用户名和密码\n            if(!checkUser(loginForm)){\n                attrs.addFlashAttribute(\"message\", \"密码错误!\");\n                return toLogin(attrs); \n            }else{\n                formSession(loginForm);\n            }\n            return toHome();\n        }catch (ControllerException ex){\n            attrs.addFlashAttribute(\"message\", \"登录过程发生异常!请联系系统管理员\");\n            return toLogin(attrs);\n        }\n   }\n   \n   \n   /**\n     * \n     * 用户名密码验证\n     * @param loginForm\n     * @return\n     */\n    private Boolean checkUser(LoginForm loginForm){\n        Boolean checkResult = Boolean.FALSE;\n        try{\n            UsernamePasswordToken token = new UsernamePasswordToken(loginForm.getUserName(),loginForm.getPassword());\n            Subject currentUser = SecurityUtils.getSubject();\n            currentUser.login(token);\n            checkResult = currentUser.isAuthenticated();\n            token.setRememberMe(false);\n        }catch(Exception ex){\n            checkResult = Boolean.FALSE;\n        }\n        return checkResult;\n    }\n```\n\n\n\n**引用参考：**\nhttps://www.cnblogs.com/learnhow/p/5694876.html","source":"_posts/shiro验证框架.md","raw":"---\ntitle: shiro验证框架\ntags:\n  - JAVA\n  - 框架\n  - shiro\nabbrlink: 61afe343-shiro-authority-frame\ndate: 2018-03-23 09:20:17\n---\nApache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码学和会话管理。使用Shiro的易于理解的API,您可以快速、轻松地获得任何应用程序,从最小的移动应用程序到最大的网络和企业应用程序。\n<!-- more -->\n### 配置介绍\n- shiro 添加 pom.xml 相关依赖\n```\n<!-- Shiro SECURITY begin -->\n    <dependency>\n        <groupId>org.apache.shiro</groupId>\n        <artifactId>shiro-core</artifactId>\n        <version>${shiro.version}</version>\n    </dependency>\n    <dependency>\n        <groupId>org.apache.shiro</groupId>\n        <artifactId>shiro-spring</artifactId>\n        <version>${shiro.version}</version>\n    </dependency>\n    <dependency>\n        <groupId>org.apache.shiro</groupId>\n        <artifactId>shiro-web</artifactId>\n        <version>${shiro.version}</version>\n    </dependency>\n    <dependency>\n        <groupId>org.apache.shiro</groupId>\n        <artifactId>shiro-ehcache</artifactId>\n        <version>${shiro.version}</version>\n    </dependency>\n    <dependency>\n        <groupId>org.apache.shiro</groupId>\n        <artifactId>shiro-quartz</artifactId>\n        <version>${shiro.version}</version>\n    </dependency>\n<!-- Shiro SECURITY end -->\n```\n- web.xml配置shrio\n```\n<!-- Shiro安全管理   begin-->\n    <filter>\n        <filter-name>shiroFilter</filter-name>\n        <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>\n        <init-param>\n            <param-name>targetFilterLifecycle</param-name>\n            <param-value>true</param-value>\n        </init-param>\n    </filter>\n    <filter-mapping>\n        <filter-name>shiroFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n    <!-- Shiro安全管理    end -->\n```\n在web.xml中加载spring配置文件applicationContext.xml,在spring配置文件中导入加载shiro.xml，如下所示。\n```\n<import resource=\"../shiro/shiro.xml\"/>\n```\n- shiro.xml 配置文件\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:jee=\"http://www.springframework.org/schema/jee\"\n    xmlns:tx=\"http://www.springframework.org/schema/tx\"\n    xmlns:util=\"http://www.springframework.org/schema/util\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.0.xsd\"\n    default-lazy-init=\"true\">\n    <description>Shiro Configuration</description>\n\n    <bean id=\"customRealm\" class=\"club.sdll.shiro.CustomRealm\">\n        <property name=\"credentialsMatcher\" ref=\"customCredentialsMatcher\" />\n    </bean>\n\n    <bean id=\"customCredentialsMatcher\" class=\"club.sdll.shiro.CustomCredentialsMatcher\">\n    </bean>\n        \n    <bean id=\"simpleCookie\" class=\"org.apache.shiro.web.servlet.SimpleCookie\">\n       <constructor-arg name=\"name\" value=\"rememberMe\"></constructor-arg>\n       <property name=\"maxAge\" value=\"2592000\"/>\n    </bean>\n    \n    <bean id=\"cookieRememberMeManager\" class=\"org.apache.shiro.web.mgt.CookieRememberMeManager\">\n       <property name=\"cookie\" ref=\"simpleCookie\"></property>\n    </bean>\n\n    <bean id=\"securityWebManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\">\n        <property name=\"realm\" ref=\"customRealm\" />\n        <property name=\"cacheManager\" ref=\"cacheManager\" />\n        <property name=\"rememberMeManager\" ref=\"cookieRememberMeManager\"></property>\n    </bean>\n    \n    <bean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\">\n        <property name=\"securityManager\" ref=\"securityWebManager\" />\n        <property name=\"loginUrl\" value=\"/index.jsp?toTop=true\" />\n        <property name=\"successUrl\" value=\"/index.jsp\" />\n        <property name=\"unauthorizedUrl\" value=\"/index.jsp\" />\n\n        <property name=\"filters\">\n            <util:map>\n                <entry key=\"authc\">\n                    <bean\n                        class=\"org.apache.shiro.web.filter.authc.FormAuthenticationFilter\" />\n                </entry>\n            </util:map>\n        </property>\n        <property name=\"filterChainDefinitions\"><!--authc  -->\n            <value>\n                /resources/** = anon\n                /common/** = anon\n                /plugins/framework/** = anon\n                /plugins/login/** = anon\n                /plugins/sysmgr/**  = authc\n                /plugins/comm/**  = authc\n                /plugins/business/**  = authc\n                /sysmgr/** = authc\n                /business/** = authc\n                /comm/** = authc\n                /main/** = authc  <!-- 用户必须登录才能访问 -->\n                /login/** = anon <!-- 任何人都可以访问 -->\n                /kaptcha/** = anon\n        <!--    /authc/admin =roles[admin]  需要用户有用admin权限才能访问 -->\n            </value>\n        </property>\n    </bean>\n    \n    <bean id=\"cacheManager\" class=\"org.apache.shiro.cache.MemoryConstrainedCacheManager\" />\n    <bean id=\"lifecycleBeanPostProcessor\" class=\"org.apache.shiro.spring.LifecycleBeanPostProcessor\" />\n</beans>\n```\n- 自定义realm 类继承 `AuthorizingRealm`\n```\n/**\n * \n */\npackage club.sdll.blog.sysmgr.shiro;\n\nimport org.apache.shiro.authc.AuthenticationException;\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.SimpleAuthenticationInfo;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.authz.SimpleAuthorizationInfo;\nimport org.apache.shiro.realm.AuthorizingRealm;\nimport org.apache.shiro.subject.PrincipalCollection;\nimport org.springframework.beans.factory.annotation.Autowired;\n\nimport com.eshore.icthala.sysmgr.pojo.bean.authority.SysUser;\nimport com.eshore.icthala.sysmgr.service.authority.ISysUserService;\n\n/**\n * \n * Shiro领域\n */\npublic class CustomRealm extends AuthorizingRealm {\n    \n    @Autowired ISysUserService sysUserService;\n\n    /**\n     * 授权验证\n     */\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n         //Object object = this.getAvailablePrincipal(principals);\n         SimpleAuthorizationInfo principal = new SimpleAuthorizationInfo(); \n         //principal.setRoles(new HashSet<String>());\n         //principal.setStringPermissions(new HashSet<String>(){});\n        return principal;\n    }\n\n    /**\n     * 获取登录验证信息\n     */\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n        AuthenticationInfo athcInfo = null;\n        UsernamePasswordToken athcToken = (UsernamePasswordToken) token;\n        try {\n            SysUser sysUser = sysUserService.getUserByLoginName(athcToken.getUsername());\n            if(null!=sysUser){  //验证是否存在用户\n                athcInfo =  new SimpleAuthenticationInfo(sysUser.getLoginName(),sysUser.getLoginPwd(), getName());\n            }\n            return athcInfo;\n        } catch (Exception ex) {\n            throw new AuthenticationException(ex);\n        }\n    }\n\n}\n\n```\n- shiro证书匹配\n```\n/**\n * \n */\npackage club.sdll.blog.sysmgr.shiro;\n\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.authc.credential.SimpleCredentialsMatcher;\n\nimport com.eshore.icthala.common.utils.crypt.MD5Util;\n\n/**\n * @author chengxiwang\n * 2017年09月13日 下午2:56:55\n * shiro证书匹配\n */\npublic class CustomCredentialsMatcher extends SimpleCredentialsMatcher {\n    /**\n     * 登录密码验证\n     */\n    @Override\n    public boolean doCredentialsMatch(AuthenticationToken token,AuthenticationInfo info) {\n        UsernamePasswordToken authcToken = (UsernamePasswordToken) token;\n        String passwordFromAthcToken = String.valueOf(authcToken.getPassword()); //\n        Object accountCredentials = null;\n        try {\n            accountCredentials = MD5Util.crypt(getCredentials(info).toString());\n        } catch (Exception e) {\n            return Boolean.FALSE.booleanValue();\n        }\n        return equals(passwordFromAthcToken, accountCredentials);\n    }\n\n}\n```\n\n### 二、使用\n```\n/**\n * \n * 登录操作\n * @param page\n * @return\n * @throws ControllerException\n * @throws UtilException\n */\n@RequestMapping(value = \"loginOn\", method = { RequestMethod.GET})\n    public ModelAndView loginOn(LoginForm loginForm,RedirectAttributes attrs) throws ControllerException{\n         try {\n             //验证验证码\n            if(!checkKaptcha(loginForm)){\n                attrs.addFlashAttribute(\"message\", \"验证码错误!\");\n                return toLogin(attrs);\n            }\n            //验证用户名和密码\n            if(!checkUser(loginForm)){\n                attrs.addFlashAttribute(\"message\", \"密码错误!\");\n                return toLogin(attrs); \n            }else{\n                formSession(loginForm);\n            }\n            return toHome();\n        }catch (ControllerException ex){\n            attrs.addFlashAttribute(\"message\", \"登录过程发生异常!请联系系统管理员\");\n            return toLogin(attrs);\n        }\n   }\n   \n   \n   /**\n     * \n     * 用户名密码验证\n     * @param loginForm\n     * @return\n     */\n    private Boolean checkUser(LoginForm loginForm){\n        Boolean checkResult = Boolean.FALSE;\n        try{\n            UsernamePasswordToken token = new UsernamePasswordToken(loginForm.getUserName(),loginForm.getPassword());\n            Subject currentUser = SecurityUtils.getSubject();\n            currentUser.login(token);\n            checkResult = currentUser.isAuthenticated();\n            token.setRememberMe(false);\n        }catch(Exception ex){\n            checkResult = Boolean.FALSE;\n        }\n        return checkResult;\n    }\n```\n\n\n\n**引用参考：**\nhttps://www.cnblogs.com/learnhow/p/5694876.html","slug":"shiro验证框架","published":1,"updated":"2018-05-23T01:26:32.832Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2w200x4000xmwd35kwqv8ge","content":"<p>Apache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码学和会话管理。使用Shiro的易于理解的API,您可以快速、轻松地获得任何应用程序,从最小的移动应用程序到最大的网络和企业应用程序。<br><a id=\"more\"></a></p>\n<h3 id=\"配置介绍\"><a href=\"#配置介绍\" class=\"headerlink\" title=\"配置介绍\"></a>配置介绍</h3><ul>\n<li><p>shiro 添加 pom.xml 相关依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Shiro SECURITY begin --&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;$&#123;shiro.version&#125;&lt;/version&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;$&#123;shiro.version&#125;&lt;/version&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;shiro-web&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;$&#123;shiro.version&#125;&lt;/version&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;$&#123;shiro.version&#125;&lt;/version&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;shiro-quartz&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;$&#123;shiro.version&#125;&lt;/version&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">&lt;!-- Shiro SECURITY end --&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>web.xml配置shrio</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Shiro安全管理   begin--&gt;</span><br><span class=\"line\">    &lt;filter&gt;</span><br><span class=\"line\">        &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;</span><br><span class=\"line\">        &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;</span><br><span class=\"line\">        &lt;init-param&gt;</span><br><span class=\"line\">            &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt;</span><br><span class=\"line\">            &lt;param-value&gt;true&lt;/param-value&gt;</span><br><span class=\"line\">        &lt;/init-param&gt;</span><br><span class=\"line\">    &lt;/filter&gt;</span><br><span class=\"line\">    &lt;filter-mapping&gt;</span><br><span class=\"line\">        &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;</span><br><span class=\"line\">        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class=\"line\">    &lt;/filter-mapping&gt;</span><br><span class=\"line\">    &lt;!-- Shiro安全管理    end --&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在web.xml中加载spring配置文件applicationContext.xml,在spring配置文件中导入加载shiro.xml，如下所示。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;import resource=&quot;../shiro/shiro.xml&quot;/&gt;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>shiro.xml 配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class=\"line\">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">    xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;</span><br><span class=\"line\">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class=\"line\">    xmlns:util=&quot;http://www.springframework.org/schema/util&quot;</span><br><span class=\"line\">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class=\"line\">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.0.xsd&quot;</span><br><span class=\"line\">    default-lazy-init=&quot;true&quot;&gt;</span><br><span class=\"line\">    &lt;description&gt;Shiro Configuration&lt;/description&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;bean id=&quot;customRealm&quot; class=&quot;club.sdll.shiro.CustomRealm&quot;&gt;</span><br><span class=\"line\">        &lt;property name=&quot;credentialsMatcher&quot; ref=&quot;customCredentialsMatcher&quot; /&gt;</span><br><span class=\"line\">    &lt;/bean&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;bean id=&quot;customCredentialsMatcher&quot; class=&quot;club.sdll.shiro.CustomCredentialsMatcher&quot;&gt;</span><br><span class=\"line\">    &lt;/bean&gt;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &lt;bean id=&quot;simpleCookie&quot; class=&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt;</span><br><span class=\"line\">       &lt;constructor-arg name=&quot;name&quot; value=&quot;rememberMe&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class=\"line\">       &lt;property name=&quot;maxAge&quot; value=&quot;2592000&quot;/&gt;</span><br><span class=\"line\">    &lt;/bean&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;bean id=&quot;cookieRememberMeManager&quot; class=&quot;org.apache.shiro.web.mgt.CookieRememberMeManager&quot;&gt;</span><br><span class=\"line\">       &lt;property name=&quot;cookie&quot; ref=&quot;simpleCookie&quot;&gt;&lt;/property&gt;</span><br><span class=\"line\">    &lt;/bean&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;bean id=&quot;securityWebManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt;</span><br><span class=\"line\">        &lt;property name=&quot;realm&quot; ref=&quot;customRealm&quot; /&gt;</span><br><span class=\"line\">        &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot; /&gt;</span><br><span class=\"line\">        &lt;property name=&quot;rememberMeManager&quot; ref=&quot;cookieRememberMeManager&quot;&gt;&lt;/property&gt;</span><br><span class=\"line\">    &lt;/bean&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;</span><br><span class=\"line\">        &lt;property name=&quot;securityManager&quot; ref=&quot;securityWebManager&quot; /&gt;</span><br><span class=\"line\">        &lt;property name=&quot;loginUrl&quot; value=&quot;/index.jsp?toTop=true&quot; /&gt;</span><br><span class=\"line\">        &lt;property name=&quot;successUrl&quot; value=&quot;/index.jsp&quot; /&gt;</span><br><span class=\"line\">        &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/index.jsp&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;property name=&quot;filters&quot;&gt;</span><br><span class=\"line\">            &lt;util:map&gt;</span><br><span class=\"line\">                &lt;entry key=&quot;authc&quot;&gt;</span><br><span class=\"line\">                    &lt;bean</span><br><span class=\"line\">                        class=&quot;org.apache.shiro.web.filter.authc.FormAuthenticationFilter&quot; /&gt;</span><br><span class=\"line\">                &lt;/entry&gt;</span><br><span class=\"line\">            &lt;/util:map&gt;</span><br><span class=\"line\">        &lt;/property&gt;</span><br><span class=\"line\">        &lt;property name=&quot;filterChainDefinitions&quot;&gt;&lt;!--authc  --&gt;</span><br><span class=\"line\">            &lt;value&gt;</span><br><span class=\"line\">                /resources/** = anon</span><br><span class=\"line\">                /common/** = anon</span><br><span class=\"line\">                /plugins/framework/** = anon</span><br><span class=\"line\">                /plugins/login/** = anon</span><br><span class=\"line\">                /plugins/sysmgr/**  = authc</span><br><span class=\"line\">                /plugins/comm/**  = authc</span><br><span class=\"line\">                /plugins/business/**  = authc</span><br><span class=\"line\">                /sysmgr/** = authc</span><br><span class=\"line\">                /business/** = authc</span><br><span class=\"line\">                /comm/** = authc</span><br><span class=\"line\">                /main/** = authc  &lt;!-- 用户必须登录才能访问 --&gt;</span><br><span class=\"line\">                /login/** = anon &lt;!-- 任何人都可以访问 --&gt;</span><br><span class=\"line\">                /kaptcha/** = anon</span><br><span class=\"line\">        &lt;!--    /authc/admin =roles[admin]  需要用户有用admin权限才能访问 --&gt;</span><br><span class=\"line\">            &lt;/value&gt;</span><br><span class=\"line\">        &lt;/property&gt;</span><br><span class=\"line\">    &lt;/bean&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;bean id=&quot;cacheManager&quot; class=&quot;org.apache.shiro.cache.MemoryConstrainedCacheManager&quot; /&gt;</span><br><span class=\"line\">    &lt;bean id=&quot;lifecycleBeanPostProcessor&quot; class=&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot; /&gt;</span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>自定义realm 类继承 <code>AuthorizingRealm</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> */</span><br><span class=\"line\">package club.sdll.blog.sysmgr.shiro;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.apache.shiro.authc.AuthenticationException;</span><br><span class=\"line\">import org.apache.shiro.authc.AuthenticationInfo;</span><br><span class=\"line\">import org.apache.shiro.authc.AuthenticationToken;</span><br><span class=\"line\">import org.apache.shiro.authc.SimpleAuthenticationInfo;</span><br><span class=\"line\">import org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\">import org.apache.shiro.authz.AuthorizationInfo;</span><br><span class=\"line\">import org.apache.shiro.authz.SimpleAuthorizationInfo;</span><br><span class=\"line\">import org.apache.shiro.realm.AuthorizingRealm;</span><br><span class=\"line\">import org.apache.shiro.subject.PrincipalCollection;</span><br><span class=\"line\">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.eshore.icthala.sysmgr.pojo.bean.authority.SysUser;</span><br><span class=\"line\">import com.eshore.icthala.sysmgr.service.authority.ISysUserService;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * Shiro领域</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class CustomRealm extends AuthorizingRealm &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @Autowired ISysUserService sysUserService;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 授权验证</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123;</span><br><span class=\"line\">         //Object object = this.getAvailablePrincipal(principals);</span><br><span class=\"line\">         SimpleAuthorizationInfo principal = new SimpleAuthorizationInfo(); </span><br><span class=\"line\">         //principal.setRoles(new HashSet&lt;String&gt;());</span><br><span class=\"line\">         //principal.setStringPermissions(new HashSet&lt;String&gt;()&#123;&#125;);</span><br><span class=\"line\">        return principal;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 获取登录验证信息</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;</span><br><span class=\"line\">        AuthenticationInfo athcInfo = null;</span><br><span class=\"line\">        UsernamePasswordToken athcToken = (UsernamePasswordToken) token;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            SysUser sysUser = sysUserService.getUserByLoginName(athcToken.getUsername());</span><br><span class=\"line\">            if(null!=sysUser)&#123;  //验证是否存在用户</span><br><span class=\"line\">                athcInfo =  new SimpleAuthenticationInfo(sysUser.getLoginName(),sysUser.getLoginPwd(), getName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return athcInfo;</span><br><span class=\"line\">        &#125; catch (Exception ex) &#123;</span><br><span class=\"line\">            throw new AuthenticationException(ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>shiro证书匹配</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> */</span><br><span class=\"line\">package club.sdll.blog.sysmgr.shiro;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.apache.shiro.authc.AuthenticationInfo;</span><br><span class=\"line\">import org.apache.shiro.authc.AuthenticationToken;</span><br><span class=\"line\">import org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\">import org.apache.shiro.authc.credential.SimpleCredentialsMatcher;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.eshore.icthala.common.utils.crypt.MD5Util;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author chengxiwang</span><br><span class=\"line\"> * 2017年09月13日 下午2:56:55</span><br><span class=\"line\"> * shiro证书匹配</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class CustomCredentialsMatcher extends SimpleCredentialsMatcher &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 登录密码验证</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean doCredentialsMatch(AuthenticationToken token,AuthenticationInfo info) &#123;</span><br><span class=\"line\">        UsernamePasswordToken authcToken = (UsernamePasswordToken) token;</span><br><span class=\"line\">        String passwordFromAthcToken = String.valueOf(authcToken.getPassword()); //</span><br><span class=\"line\">        Object accountCredentials = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            accountCredentials = MD5Util.crypt(getCredentials(info).toString());</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            return Boolean.FALSE.booleanValue();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return equals(passwordFromAthcToken, accountCredentials);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"二、使用\"><a href=\"#二、使用\" class=\"headerlink\" title=\"二、使用\"></a>二、使用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * 登录操作</span><br><span class=\"line\"> * @param page</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> * @throws ControllerException</span><br><span class=\"line\"> * @throws UtilException</span><br><span class=\"line\"> */</span><br><span class=\"line\">@RequestMapping(value = &quot;loginOn&quot;, method = &#123; RequestMethod.GET&#125;)</span><br><span class=\"line\">    public ModelAndView loginOn(LoginForm loginForm,RedirectAttributes attrs) throws ControllerException&#123;</span><br><span class=\"line\">         try &#123;</span><br><span class=\"line\">             //验证验证码</span><br><span class=\"line\">            if(!checkKaptcha(loginForm))&#123;</span><br><span class=\"line\">                attrs.addFlashAttribute(&quot;message&quot;, &quot;验证码错误!&quot;);</span><br><span class=\"line\">                return toLogin(attrs);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            //验证用户名和密码</span><br><span class=\"line\">            if(!checkUser(loginForm))&#123;</span><br><span class=\"line\">                attrs.addFlashAttribute(&quot;message&quot;, &quot;密码错误!&quot;);</span><br><span class=\"line\">                return toLogin(attrs); </span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                formSession(loginForm);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return toHome();</span><br><span class=\"line\">        &#125;catch (ControllerException ex)&#123;</span><br><span class=\"line\">            attrs.addFlashAttribute(&quot;message&quot;, &quot;登录过程发生异常!请联系系统管理员&quot;);</span><br><span class=\"line\">            return toLogin(attrs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   </span><br><span class=\"line\">   /**</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * 用户名密码验证</span><br><span class=\"line\">     * @param loginForm</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private Boolean checkUser(LoginForm loginForm)&#123;</span><br><span class=\"line\">        Boolean checkResult = Boolean.FALSE;</span><br><span class=\"line\">        try&#123;</span><br><span class=\"line\">            UsernamePasswordToken token = new UsernamePasswordToken(loginForm.getUserName(),loginForm.getPassword());</span><br><span class=\"line\">            Subject currentUser = SecurityUtils.getSubject();</span><br><span class=\"line\">            currentUser.login(token);</span><br><span class=\"line\">            checkResult = currentUser.isAuthenticated();</span><br><span class=\"line\">            token.setRememberMe(false);</span><br><span class=\"line\">        &#125;catch(Exception ex)&#123;</span><br><span class=\"line\">            checkResult = Boolean.FALSE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return checkResult;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>引用参考：</strong><br><a href=\"https://www.cnblogs.com/learnhow/p/5694876.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/learnhow/p/5694876.html</a></p>\n","site":{"data":{}},"excerpt":"<p>Apache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码学和会话管理。使用Shiro的易于理解的API,您可以快速、轻松地获得任何应用程序,从最小的移动应用程序到最大的网络和企业应用程序。<br>","more":"</p>\n<h3 id=\"配置介绍\"><a href=\"#配置介绍\" class=\"headerlink\" title=\"配置介绍\"></a>配置介绍</h3><ul>\n<li><p>shiro 添加 pom.xml 相关依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Shiro SECURITY begin --&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;$&#123;shiro.version&#125;&lt;/version&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;$&#123;shiro.version&#125;&lt;/version&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;shiro-web&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;$&#123;shiro.version&#125;&lt;/version&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;$&#123;shiro.version&#125;&lt;/version&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;dependency&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;shiro-quartz&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;$&#123;shiro.version&#125;&lt;/version&gt;</span><br><span class=\"line\">    &lt;/dependency&gt;</span><br><span class=\"line\">&lt;!-- Shiro SECURITY end --&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>web.xml配置shrio</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- Shiro安全管理   begin--&gt;</span><br><span class=\"line\">    &lt;filter&gt;</span><br><span class=\"line\">        &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;</span><br><span class=\"line\">        &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;</span><br><span class=\"line\">        &lt;init-param&gt;</span><br><span class=\"line\">            &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt;</span><br><span class=\"line\">            &lt;param-value&gt;true&lt;/param-value&gt;</span><br><span class=\"line\">        &lt;/init-param&gt;</span><br><span class=\"line\">    &lt;/filter&gt;</span><br><span class=\"line\">    &lt;filter-mapping&gt;</span><br><span class=\"line\">        &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;</span><br><span class=\"line\">        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class=\"line\">    &lt;/filter-mapping&gt;</span><br><span class=\"line\">    &lt;!-- Shiro安全管理    end --&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在web.xml中加载spring配置文件applicationContext.xml,在spring配置文件中导入加载shiro.xml，如下所示。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;import resource=&quot;../shiro/shiro.xml&quot;/&gt;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>shiro.xml 配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class=\"line\">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">    xmlns:jee=&quot;http://www.springframework.org/schema/jee&quot;</span><br><span class=\"line\">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class=\"line\">    xmlns:util=&quot;http://www.springframework.org/schema/util&quot;</span><br><span class=\"line\">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class=\"line\">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.0.xsd&quot;</span><br><span class=\"line\">    default-lazy-init=&quot;true&quot;&gt;</span><br><span class=\"line\">    &lt;description&gt;Shiro Configuration&lt;/description&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;bean id=&quot;customRealm&quot; class=&quot;club.sdll.shiro.CustomRealm&quot;&gt;</span><br><span class=\"line\">        &lt;property name=&quot;credentialsMatcher&quot; ref=&quot;customCredentialsMatcher&quot; /&gt;</span><br><span class=\"line\">    &lt;/bean&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;bean id=&quot;customCredentialsMatcher&quot; class=&quot;club.sdll.shiro.CustomCredentialsMatcher&quot;&gt;</span><br><span class=\"line\">    &lt;/bean&gt;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &lt;bean id=&quot;simpleCookie&quot; class=&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt;</span><br><span class=\"line\">       &lt;constructor-arg name=&quot;name&quot; value=&quot;rememberMe&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class=\"line\">       &lt;property name=&quot;maxAge&quot; value=&quot;2592000&quot;/&gt;</span><br><span class=\"line\">    &lt;/bean&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;bean id=&quot;cookieRememberMeManager&quot; class=&quot;org.apache.shiro.web.mgt.CookieRememberMeManager&quot;&gt;</span><br><span class=\"line\">       &lt;property name=&quot;cookie&quot; ref=&quot;simpleCookie&quot;&gt;&lt;/property&gt;</span><br><span class=\"line\">    &lt;/bean&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;bean id=&quot;securityWebManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt;</span><br><span class=\"line\">        &lt;property name=&quot;realm&quot; ref=&quot;customRealm&quot; /&gt;</span><br><span class=\"line\">        &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot; /&gt;</span><br><span class=\"line\">        &lt;property name=&quot;rememberMeManager&quot; ref=&quot;cookieRememberMeManager&quot;&gt;&lt;/property&gt;</span><br><span class=\"line\">    &lt;/bean&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;</span><br><span class=\"line\">        &lt;property name=&quot;securityManager&quot; ref=&quot;securityWebManager&quot; /&gt;</span><br><span class=\"line\">        &lt;property name=&quot;loginUrl&quot; value=&quot;/index.jsp?toTop=true&quot; /&gt;</span><br><span class=\"line\">        &lt;property name=&quot;successUrl&quot; value=&quot;/index.jsp&quot; /&gt;</span><br><span class=\"line\">        &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/index.jsp&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;property name=&quot;filters&quot;&gt;</span><br><span class=\"line\">            &lt;util:map&gt;</span><br><span class=\"line\">                &lt;entry key=&quot;authc&quot;&gt;</span><br><span class=\"line\">                    &lt;bean</span><br><span class=\"line\">                        class=&quot;org.apache.shiro.web.filter.authc.FormAuthenticationFilter&quot; /&gt;</span><br><span class=\"line\">                &lt;/entry&gt;</span><br><span class=\"line\">            &lt;/util:map&gt;</span><br><span class=\"line\">        &lt;/property&gt;</span><br><span class=\"line\">        &lt;property name=&quot;filterChainDefinitions&quot;&gt;&lt;!--authc  --&gt;</span><br><span class=\"line\">            &lt;value&gt;</span><br><span class=\"line\">                /resources/** = anon</span><br><span class=\"line\">                /common/** = anon</span><br><span class=\"line\">                /plugins/framework/** = anon</span><br><span class=\"line\">                /plugins/login/** = anon</span><br><span class=\"line\">                /plugins/sysmgr/**  = authc</span><br><span class=\"line\">                /plugins/comm/**  = authc</span><br><span class=\"line\">                /plugins/business/**  = authc</span><br><span class=\"line\">                /sysmgr/** = authc</span><br><span class=\"line\">                /business/** = authc</span><br><span class=\"line\">                /comm/** = authc</span><br><span class=\"line\">                /main/** = authc  &lt;!-- 用户必须登录才能访问 --&gt;</span><br><span class=\"line\">                /login/** = anon &lt;!-- 任何人都可以访问 --&gt;</span><br><span class=\"line\">                /kaptcha/** = anon</span><br><span class=\"line\">        &lt;!--    /authc/admin =roles[admin]  需要用户有用admin权限才能访问 --&gt;</span><br><span class=\"line\">            &lt;/value&gt;</span><br><span class=\"line\">        &lt;/property&gt;</span><br><span class=\"line\">    &lt;/bean&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;bean id=&quot;cacheManager&quot; class=&quot;org.apache.shiro.cache.MemoryConstrainedCacheManager&quot; /&gt;</span><br><span class=\"line\">    &lt;bean id=&quot;lifecycleBeanPostProcessor&quot; class=&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot; /&gt;</span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>自定义realm 类继承 <code>AuthorizingRealm</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> */</span><br><span class=\"line\">package club.sdll.blog.sysmgr.shiro;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.apache.shiro.authc.AuthenticationException;</span><br><span class=\"line\">import org.apache.shiro.authc.AuthenticationInfo;</span><br><span class=\"line\">import org.apache.shiro.authc.AuthenticationToken;</span><br><span class=\"line\">import org.apache.shiro.authc.SimpleAuthenticationInfo;</span><br><span class=\"line\">import org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\">import org.apache.shiro.authz.AuthorizationInfo;</span><br><span class=\"line\">import org.apache.shiro.authz.SimpleAuthorizationInfo;</span><br><span class=\"line\">import org.apache.shiro.realm.AuthorizingRealm;</span><br><span class=\"line\">import org.apache.shiro.subject.PrincipalCollection;</span><br><span class=\"line\">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.eshore.icthala.sysmgr.pojo.bean.authority.SysUser;</span><br><span class=\"line\">import com.eshore.icthala.sysmgr.service.authority.ISysUserService;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * Shiro领域</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class CustomRealm extends AuthorizingRealm &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @Autowired ISysUserService sysUserService;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 授权验证</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123;</span><br><span class=\"line\">         //Object object = this.getAvailablePrincipal(principals);</span><br><span class=\"line\">         SimpleAuthorizationInfo principal = new SimpleAuthorizationInfo(); </span><br><span class=\"line\">         //principal.setRoles(new HashSet&lt;String&gt;());</span><br><span class=\"line\">         //principal.setStringPermissions(new HashSet&lt;String&gt;()&#123;&#125;);</span><br><span class=\"line\">        return principal;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 获取登录验证信息</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;</span><br><span class=\"line\">        AuthenticationInfo athcInfo = null;</span><br><span class=\"line\">        UsernamePasswordToken athcToken = (UsernamePasswordToken) token;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            SysUser sysUser = sysUserService.getUserByLoginName(athcToken.getUsername());</span><br><span class=\"line\">            if(null!=sysUser)&#123;  //验证是否存在用户</span><br><span class=\"line\">                athcInfo =  new SimpleAuthenticationInfo(sysUser.getLoginName(),sysUser.getLoginPwd(), getName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return athcInfo;</span><br><span class=\"line\">        &#125; catch (Exception ex) &#123;</span><br><span class=\"line\">            throw new AuthenticationException(ex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>shiro证书匹配</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> */</span><br><span class=\"line\">package club.sdll.blog.sysmgr.shiro;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.apache.shiro.authc.AuthenticationInfo;</span><br><span class=\"line\">import org.apache.shiro.authc.AuthenticationToken;</span><br><span class=\"line\">import org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\">import org.apache.shiro.authc.credential.SimpleCredentialsMatcher;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.eshore.icthala.common.utils.crypt.MD5Util;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @author chengxiwang</span><br><span class=\"line\"> * 2017年09月13日 下午2:56:55</span><br><span class=\"line\"> * shiro证书匹配</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class CustomCredentialsMatcher extends SimpleCredentialsMatcher &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 登录密码验证</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean doCredentialsMatch(AuthenticationToken token,AuthenticationInfo info) &#123;</span><br><span class=\"line\">        UsernamePasswordToken authcToken = (UsernamePasswordToken) token;</span><br><span class=\"line\">        String passwordFromAthcToken = String.valueOf(authcToken.getPassword()); //</span><br><span class=\"line\">        Object accountCredentials = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            accountCredentials = MD5Util.crypt(getCredentials(info).toString());</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            return Boolean.FALSE.booleanValue();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return equals(passwordFromAthcToken, accountCredentials);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"二、使用\"><a href=\"#二、使用\" class=\"headerlink\" title=\"二、使用\"></a>二、使用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * 登录操作</span><br><span class=\"line\"> * @param page</span><br><span class=\"line\"> * @return</span><br><span class=\"line\"> * @throws ControllerException</span><br><span class=\"line\"> * @throws UtilException</span><br><span class=\"line\"> */</span><br><span class=\"line\">@RequestMapping(value = &quot;loginOn&quot;, method = &#123; RequestMethod.GET&#125;)</span><br><span class=\"line\">    public ModelAndView loginOn(LoginForm loginForm,RedirectAttributes attrs) throws ControllerException&#123;</span><br><span class=\"line\">         try &#123;</span><br><span class=\"line\">             //验证验证码</span><br><span class=\"line\">            if(!checkKaptcha(loginForm))&#123;</span><br><span class=\"line\">                attrs.addFlashAttribute(&quot;message&quot;, &quot;验证码错误!&quot;);</span><br><span class=\"line\">                return toLogin(attrs);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            //验证用户名和密码</span><br><span class=\"line\">            if(!checkUser(loginForm))&#123;</span><br><span class=\"line\">                attrs.addFlashAttribute(&quot;message&quot;, &quot;密码错误!&quot;);</span><br><span class=\"line\">                return toLogin(attrs); </span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                formSession(loginForm);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            return toHome();</span><br><span class=\"line\">        &#125;catch (ControllerException ex)&#123;</span><br><span class=\"line\">            attrs.addFlashAttribute(&quot;message&quot;, &quot;登录过程发生异常!请联系系统管理员&quot;);</span><br><span class=\"line\">            return toLogin(attrs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">   </span><br><span class=\"line\">   /**</span><br><span class=\"line\">     * </span><br><span class=\"line\">     * 用户名密码验证</span><br><span class=\"line\">     * @param loginForm</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private Boolean checkUser(LoginForm loginForm)&#123;</span><br><span class=\"line\">        Boolean checkResult = Boolean.FALSE;</span><br><span class=\"line\">        try&#123;</span><br><span class=\"line\">            UsernamePasswordToken token = new UsernamePasswordToken(loginForm.getUserName(),loginForm.getPassword());</span><br><span class=\"line\">            Subject currentUser = SecurityUtils.getSubject();</span><br><span class=\"line\">            currentUser.login(token);</span><br><span class=\"line\">            checkResult = currentUser.isAuthenticated();</span><br><span class=\"line\">            token.setRememberMe(false);</span><br><span class=\"line\">        &#125;catch(Exception ex)&#123;</span><br><span class=\"line\">            checkResult = Boolean.FALSE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return checkResult;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>引用参考：</strong><br><a href=\"https://www.cnblogs.com/learnhow/p/5694876.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/learnhow/p/5694876.html</a></p>"},{"title":"《维京：王者之战》观影感","abbrlink":"10818c5d","date":"2017-12-03T11:20:32.000Z","_content":"在大学的时候养成的看电影的习惯，先去豆瓣网搜索下电影的评分怎么样，一半低于7分的电影会直接选择忽视掉，不看；所以我现一般在空闲的时候会不自觉的去找些符合自己品味的电影来看，记得以前看过一个电影[《与狼共舞》](https://movie.douban.com/subject/1293764/)，被里面的场景给震撼住了，电影拍的蛮不错的，强烈推荐哦；\n<!-- more -->\n- **背景介绍**\n> 现在回到今天的主题《维京：王者之战》。\n![维京：王者之战](http://ozux0lqfa.bkt.clouddn.com/%E7%BB%B4%E4%BA%AC%EF%BC%9A%E7%8E%8B%E8%80%85%E4%B9%8B%E6%88%98.png)\n\n- **观影由来**\n> 在午休的时候无意间刷微博，看到这篇电影的简介，点进预告片，迎面给我带来的感受是“森林”、“皑皑大雪”、“猎手”、“野牛”、“斧头”等等这些工具，给人一种很强烈的视觉冲击，使得我对这部电影充满了期待，连夜把电影资源下载下来，电影时长两个多小时，然后就想着周末空闲的时候把电影看完,终于周五放假啦。。。\n\n- **观影感**\n> 电影总共是分为卫三段看完的，在整个观影过程中，除了电影在追逐野牛那段给我带了强烈的视觉的冲击，并未见其他的闪光点，电影的叙事过程比较拖拉，看完了整个电影后仍没有对整个电影的故事情节有一个完整的认识，我不知道是不是因为我看的过程断断续续导致的。其实看这部电影的时候我是把它拿来跟小李子的![《荒野猎人》](https://movie.douban.com/subject/5327268/)作为同一类型、级别的电影来比较的，故在看电影之前我都没有去看这部电影的豆瓣评分高不高；电影一直到结束我还未能理顺整个电影...\n\n- **总结**\n> *推荐指数：* ★★★\n建议大家看电影之前先去查下豆瓣评分，作为一个大概的参考。\n","source":"_posts/《维京：王者之战》观影感.md","raw":"---\ntitle: 《维京：王者之战》观影感\ntags:\n  - 电影\nabbrlink: 10818c5d\ndate: 2017-12-03 19:20:32\n---\n在大学的时候养成的看电影的习惯，先去豆瓣网搜索下电影的评分怎么样，一半低于7分的电影会直接选择忽视掉，不看；所以我现一般在空闲的时候会不自觉的去找些符合自己品味的电影来看，记得以前看过一个电影[《与狼共舞》](https://movie.douban.com/subject/1293764/)，被里面的场景给震撼住了，电影拍的蛮不错的，强烈推荐哦；\n<!-- more -->\n- **背景介绍**\n> 现在回到今天的主题《维京：王者之战》。\n![维京：王者之战](http://ozux0lqfa.bkt.clouddn.com/%E7%BB%B4%E4%BA%AC%EF%BC%9A%E7%8E%8B%E8%80%85%E4%B9%8B%E6%88%98.png)\n\n- **观影由来**\n> 在午休的时候无意间刷微博，看到这篇电影的简介，点进预告片，迎面给我带来的感受是“森林”、“皑皑大雪”、“猎手”、“野牛”、“斧头”等等这些工具，给人一种很强烈的视觉冲击，使得我对这部电影充满了期待，连夜把电影资源下载下来，电影时长两个多小时，然后就想着周末空闲的时候把电影看完,终于周五放假啦。。。\n\n- **观影感**\n> 电影总共是分为卫三段看完的，在整个观影过程中，除了电影在追逐野牛那段给我带了强烈的视觉的冲击，并未见其他的闪光点，电影的叙事过程比较拖拉，看完了整个电影后仍没有对整个电影的故事情节有一个完整的认识，我不知道是不是因为我看的过程断断续续导致的。其实看这部电影的时候我是把它拿来跟小李子的![《荒野猎人》](https://movie.douban.com/subject/5327268/)作为同一类型、级别的电影来比较的，故在看电影之前我都没有去看这部电影的豆瓣评分高不高；电影一直到结束我还未能理顺整个电影...\n\n- **总结**\n> *推荐指数：* ★★★\n建议大家看电影之前先去查下豆瓣评分，作为一个大概的参考。\n","slug":"《维京：王者之战》观影感","published":1,"updated":"2017-12-14T13:55:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2w200x9000zmwd3bvwccd0b","content":"<p>在大学的时候养成的看电影的习惯，先去豆瓣网搜索下电影的评分怎么样，一半低于7分的电影会直接选择忽视掉，不看；所以我现一般在空闲的时候会不自觉的去找些符合自己品味的电影来看，记得以前看过一个电影<a href=\"https://movie.douban.com/subject/1293764/\" target=\"_blank\" rel=\"noopener\">《与狼共舞》</a>，被里面的场景给震撼住了，电影拍的蛮不错的，强烈推荐哦；<br><a id=\"more\"></a></p>\n<ul>\n<li><p><strong>背景介绍</strong></p>\n<blockquote>\n<p>现在回到今天的主题《维京：王者之战》。<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/%E7%BB%B4%E4%BA%AC%EF%BC%9A%E7%8E%8B%E8%80%85%E4%B9%8B%E6%88%98.png\" alt=\"维京：王者之战\"></p>\n</blockquote>\n</li>\n<li><p><strong>观影由来</strong></p>\n<blockquote>\n<p>在午休的时候无意间刷微博，看到这篇电影的简介，点进预告片，迎面给我带来的感受是“森林”、“皑皑大雪”、“猎手”、“野牛”、“斧头”等等这些工具，给人一种很强烈的视觉冲击，使得我对这部电影充满了期待，连夜把电影资源下载下来，电影时长两个多小时，然后就想着周末空闲的时候把电影看完,终于周五放假啦。。。</p>\n</blockquote>\n</li>\n<li><p><strong>观影感</strong></p>\n<blockquote>\n<p>电影总共是分为卫三段看完的，在整个观影过程中，除了电影在追逐野牛那段给我带了强烈的视觉的冲击，并未见其他的闪光点，电影的叙事过程比较拖拉，看完了整个电影后仍没有对整个电影的故事情节有一个完整的认识，我不知道是不是因为我看的过程断断续续导致的。其实看这部电影的时候我是把它拿来跟小李子的<img src=\"https://movie.douban.com/subject/5327268/\" alt=\"《荒野猎人》\">作为同一类型、级别的电影来比较的，故在看电影之前我都没有去看这部电影的豆瓣评分高不高；电影一直到结束我还未能理顺整个电影…</p>\n</blockquote>\n</li>\n<li><p><strong>总结</strong></p>\n<blockquote>\n<p><em>推荐指数：</em> ★★★<br>建议大家看电影之前先去查下豆瓣评分，作为一个大概的参考。</p>\n</blockquote>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>在大学的时候养成的看电影的习惯，先去豆瓣网搜索下电影的评分怎么样，一半低于7分的电影会直接选择忽视掉，不看；所以我现一般在空闲的时候会不自觉的去找些符合自己品味的电影来看，记得以前看过一个电影<a href=\"https://movie.douban.com/subject/1293764/\" target=\"_blank\" rel=\"noopener\">《与狼共舞》</a>，被里面的场景给震撼住了，电影拍的蛮不错的，强烈推荐哦；<br>","more":"</p>\n<ul>\n<li><p><strong>背景介绍</strong></p>\n<blockquote>\n<p>现在回到今天的主题《维京：王者之战》。<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/%E7%BB%B4%E4%BA%AC%EF%BC%9A%E7%8E%8B%E8%80%85%E4%B9%8B%E6%88%98.png\" alt=\"维京：王者之战\"></p>\n</blockquote>\n</li>\n<li><p><strong>观影由来</strong></p>\n<blockquote>\n<p>在午休的时候无意间刷微博，看到这篇电影的简介，点进预告片，迎面给我带来的感受是“森林”、“皑皑大雪”、“猎手”、“野牛”、“斧头”等等这些工具，给人一种很强烈的视觉冲击，使得我对这部电影充满了期待，连夜把电影资源下载下来，电影时长两个多小时，然后就想着周末空闲的时候把电影看完,终于周五放假啦。。。</p>\n</blockquote>\n</li>\n<li><p><strong>观影感</strong></p>\n<blockquote>\n<p>电影总共是分为卫三段看完的，在整个观影过程中，除了电影在追逐野牛那段给我带了强烈的视觉的冲击，并未见其他的闪光点，电影的叙事过程比较拖拉，看完了整个电影后仍没有对整个电影的故事情节有一个完整的认识，我不知道是不是因为我看的过程断断续续导致的。其实看这部电影的时候我是把它拿来跟小李子的<img src=\"https://movie.douban.com/subject/5327268/\" alt=\"《荒野猎人》\">作为同一类型、级别的电影来比较的，故在看电影之前我都没有去看这部电影的豆瓣评分高不高；电影一直到结束我还未能理顺整个电影…</p>\n</blockquote>\n</li>\n<li><p><strong>总结</strong></p>\n<blockquote>\n<p><em>推荐指数：</em> ★★★<br>建议大家看电影之前先去查下豆瓣评分，作为一个大概的参考。</p>\n</blockquote>\n</li>\n</ul>"},{"title":"你好，武汉。","abbrlink":"cb6878a2","date":"2017-12-01T01:47:45.000Z","_content":"武汉的早晨仍是灰蒙蒙的，路边卖菜的叔叔阿姨依旧很早就在小区那条道道上开始摆摊卖菜了，路旁的施工工地正发出猛烈碰撞的声音，马路上轿车、电动车、共享单车争先恐后地行驶着。一切是那么的规规矩矩，一切又是那么的有井有条。\n<!-- more -->\n早上出门，骑上小黄车，到软件园路边的早餐店吃碗热干面，因为早餐店很小，所以一般我都是买了直接在路上吃，到公司楼下就正好吃完了，上楼到公司。\n\n最近几天天气也变冷了，骑着小黄车在路上，扶在车把上的手明显感觉寒风习习，武汉的房价还在节节攀升着，前几天跟几个同事一起聚餐，听他讲他家那块的房价都到24k/平了，回头想下自己的工资，此时的我只能用`革命尚未成功，同志仍需努力`来安慰自己。\n\n> 假如生活欺骗了你，\n不要悲伤，不要心急！\n忧郁的日子里须要镇静：\n相信吧，快乐的日子将会来临！\n心儿永远向往着未来；\n现在却常是忧郁。\n一切都是瞬息，一切都将会过去；\n而那过去了的，就会成为亲切的怀恋。\n\n我不曾到感觉生活欺骗了我，我只是被生活紧紧地压着，动弹不得。\n\n- **参考引用** \n[假如生活欺骗了你_普希金](https://baike.baidu.com/item/%E5%81%87%E5%A6%82%E7%94%9F%E6%B4%BB%E6%AC%BA%E9%AA%97%E4%BA%86%E4%BD%A0/75681?fr=aladdin)\n","source":"_posts/你好，武汉.md","raw":"---\ntitle: 你好，武汉。\ntags:\n  - 生活感想\nabbrlink: cb6878a2\ndate: 2017-12-01 09:47:45\n---\n武汉的早晨仍是灰蒙蒙的，路边卖菜的叔叔阿姨依旧很早就在小区那条道道上开始摆摊卖菜了，路旁的施工工地正发出猛烈碰撞的声音，马路上轿车、电动车、共享单车争先恐后地行驶着。一切是那么的规规矩矩，一切又是那么的有井有条。\n<!-- more -->\n早上出门，骑上小黄车，到软件园路边的早餐店吃碗热干面，因为早餐店很小，所以一般我都是买了直接在路上吃，到公司楼下就正好吃完了，上楼到公司。\n\n最近几天天气也变冷了，骑着小黄车在路上，扶在车把上的手明显感觉寒风习习，武汉的房价还在节节攀升着，前几天跟几个同事一起聚餐，听他讲他家那块的房价都到24k/平了，回头想下自己的工资，此时的我只能用`革命尚未成功，同志仍需努力`来安慰自己。\n\n> 假如生活欺骗了你，\n不要悲伤，不要心急！\n忧郁的日子里须要镇静：\n相信吧，快乐的日子将会来临！\n心儿永远向往着未来；\n现在却常是忧郁。\n一切都是瞬息，一切都将会过去；\n而那过去了的，就会成为亲切的怀恋。\n\n我不曾到感觉生活欺骗了我，我只是被生活紧紧地压着，动弹不得。\n\n- **参考引用** \n[假如生活欺骗了你_普希金](https://baike.baidu.com/item/%E5%81%87%E5%A6%82%E7%94%9F%E6%B4%BB%E6%AC%BA%E9%AA%97%E4%BA%86%E4%BD%A0/75681?fr=aladdin)\n","slug":"你好，武汉","published":1,"updated":"2017-12-14T13:55:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2w200xe0012mwd33i5cukck","content":"<p>武汉的早晨仍是灰蒙蒙的，路边卖菜的叔叔阿姨依旧很早就在小区那条道道上开始摆摊卖菜了，路旁的施工工地正发出猛烈碰撞的声音，马路上轿车、电动车、共享单车争先恐后地行驶着。一切是那么的规规矩矩，一切又是那么的有井有条。<br><a id=\"more\"></a><br>早上出门，骑上小黄车，到软件园路边的早餐店吃碗热干面，因为早餐店很小，所以一般我都是买了直接在路上吃，到公司楼下就正好吃完了，上楼到公司。</p>\n<p>最近几天天气也变冷了，骑着小黄车在路上，扶在车把上的手明显感觉寒风习习，武汉的房价还在节节攀升着，前几天跟几个同事一起聚餐，听他讲他家那块的房价都到24k/平了，回头想下自己的工资，此时的我只能用<code>革命尚未成功，同志仍需努力</code>来安慰自己。</p>\n<blockquote>\n<p>假如生活欺骗了你，<br>不要悲伤，不要心急！<br>忧郁的日子里须要镇静：<br>相信吧，快乐的日子将会来临！<br>心儿永远向往着未来；<br>现在却常是忧郁。<br>一切都是瞬息，一切都将会过去；<br>而那过去了的，就会成为亲切的怀恋。</p>\n</blockquote>\n<p>我不曾到感觉生活欺骗了我，我只是被生活紧紧地压着，动弹不得。</p>\n<ul>\n<li><strong>参考引用</strong><br><a href=\"https://baike.baidu.com/item/%E5%81%87%E5%A6%82%E7%94%9F%E6%B4%BB%E6%AC%BA%E9%AA%97%E4%BA%86%E4%BD%A0/75681?fr=aladdin\" target=\"_blank\" rel=\"noopener\">假如生活欺骗了你_普希金</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>武汉的早晨仍是灰蒙蒙的，路边卖菜的叔叔阿姨依旧很早就在小区那条道道上开始摆摊卖菜了，路旁的施工工地正发出猛烈碰撞的声音，马路上轿车、电动车、共享单车争先恐后地行驶着。一切是那么的规规矩矩，一切又是那么的有井有条。<br>","more":"<br>早上出门，骑上小黄车，到软件园路边的早餐店吃碗热干面，因为早餐店很小，所以一般我都是买了直接在路上吃，到公司楼下就正好吃完了，上楼到公司。</p>\n<p>最近几天天气也变冷了，骑着小黄车在路上，扶在车把上的手明显感觉寒风习习，武汉的房价还在节节攀升着，前几天跟几个同事一起聚餐，听他讲他家那块的房价都到24k/平了，回头想下自己的工资，此时的我只能用<code>革命尚未成功，同志仍需努力</code>来安慰自己。</p>\n<blockquote>\n<p>假如生活欺骗了你，<br>不要悲伤，不要心急！<br>忧郁的日子里须要镇静：<br>相信吧，快乐的日子将会来临！<br>心儿永远向往着未来；<br>现在却常是忧郁。<br>一切都是瞬息，一切都将会过去；<br>而那过去了的，就会成为亲切的怀恋。</p>\n</blockquote>\n<p>我不曾到感觉生活欺骗了我，我只是被生活紧紧地压着，动弹不得。</p>\n<ul>\n<li><strong>参考引用</strong><br><a href=\"https://baike.baidu.com/item/%E5%81%87%E5%A6%82%E7%94%9F%E6%B4%BB%E6%AC%BA%E9%AA%97%E4%BA%86%E4%BD%A0/75681?fr=aladdin\" target=\"_blank\" rel=\"noopener\">假如生活欺骗了你_普希金</a></li>\n</ul>"},{"title":"你应该知道的JAVA面试题","abbrlink":"d46124c7","date":"2017-11-29T14:16:55.000Z","_content":"> 如果你感到迷茫，请看看这些你都会吗？天比地高，脚踏实地，做一个务实的人，不要抱怨生活没给你带来什么，要思考你自己为了生活做了哪些努力和改变，DO THINGS BY HEART.\n<!-- more -->\n\n- **基础题目**\n    1. Java线程的状态\n    2. 进程和线程的区别，进程间如何通讯，线程间如何通讯\n    3. HashMap的数据结构是什么？如何实现的。和HashTable，ConcurrentHashMap的区别\n    4. Cookie和Session的区别\n    5. 索引有什么用？如何建索引？\n    6. ArrayList是如何实现的，ArrayList和LinkedList的区别？ArrayList如何实现扩容。\n    7. equals方法实现\n    8. 面向对象\n    9. 线程状态，BLOCKED和WAITING有什么区别\n    10. JVM如何加载字节码文件\n    11. JVM GC，GC算法。\n    12. 什么情况会出现Full GC，什么情况会出现yong GC。\n    13. JVM内存模型\n    14. Java运行时数据区\n    15. 事务的实现原理\n- **技术深度**\n    - 有没有看过JDK源码，看过的类实现原理是什么。\n    - HTTP协议\n    - TCP协议\n    - 一致性Hash算法\n    - JVM如何加载字节码文件\n    - 类加载器如何卸载字节码\n    - IO和NIO的区别，NIO优点\n    - Java线程池的实现原理，keepAliveTime等参数的作用。\n    - HTTP连接池实现原理\n    - 数据库连接池实现原理\n    - 数据库的实现原理\n- **技术框架**\n    - 看过哪些开源框架的源码\n    - 为什么要用Redis，Redis有哪些优缺点？Redis如何实现扩容？\n    - Netty是如何使用线程池的，为什么这么使用\n    - 为什么要使用Spring，Spring的优缺点有哪些\n    - Spring的IOC容器初始化流程\n    - Spring的IOC容器实现原理，为什么可以通过byName和ByType找到Bean\n    - Spring AOP实现原理\n    - 消息中间件是如何实现的，技术难点有哪些 \n- **系统架构**\n    - 如何搭建一个高可用系统\n    - 哪些设计模式可以增加系统的可扩展性\n    - 介绍设计模式，如模板模式，命令模式，策略模式，适配器模式、桥接模式、装饰模式，观察者模式，状态模式，访问者模式。\n    - 抽象能力，怎么提高研发效率。\n    - 什么是高内聚低耦合，请举例子如何实现\n    - 什么情况用接口，什么情况用消息\n    - 如果AB两个系统互相依赖，如何解除依赖\n    - 如何写一篇设计文档，目录是什么\n    - 什么场景应该拆分系统，什么场景应该合并系统\n    - 系统和模块的区别，分别在什么场景下使用\n- **分布式系统**\n    - 分布式事务，两阶段提交。\n    - 如何实现分布式锁\n    - 如何实现分布式Session\n    - 如何保证消息的一致性\n    - 负载均衡\n    - 正向代理（客户端代理）和反向代理（服务器端代理）\n    - CDN实现原理\n    - 怎么提升系统的QPS和吞吐量\n- **实战能力**\n    - 有没有处理过线上问题？出现内存泄露，CPU利用率标高，应用无响应时如何处理的。\n    - 开发中有没有遇到什么技术问题？如何解决的\n    - 如果有几十亿的白名单，每天白天需要高并发查询，晚上需要更新一次，如何设计这个功能。\n    - 新浪微博是如何实现把微博推给订阅者\n    - Google是如何在一秒内把搜索结果返回给用户的。\n    - 12306网站的订票系统如何实现，如何保证不会票不被超卖。\n    - 如何实现一个秒杀系统，保证只有几位用户能买到某件商品。\n- **软能力**\n    - 如何学习一项新技术，比如如何学习Java的，重点学习什么\n    - 有关注哪些新的技术\n    - 工作任务非常多非常杂时如何处理\n    - 项目出现延迟如何处理\n    - 和同事的设计思路不一样怎么处理\n    - 如何保证开发质量\n    - 职业规划是什么？短期，长期目标是什么\n    - 团队的规划是什么\n    - 能介绍下从工作到现在自己的成长在那里\n\n\n\n**引用参考文章：**\nhttp://ifeve.com/java-interview-question/","source":"_posts/你应该知道的JAVA面试题.md","raw":"---\ntitle: 你应该知道的JAVA面试题\ntags:\n  - JAVA\n  - 面试\nabbrlink: d46124c7\ndate: 2017-11-29 22:16:55\n---\n> 如果你感到迷茫，请看看这些你都会吗？天比地高，脚踏实地，做一个务实的人，不要抱怨生活没给你带来什么，要思考你自己为了生活做了哪些努力和改变，DO THINGS BY HEART.\n<!-- more -->\n\n- **基础题目**\n    1. Java线程的状态\n    2. 进程和线程的区别，进程间如何通讯，线程间如何通讯\n    3. HashMap的数据结构是什么？如何实现的。和HashTable，ConcurrentHashMap的区别\n    4. Cookie和Session的区别\n    5. 索引有什么用？如何建索引？\n    6. ArrayList是如何实现的，ArrayList和LinkedList的区别？ArrayList如何实现扩容。\n    7. equals方法实现\n    8. 面向对象\n    9. 线程状态，BLOCKED和WAITING有什么区别\n    10. JVM如何加载字节码文件\n    11. JVM GC，GC算法。\n    12. 什么情况会出现Full GC，什么情况会出现yong GC。\n    13. JVM内存模型\n    14. Java运行时数据区\n    15. 事务的实现原理\n- **技术深度**\n    - 有没有看过JDK源码，看过的类实现原理是什么。\n    - HTTP协议\n    - TCP协议\n    - 一致性Hash算法\n    - JVM如何加载字节码文件\n    - 类加载器如何卸载字节码\n    - IO和NIO的区别，NIO优点\n    - Java线程池的实现原理，keepAliveTime等参数的作用。\n    - HTTP连接池实现原理\n    - 数据库连接池实现原理\n    - 数据库的实现原理\n- **技术框架**\n    - 看过哪些开源框架的源码\n    - 为什么要用Redis，Redis有哪些优缺点？Redis如何实现扩容？\n    - Netty是如何使用线程池的，为什么这么使用\n    - 为什么要使用Spring，Spring的优缺点有哪些\n    - Spring的IOC容器初始化流程\n    - Spring的IOC容器实现原理，为什么可以通过byName和ByType找到Bean\n    - Spring AOP实现原理\n    - 消息中间件是如何实现的，技术难点有哪些 \n- **系统架构**\n    - 如何搭建一个高可用系统\n    - 哪些设计模式可以增加系统的可扩展性\n    - 介绍设计模式，如模板模式，命令模式，策略模式，适配器模式、桥接模式、装饰模式，观察者模式，状态模式，访问者模式。\n    - 抽象能力，怎么提高研发效率。\n    - 什么是高内聚低耦合，请举例子如何实现\n    - 什么情况用接口，什么情况用消息\n    - 如果AB两个系统互相依赖，如何解除依赖\n    - 如何写一篇设计文档，目录是什么\n    - 什么场景应该拆分系统，什么场景应该合并系统\n    - 系统和模块的区别，分别在什么场景下使用\n- **分布式系统**\n    - 分布式事务，两阶段提交。\n    - 如何实现分布式锁\n    - 如何实现分布式Session\n    - 如何保证消息的一致性\n    - 负载均衡\n    - 正向代理（客户端代理）和反向代理（服务器端代理）\n    - CDN实现原理\n    - 怎么提升系统的QPS和吞吐量\n- **实战能力**\n    - 有没有处理过线上问题？出现内存泄露，CPU利用率标高，应用无响应时如何处理的。\n    - 开发中有没有遇到什么技术问题？如何解决的\n    - 如果有几十亿的白名单，每天白天需要高并发查询，晚上需要更新一次，如何设计这个功能。\n    - 新浪微博是如何实现把微博推给订阅者\n    - Google是如何在一秒内把搜索结果返回给用户的。\n    - 12306网站的订票系统如何实现，如何保证不会票不被超卖。\n    - 如何实现一个秒杀系统，保证只有几位用户能买到某件商品。\n- **软能力**\n    - 如何学习一项新技术，比如如何学习Java的，重点学习什么\n    - 有关注哪些新的技术\n    - 工作任务非常多非常杂时如何处理\n    - 项目出现延迟如何处理\n    - 和同事的设计思路不一样怎么处理\n    - 如何保证开发质量\n    - 职业规划是什么？短期，长期目标是什么\n    - 团队的规划是什么\n    - 能介绍下从工作到现在自己的成长在那里\n\n\n\n**引用参考文章：**\nhttp://ifeve.com/java-interview-question/","slug":"你应该知道的JAVA面试题","published":1,"updated":"2017-12-14T13:55:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2w200xk0014mwd3eg71a7ip","content":"<blockquote>\n<p>如果你感到迷茫，请看看这些你都会吗？天比地高，脚踏实地，做一个务实的人，不要抱怨生活没给你带来什么，要思考你自己为了生活做了哪些努力和改变，DO THINGS BY HEART.<br><a id=\"more\"></a></p>\n</blockquote>\n<ul>\n<li><strong>基础题目</strong><ol>\n<li>Java线程的状态</li>\n<li>进程和线程的区别，进程间如何通讯，线程间如何通讯</li>\n<li>HashMap的数据结构是什么？如何实现的。和HashTable，ConcurrentHashMap的区别</li>\n<li>Cookie和Session的区别</li>\n<li>索引有什么用？如何建索引？</li>\n<li>ArrayList是如何实现的，ArrayList和LinkedList的区别？ArrayList如何实现扩容。</li>\n<li>equals方法实现</li>\n<li>面向对象</li>\n<li>线程状态，BLOCKED和WAITING有什么区别</li>\n<li>JVM如何加载字节码文件</li>\n<li>JVM GC，GC算法。</li>\n<li>什么情况会出现Full GC，什么情况会出现yong GC。</li>\n<li>JVM内存模型</li>\n<li>Java运行时数据区</li>\n<li>事务的实现原理</li>\n</ol>\n</li>\n<li><strong>技术深度</strong><ul>\n<li>有没有看过JDK源码，看过的类实现原理是什么。</li>\n<li>HTTP协议</li>\n<li>TCP协议</li>\n<li>一致性Hash算法</li>\n<li>JVM如何加载字节码文件</li>\n<li>类加载器如何卸载字节码</li>\n<li>IO和NIO的区别，NIO优点</li>\n<li>Java线程池的实现原理，keepAliveTime等参数的作用。</li>\n<li>HTTP连接池实现原理</li>\n<li>数据库连接池实现原理</li>\n<li>数据库的实现原理</li>\n</ul>\n</li>\n<li><strong>技术框架</strong><ul>\n<li>看过哪些开源框架的源码</li>\n<li>为什么要用Redis，Redis有哪些优缺点？Redis如何实现扩容？</li>\n<li>Netty是如何使用线程池的，为什么这么使用</li>\n<li>为什么要使用Spring，Spring的优缺点有哪些</li>\n<li>Spring的IOC容器初始化流程</li>\n<li>Spring的IOC容器实现原理，为什么可以通过byName和ByType找到Bean</li>\n<li>Spring AOP实现原理</li>\n<li>消息中间件是如何实现的，技术难点有哪些 </li>\n</ul>\n</li>\n<li><strong>系统架构</strong><ul>\n<li>如何搭建一个高可用系统</li>\n<li>哪些设计模式可以增加系统的可扩展性</li>\n<li>介绍设计模式，如模板模式，命令模式，策略模式，适配器模式、桥接模式、装饰模式，观察者模式，状态模式，访问者模式。</li>\n<li>抽象能力，怎么提高研发效率。</li>\n<li>什么是高内聚低耦合，请举例子如何实现</li>\n<li>什么情况用接口，什么情况用消息</li>\n<li>如果AB两个系统互相依赖，如何解除依赖</li>\n<li>如何写一篇设计文档，目录是什么</li>\n<li>什么场景应该拆分系统，什么场景应该合并系统</li>\n<li>系统和模块的区别，分别在什么场景下使用</li>\n</ul>\n</li>\n<li><strong>分布式系统</strong><ul>\n<li>分布式事务，两阶段提交。</li>\n<li>如何实现分布式锁</li>\n<li>如何实现分布式Session</li>\n<li>如何保证消息的一致性</li>\n<li>负载均衡</li>\n<li>正向代理（客户端代理）和反向代理（服务器端代理）</li>\n<li>CDN实现原理</li>\n<li>怎么提升系统的QPS和吞吐量</li>\n</ul>\n</li>\n<li><strong>实战能力</strong><ul>\n<li>有没有处理过线上问题？出现内存泄露，CPU利用率标高，应用无响应时如何处理的。</li>\n<li>开发中有没有遇到什么技术问题？如何解决的</li>\n<li>如果有几十亿的白名单，每天白天需要高并发查询，晚上需要更新一次，如何设计这个功能。</li>\n<li>新浪微博是如何实现把微博推给订阅者</li>\n<li>Google是如何在一秒内把搜索结果返回给用户的。</li>\n<li>12306网站的订票系统如何实现，如何保证不会票不被超卖。</li>\n<li>如何实现一个秒杀系统，保证只有几位用户能买到某件商品。</li>\n</ul>\n</li>\n<li><strong>软能力</strong><ul>\n<li>如何学习一项新技术，比如如何学习Java的，重点学习什么</li>\n<li>有关注哪些新的技术</li>\n<li>工作任务非常多非常杂时如何处理</li>\n<li>项目出现延迟如何处理</li>\n<li>和同事的设计思路不一样怎么处理</li>\n<li>如何保证开发质量</li>\n<li>职业规划是什么？短期，长期目标是什么</li>\n<li>团队的规划是什么</li>\n<li>能介绍下从工作到现在自己的成长在那里</li>\n</ul>\n</li>\n</ul>\n<p><strong>引用参考文章：</strong><br><a href=\"http://ifeve.com/java-interview-question/\" target=\"_blank\" rel=\"noopener\">http://ifeve.com/java-interview-question/</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>如果你感到迷茫，请看看这些你都会吗？天比地高，脚踏实地，做一个务实的人，不要抱怨生活没给你带来什么，要思考你自己为了生活做了哪些努力和改变，DO THINGS BY HEART.<br>","more":"</p>\n</blockquote>\n<ul>\n<li><strong>基础题目</strong><ol>\n<li>Java线程的状态</li>\n<li>进程和线程的区别，进程间如何通讯，线程间如何通讯</li>\n<li>HashMap的数据结构是什么？如何实现的。和HashTable，ConcurrentHashMap的区别</li>\n<li>Cookie和Session的区别</li>\n<li>索引有什么用？如何建索引？</li>\n<li>ArrayList是如何实现的，ArrayList和LinkedList的区别？ArrayList如何实现扩容。</li>\n<li>equals方法实现</li>\n<li>面向对象</li>\n<li>线程状态，BLOCKED和WAITING有什么区别</li>\n<li>JVM如何加载字节码文件</li>\n<li>JVM GC，GC算法。</li>\n<li>什么情况会出现Full GC，什么情况会出现yong GC。</li>\n<li>JVM内存模型</li>\n<li>Java运行时数据区</li>\n<li>事务的实现原理</li>\n</ol>\n</li>\n<li><strong>技术深度</strong><ul>\n<li>有没有看过JDK源码，看过的类实现原理是什么。</li>\n<li>HTTP协议</li>\n<li>TCP协议</li>\n<li>一致性Hash算法</li>\n<li>JVM如何加载字节码文件</li>\n<li>类加载器如何卸载字节码</li>\n<li>IO和NIO的区别，NIO优点</li>\n<li>Java线程池的实现原理，keepAliveTime等参数的作用。</li>\n<li>HTTP连接池实现原理</li>\n<li>数据库连接池实现原理</li>\n<li>数据库的实现原理</li>\n</ul>\n</li>\n<li><strong>技术框架</strong><ul>\n<li>看过哪些开源框架的源码</li>\n<li>为什么要用Redis，Redis有哪些优缺点？Redis如何实现扩容？</li>\n<li>Netty是如何使用线程池的，为什么这么使用</li>\n<li>为什么要使用Spring，Spring的优缺点有哪些</li>\n<li>Spring的IOC容器初始化流程</li>\n<li>Spring的IOC容器实现原理，为什么可以通过byName和ByType找到Bean</li>\n<li>Spring AOP实现原理</li>\n<li>消息中间件是如何实现的，技术难点有哪些 </li>\n</ul>\n</li>\n<li><strong>系统架构</strong><ul>\n<li>如何搭建一个高可用系统</li>\n<li>哪些设计模式可以增加系统的可扩展性</li>\n<li>介绍设计模式，如模板模式，命令模式，策略模式，适配器模式、桥接模式、装饰模式，观察者模式，状态模式，访问者模式。</li>\n<li>抽象能力，怎么提高研发效率。</li>\n<li>什么是高内聚低耦合，请举例子如何实现</li>\n<li>什么情况用接口，什么情况用消息</li>\n<li>如果AB两个系统互相依赖，如何解除依赖</li>\n<li>如何写一篇设计文档，目录是什么</li>\n<li>什么场景应该拆分系统，什么场景应该合并系统</li>\n<li>系统和模块的区别，分别在什么场景下使用</li>\n</ul>\n</li>\n<li><strong>分布式系统</strong><ul>\n<li>分布式事务，两阶段提交。</li>\n<li>如何实现分布式锁</li>\n<li>如何实现分布式Session</li>\n<li>如何保证消息的一致性</li>\n<li>负载均衡</li>\n<li>正向代理（客户端代理）和反向代理（服务器端代理）</li>\n<li>CDN实现原理</li>\n<li>怎么提升系统的QPS和吞吐量</li>\n</ul>\n</li>\n<li><strong>实战能力</strong><ul>\n<li>有没有处理过线上问题？出现内存泄露，CPU利用率标高，应用无响应时如何处理的。</li>\n<li>开发中有没有遇到什么技术问题？如何解决的</li>\n<li>如果有几十亿的白名单，每天白天需要高并发查询，晚上需要更新一次，如何设计这个功能。</li>\n<li>新浪微博是如何实现把微博推给订阅者</li>\n<li>Google是如何在一秒内把搜索结果返回给用户的。</li>\n<li>12306网站的订票系统如何实现，如何保证不会票不被超卖。</li>\n<li>如何实现一个秒杀系统，保证只有几位用户能买到某件商品。</li>\n</ul>\n</li>\n<li><strong>软能力</strong><ul>\n<li>如何学习一项新技术，比如如何学习Java的，重点学习什么</li>\n<li>有关注哪些新的技术</li>\n<li>工作任务非常多非常杂时如何处理</li>\n<li>项目出现延迟如何处理</li>\n<li>和同事的设计思路不一样怎么处理</li>\n<li>如何保证开发质量</li>\n<li>职业规划是什么？短期，长期目标是什么</li>\n<li>团队的规划是什么</li>\n<li>能介绍下从工作到现在自己的成长在那里</li>\n</ul>\n</li>\n</ul>\n<p><strong>引用参考文章：</strong><br><a href=\"http://ifeve.com/java-interview-question/\" target=\"_blank\" rel=\"noopener\">http://ifeve.com/java-interview-question/</a></p>"},{"title":"使用Nginx和Tomcat来搭建高性能负载均衡集群","abbrlink":"b7aae4ad-nginx-tomcat-cluster","date":"2018-02-23T11:00:02.000Z","_content":"\nNginx (engine x) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的。\n<!-- more -->\n### 一、准备工作。\n\n下载`nginx`和`tomcat`包。请下载对应你的操作系统的包。\n- [nginx下载](http://nginx.org/en/download.html)\n- [tomcat下载](http://tomcat.apache.org/download-70.cgi)\n\n### 二、实现目标。\n\n实现高性能负载均衡的Tomcat集群：\n![](http://ozux0lqfa.bkt.clouddn.com/nginx&&tomcat%E9%9B%86%E7%BE%A4.png)\n\n### 三、实现步骤\n- 把解压的tomcat复制两份，如下图所示\n![解压目录图](http://ozux0lqfa.bkt.clouddn.com/tomcat%E4%B8%8Enginx%E8%A7%A3%E5%8E%8B%E5%9B%BE.png)\n- 把`nginx`包也解压出来。\n为了便于管理，把tomcat的与nginx放在同一文件夹目录下。\n- 分别修改两个tomcat服务器的端口，避免端口冲突，从而使得两个`tomcat`顺利启动，以下举例修改第一个`tomcat`的端口；打开`conf\\server.xml`,修改以下端口。\n```\n1、\n<Server port=\"8005\" shutdown=\"SHUTDOWN\">\n改成：\n<Server port=\"18005\" shutdown=\"SHUTDOWN\">\n\n2、\n<Connector port=\"8080\" protocol=\"HTTP/1.1\"\n               connectionTimeout=\"20000\"\n               redirectPort=\"8443\" />\n改成：\n<Connector port=\"18080\" protocol=\"HTTP/1.1\"\n               connectionTimeout=\"20000\"\n               redirectPort=\"8443\" />\n\n3、\n<Connector port=\"8009\" protocol=\"AJP/1.3\" redirectPort=\"8443\" />\n改成：\n<Connector port=\"18009\" protocol=\"AJP/1.3\" redirectPort=\"8443\" />\n```\n![](http://ozux0lqfa.bkt.clouddn.com/%E4%BF%AE%E6%94%B9tomcat%E7%9A%84%E6%AC%A2%E8%BF%8E%E9%A1%B5.png)\n至此两个`tomcat`顺利启动起来。\n\n- 下面开始修改nginx的配置文件。打开`nginx-1.10.3\\conf\\nginx.conf`文件。\n\n```\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    \n    # 服务器的集群\n    upstream sdll.club { #服务器集群的名字： sdll.club\n\t\t# 集群的服务器列表，weight是权重的意思，值越大，分配的概率越大。\n\t\tserver\t127.0.0.1:18080\tweight=1;\n\t\tserver\t127.0.0.1:28080\tweight=2;\n\t}\n\n    server {\n        listen       9000; #监听端口，可以改成其他端口。\n        server_name  localhost; #当前服务的主机\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n\n        # location / {\n        #    root   html;\n        #    index  index.html index.htm;\n        # }\n\t\t\n\t\tlocation / {\n            proxy_pass   http://sdll.club; #这里的值要与服务器集群的值一样\n            proxy_redirect  default;\n        }\n        \n```\n- 启动`nginx`。\n\n在nginx目录下输入命令`start nginx`,启动`nginx`，紧接着在浏览器中输入`localhost:9000/index.jsp`，如下结果。\n![](http://ozux0lqfa.bkt.clouddn.com/nginx%E9%9B%86%E7%BE%A4%E6%B5%8B%E8%AF%95.png)\n不停的刷新页面，页面会在**Home 11**和**Home 22**切换中，随着访问次数的增加，**Home 22**出现的次数与**Home 11**出现次数的之比接近为**2:1**，这是因为权重起作用了。\n```\nupstream sdll.club {\n\t# 集群服务器列表，最终请求会被转发到这里来。\n\tserver\t127.0.0.1:18080\tweight=1;\n\tserver\t127.0.0.1:28080\tweight=2;\n}\n```\n### 四、总结\n至此，整个步骤结束。\n\n**参考引用：**\nhttp://blog.csdn.net/xlgen157387/article/details/49781487","source":"_posts/使用Nginx和Tomcat来搭建高性能负载均衡集群.md","raw":"---\ntitle: 使用Nginx和Tomcat来搭建高性能负载均衡集群\nabbrlink: b7aae4ad-nginx-tomcat-cluster\ndate: 2018-02-23 19:00:02\ntags: [JAVA,Tomcat,nginx]\n---\n\nNginx (engine x) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的。\n<!-- more -->\n### 一、准备工作。\n\n下载`nginx`和`tomcat`包。请下载对应你的操作系统的包。\n- [nginx下载](http://nginx.org/en/download.html)\n- [tomcat下载](http://tomcat.apache.org/download-70.cgi)\n\n### 二、实现目标。\n\n实现高性能负载均衡的Tomcat集群：\n![](http://ozux0lqfa.bkt.clouddn.com/nginx&&tomcat%E9%9B%86%E7%BE%A4.png)\n\n### 三、实现步骤\n- 把解压的tomcat复制两份，如下图所示\n![解压目录图](http://ozux0lqfa.bkt.clouddn.com/tomcat%E4%B8%8Enginx%E8%A7%A3%E5%8E%8B%E5%9B%BE.png)\n- 把`nginx`包也解压出来。\n为了便于管理，把tomcat的与nginx放在同一文件夹目录下。\n- 分别修改两个tomcat服务器的端口，避免端口冲突，从而使得两个`tomcat`顺利启动，以下举例修改第一个`tomcat`的端口；打开`conf\\server.xml`,修改以下端口。\n```\n1、\n<Server port=\"8005\" shutdown=\"SHUTDOWN\">\n改成：\n<Server port=\"18005\" shutdown=\"SHUTDOWN\">\n\n2、\n<Connector port=\"8080\" protocol=\"HTTP/1.1\"\n               connectionTimeout=\"20000\"\n               redirectPort=\"8443\" />\n改成：\n<Connector port=\"18080\" protocol=\"HTTP/1.1\"\n               connectionTimeout=\"20000\"\n               redirectPort=\"8443\" />\n\n3、\n<Connector port=\"8009\" protocol=\"AJP/1.3\" redirectPort=\"8443\" />\n改成：\n<Connector port=\"18009\" protocol=\"AJP/1.3\" redirectPort=\"8443\" />\n```\n![](http://ozux0lqfa.bkt.clouddn.com/%E4%BF%AE%E6%94%B9tomcat%E7%9A%84%E6%AC%A2%E8%BF%8E%E9%A1%B5.png)\n至此两个`tomcat`顺利启动起来。\n\n- 下面开始修改nginx的配置文件。打开`nginx-1.10.3\\conf\\nginx.conf`文件。\n\n```\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    \n    # 服务器的集群\n    upstream sdll.club { #服务器集群的名字： sdll.club\n\t\t# 集群的服务器列表，weight是权重的意思，值越大，分配的概率越大。\n\t\tserver\t127.0.0.1:18080\tweight=1;\n\t\tserver\t127.0.0.1:28080\tweight=2;\n\t}\n\n    server {\n        listen       9000; #监听端口，可以改成其他端口。\n        server_name  localhost; #当前服务的主机\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n\n        # location / {\n        #    root   html;\n        #    index  index.html index.htm;\n        # }\n\t\t\n\t\tlocation / {\n            proxy_pass   http://sdll.club; #这里的值要与服务器集群的值一样\n            proxy_redirect  default;\n        }\n        \n```\n- 启动`nginx`。\n\n在nginx目录下输入命令`start nginx`,启动`nginx`，紧接着在浏览器中输入`localhost:9000/index.jsp`，如下结果。\n![](http://ozux0lqfa.bkt.clouddn.com/nginx%E9%9B%86%E7%BE%A4%E6%B5%8B%E8%AF%95.png)\n不停的刷新页面，页面会在**Home 11**和**Home 22**切换中，随着访问次数的增加，**Home 22**出现的次数与**Home 11**出现次数的之比接近为**2:1**，这是因为权重起作用了。\n```\nupstream sdll.club {\n\t# 集群服务器列表，最终请求会被转发到这里来。\n\tserver\t127.0.0.1:18080\tweight=1;\n\tserver\t127.0.0.1:28080\tweight=2;\n}\n```\n### 四、总结\n至此，整个步骤结束。\n\n**参考引用：**\nhttp://blog.csdn.net/xlgen157387/article/details/49781487","slug":"使用Nginx和Tomcat来搭建高性能负载均衡集群","published":1,"updated":"2018-02-23T03:07:48.736Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2w200xp0016mwd357y5n4zo","content":"<p>Nginx (engine x) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的。<br><a id=\"more\"></a></p>\n<h3 id=\"一、准备工作。\"><a href=\"#一、准备工作。\" class=\"headerlink\" title=\"一、准备工作。\"></a>一、准备工作。</h3><p>下载<code>nginx</code>和<code>tomcat</code>包。请下载对应你的操作系统的包。</p>\n<ul>\n<li><a href=\"http://nginx.org/en/download.html\" target=\"_blank\" rel=\"noopener\">nginx下载</a></li>\n<li><a href=\"http://tomcat.apache.org/download-70.cgi\" target=\"_blank\" rel=\"noopener\">tomcat下载</a></li>\n</ul>\n<h3 id=\"二、实现目标。\"><a href=\"#二、实现目标。\" class=\"headerlink\" title=\"二、实现目标。\"></a>二、实现目标。</h3><p>实现高性能负载均衡的Tomcat集群：<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/nginx&amp;&amp;tomcat%E9%9B%86%E7%BE%A4.png\" alt=\"\"></p>\n<h3 id=\"三、实现步骤\"><a href=\"#三、实现步骤\" class=\"headerlink\" title=\"三、实现步骤\"></a>三、实现步骤</h3><ul>\n<li>把解压的tomcat复制两份，如下图所示<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/tomcat%E4%B8%8Enginx%E8%A7%A3%E5%8E%8B%E5%9B%BE.png\" alt=\"解压目录图\"></li>\n<li>把<code>nginx</code>包也解压出来。<br>为了便于管理，把tomcat的与nginx放在同一文件夹目录下。</li>\n<li>分别修改两个tomcat服务器的端口，避免端口冲突，从而使得两个<code>tomcat</code>顺利启动，以下举例修改第一个<code>tomcat</code>的端口；打开<code>conf\\server.xml</code>,修改以下端口。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、</span><br><span class=\"line\">&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</span><br><span class=\"line\">改成：</span><br><span class=\"line\">&lt;Server port=&quot;18005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">2、</span><br><span class=\"line\">&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</span><br><span class=\"line\">               connectionTimeout=&quot;20000&quot;</span><br><span class=\"line\">               redirectPort=&quot;8443&quot; /&gt;</span><br><span class=\"line\">改成：</span><br><span class=\"line\">&lt;Connector port=&quot;18080&quot; protocol=&quot;HTTP/1.1&quot;</span><br><span class=\"line\">               connectionTimeout=&quot;20000&quot;</span><br><span class=\"line\">               redirectPort=&quot;8443&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">3、</span><br><span class=\"line\">&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</span><br><span class=\"line\">改成：</span><br><span class=\"line\">&lt;Connector port=&quot;18009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"http://ozux0lqfa.bkt.clouddn.com/%E4%BF%AE%E6%94%B9tomcat%E7%9A%84%E6%AC%A2%E8%BF%8E%E9%A1%B5.png\" alt=\"\"><br>至此两个<code>tomcat</code>顺利启动起来。</p>\n<ul>\n<li>下面开始修改nginx的配置文件。打开<code>nginx-1.10.3\\conf\\nginx.conf</code>文件。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http &#123;</span><br><span class=\"line\">    include       mime.types;</span><br><span class=\"line\">    default_type  application/octet-stream;</span><br><span class=\"line\">    </span><br><span class=\"line\">    # 服务器的集群</span><br><span class=\"line\">    upstream sdll.club &#123; #服务器集群的名字： sdll.club</span><br><span class=\"line\">\t\t# 集群的服务器列表，weight是权重的意思，值越大，分配的概率越大。</span><br><span class=\"line\">\t\tserver\t127.0.0.1:18080\tweight=1;</span><br><span class=\"line\">\t\tserver\t127.0.0.1:28080\tweight=2;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen       9000; #监听端口，可以改成其他端口。</span><br><span class=\"line\">        server_name  localhost; #当前服务的主机</span><br><span class=\"line\"></span><br><span class=\"line\">        #charset koi8-r;</span><br><span class=\"line\"></span><br><span class=\"line\">        #access_log  logs/host.access.log  main;</span><br><span class=\"line\"></span><br><span class=\"line\">        # location / &#123;</span><br><span class=\"line\">        #    root   html;</span><br><span class=\"line\">        #    index  index.html index.htm;</span><br><span class=\"line\">        # &#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tlocation / &#123;</span><br><span class=\"line\">            proxy_pass   http://sdll.club; #这里的值要与服务器集群的值一样</span><br><span class=\"line\">            proxy_redirect  default;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>启动<code>nginx</code>。</li>\n</ul>\n<p>在nginx目录下输入命令<code>start nginx</code>,启动<code>nginx</code>，紧接着在浏览器中输入<code>localhost:9000/index.jsp</code>，如下结果。<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/nginx%E9%9B%86%E7%BE%A4%E6%B5%8B%E8%AF%95.png\" alt=\"\"><br>不停的刷新页面，页面会在<strong>Home 11</strong>和<strong>Home 22</strong>切换中，随着访问次数的增加，<strong>Home 22</strong>出现的次数与<strong>Home 11</strong>出现次数的之比接近为<strong>2:1</strong>，这是因为权重起作用了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream sdll.club &#123;</span><br><span class=\"line\">\t# 集群服务器列表，最终请求会被转发到这里来。</span><br><span class=\"line\">\tserver\t127.0.0.1:18080\tweight=1;</span><br><span class=\"line\">\tserver\t127.0.0.1:28080\tweight=2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h3><p>至此，整个步骤结束。</p>\n<p><strong>参考引用：</strong><br><a href=\"http://blog.csdn.net/xlgen157387/article/details/49781487\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/xlgen157387/article/details/49781487</a></p>\n","site":{"data":{}},"excerpt":"<p>Nginx (engine x) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的。<br>","more":"</p>\n<h3 id=\"一、准备工作。\"><a href=\"#一、准备工作。\" class=\"headerlink\" title=\"一、准备工作。\"></a>一、准备工作。</h3><p>下载<code>nginx</code>和<code>tomcat</code>包。请下载对应你的操作系统的包。</p>\n<ul>\n<li><a href=\"http://nginx.org/en/download.html\" target=\"_blank\" rel=\"noopener\">nginx下载</a></li>\n<li><a href=\"http://tomcat.apache.org/download-70.cgi\" target=\"_blank\" rel=\"noopener\">tomcat下载</a></li>\n</ul>\n<h3 id=\"二、实现目标。\"><a href=\"#二、实现目标。\" class=\"headerlink\" title=\"二、实现目标。\"></a>二、实现目标。</h3><p>实现高性能负载均衡的Tomcat集群：<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/nginx&amp;&amp;tomcat%E9%9B%86%E7%BE%A4.png\" alt=\"\"></p>\n<h3 id=\"三、实现步骤\"><a href=\"#三、实现步骤\" class=\"headerlink\" title=\"三、实现步骤\"></a>三、实现步骤</h3><ul>\n<li>把解压的tomcat复制两份，如下图所示<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/tomcat%E4%B8%8Enginx%E8%A7%A3%E5%8E%8B%E5%9B%BE.png\" alt=\"解压目录图\"></li>\n<li>把<code>nginx</code>包也解压出来。<br>为了便于管理，把tomcat的与nginx放在同一文件夹目录下。</li>\n<li>分别修改两个tomcat服务器的端口，避免端口冲突，从而使得两个<code>tomcat</code>顺利启动，以下举例修改第一个<code>tomcat</code>的端口；打开<code>conf\\server.xml</code>,修改以下端口。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、</span><br><span class=\"line\">&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</span><br><span class=\"line\">改成：</span><br><span class=\"line\">&lt;Server port=&quot;18005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">2、</span><br><span class=\"line\">&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</span><br><span class=\"line\">               connectionTimeout=&quot;20000&quot;</span><br><span class=\"line\">               redirectPort=&quot;8443&quot; /&gt;</span><br><span class=\"line\">改成：</span><br><span class=\"line\">&lt;Connector port=&quot;18080&quot; protocol=&quot;HTTP/1.1&quot;</span><br><span class=\"line\">               connectionTimeout=&quot;20000&quot;</span><br><span class=\"line\">               redirectPort=&quot;8443&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">3、</span><br><span class=\"line\">&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</span><br><span class=\"line\">改成：</span><br><span class=\"line\">&lt;Connector port=&quot;18009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"http://ozux0lqfa.bkt.clouddn.com/%E4%BF%AE%E6%94%B9tomcat%E7%9A%84%E6%AC%A2%E8%BF%8E%E9%A1%B5.png\" alt=\"\"><br>至此两个<code>tomcat</code>顺利启动起来。</p>\n<ul>\n<li>下面开始修改nginx的配置文件。打开<code>nginx-1.10.3\\conf\\nginx.conf</code>文件。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http &#123;</span><br><span class=\"line\">    include       mime.types;</span><br><span class=\"line\">    default_type  application/octet-stream;</span><br><span class=\"line\">    </span><br><span class=\"line\">    # 服务器的集群</span><br><span class=\"line\">    upstream sdll.club &#123; #服务器集群的名字： sdll.club</span><br><span class=\"line\">\t\t# 集群的服务器列表，weight是权重的意思，值越大，分配的概率越大。</span><br><span class=\"line\">\t\tserver\t127.0.0.1:18080\tweight=1;</span><br><span class=\"line\">\t\tserver\t127.0.0.1:28080\tweight=2;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen       9000; #监听端口，可以改成其他端口。</span><br><span class=\"line\">        server_name  localhost; #当前服务的主机</span><br><span class=\"line\"></span><br><span class=\"line\">        #charset koi8-r;</span><br><span class=\"line\"></span><br><span class=\"line\">        #access_log  logs/host.access.log  main;</span><br><span class=\"line\"></span><br><span class=\"line\">        # location / &#123;</span><br><span class=\"line\">        #    root   html;</span><br><span class=\"line\">        #    index  index.html index.htm;</span><br><span class=\"line\">        # &#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tlocation / &#123;</span><br><span class=\"line\">            proxy_pass   http://sdll.club; #这里的值要与服务器集群的值一样</span><br><span class=\"line\">            proxy_redirect  default;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>启动<code>nginx</code>。</li>\n</ul>\n<p>在nginx目录下输入命令<code>start nginx</code>,启动<code>nginx</code>，紧接着在浏览器中输入<code>localhost:9000/index.jsp</code>，如下结果。<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/nginx%E9%9B%86%E7%BE%A4%E6%B5%8B%E8%AF%95.png\" alt=\"\"><br>不停的刷新页面，页面会在<strong>Home 11</strong>和<strong>Home 22</strong>切换中，随着访问次数的增加，<strong>Home 22</strong>出现的次数与<strong>Home 11</strong>出现次数的之比接近为<strong>2:1</strong>，这是因为权重起作用了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream sdll.club &#123;</span><br><span class=\"line\">\t# 集群服务器列表，最终请求会被转发到这里来。</span><br><span class=\"line\">\tserver\t127.0.0.1:18080\tweight=1;</span><br><span class=\"line\">\tserver\t127.0.0.1:28080\tweight=2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h3><p>至此，整个步骤结束。</p>\n<p><strong>参考引用：</strong><br><a href=\"http://blog.csdn.net/xlgen157387/article/details/49781487\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/xlgen157387/article/details/49781487</a></p>"},{"title":"在Linux环境下部署java web项目","abbrlink":"d54218b1","date":"2017-12-12T14:13:39.000Z","_content":"\n由于项目需要，最近开发的这个项目的部署工作由我们开发自己来完成，因为项目是部署在Linux环境中，对我来说说还是蛮有吸引力的，之前开发都是在windows环境中完成的，还没有体验过真正项目的部署过程；下面开始记录部署的整个过程。\n<!-- more -->\n### 一、安装jdk\n- 解压jdk安装包\n下载linux环境对应的jdk安装包，[jdk下载地址](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html),大家选择对应自己电脑的版本下载，这个就不多讲了；下载好了之后解压安装包\n```\ntar -zxvf jdk-8u151-linux-x64.tar.gz -C /usr/local/java/\n```\n此处把jdk压缩包解压到指定目录`/usr/local/java/`中\n- 配置环境变量\n\n\n\n### 二、安装zookeeper\n- 首先下载zookeeper的稳定版本。[zookeeper-3.4.10.tar.gz stable版本下载](http://mirrors.hust.edu.cn/apache/zookeeper/stable/)\n- 解压压缩包\n```\ntar -zxvf zookeeper-3.4.10.tar.gz\n```\n- 把conf目录下的zoo_sample.cfg复制一份,并命名为zoo.cfg\n`cp zoo_sample.cfg zoo.cfg`\n- 修改zoo.cfg配置文件，此处是单机版zookeeper配置。\n```\ndataDir=/datatmp/zookeeper/data\ndataLogDir=/datatmp/zookeeper/logs\n```\n保存。如果在对应文件夹`data`、`logs`不存在，请自己在对应的路径下新建。\n- 在/etc/profile文件中设置PATH\n修改profile文件：`vi /etc/profile`，在文件末尾加入\n```\nexport ZOOKEEPER_INSTALL=/usr/local/zookeeper/zookeeper-3.4.10/\nexport PATH=$PATH:$ZOOKEEPER_INSTALL/bin\n```\n到此安装完毕\n- 启动zookeeper\n```\n./zkServer.sh start   #启动服务\n./zkServer.sh status  #查看状态STARTED、STOPPED\n./zkServer.sh stop    #关闭服务\n```\n### 三、安装tomcat\n- 解压tomcat安装包\n```\ntar -zxvf apache-tomcat-7.0.77.tar.gz\n```\n- 启动tomcat\n使用`./catalina.sh start`和`./startup.sh`都能启动tomcat。\n使用`./catalina.sh stop`或`./shutdown.sh`停止tomcat。\n\n- 查看tomcat的启动日志\n```\ntail -f catalina.out\n```\n- 退出查看:`Ctrl + c`,退出tail命令。  \n\n### 四、Centos 7端口、防火墙。\nCentOS7使用firewall而不是iptables。所以解决这类问题可以通过添加firewall的端口，使其对我们需要用的端口开放。\n#### 4.1、Centos 7 端口\n- 查看已经开放的端口：\n```\nfirewall-cmd --list-ports\n```\n- 开放新的端口\n```\nfirewall-cmd --zone=public --add-port=8080/tcp --permanent\n```\n**命令含义：**\n`zone` #作用域\n`add-port=80/tcp` #添加端口，格式为：端口/通讯协议\n`permanent` #永久生效，没有此参数重启后失效\n\n#### 4.2、Centos 7防火墙\n```\nfirewall-cmd --state    #查看防火墙状态。得到结果是running或者not running\nfirewall-cmd --reload   #加载配置,重启firewall\nfirewall-cmd --permanent --zone=public --list-ports //查看开启的端口\nsystemctl stop firewalld.service    #停止firewall\nsystemctl disable firewalld.service     #禁止firewall开机启动\n```\n\n### 五、Centos 6.x版本及以下版本\n- 开放8080 端口.\n用vi打开 `/etc/sysconfig/iptables`,新增如下一行。\n```\n-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT\n```\n此行必须放在\n```\n-A INPUT -j REJECT --reject-with icmp-host-prohibited\n-A FORWARD -j REJECT --reject-with icmp-host-prohibited\n```\n这两行的前面，否则一样无效,编辑完后保存。\n重启防火墙，使新增的端口生效。\n```\nservice iptables restart\n```\n- 查看开启的端口：\n```\n/etc/init.d/iptables status\n```\n- 开启、关闭防火墙\n    1. 永久性生效，重启后不会复原\n        开启： `chkconfig iptables on`\n        关闭： `chkconfig iptables off`\n    2.  即时生效，重启后复原\n        开启： `service iptables start`\n        关闭： `service iptables stop`\n\n### 六、linux中切换账户\n- 使用root用户切换普通用户时直接`su - 用户名`就可以了；\n```\nsu - sdll \n```\n切换到用户:`sdll`, 切换到root用户同理。\n\n> 使用普通用户切换至root用户时`su -`或者`su - root`然后输入root密码就可以了；\n在大都的Linux的版本中，都可以使用`su`或者`su -`，但是`su`和`su -`还是有一定的差别的：\nsu只是切换了root身份，但Shell环境仍然是普通用户的Shell；而`su -`连用户和Shell环境一起切换成root身份了。只有切换了Shell环境才不会出现PATH环境变量错误。`su`切换成root用户以后，pwd一下，发现工作目录仍然是普通用户的工作目录；而用`su -`命令切换以后，工作目录变成root的工作目录了。用`echo $PATH`命令看一下`su`和`su -`以后的环境变量有何不同。以此类推，要从当前用户切换到其它用户也一样，应该使用`su -`命令。\n\n### 七、root权限\n在操作的时候尽量不要直接使用root账号来操作，使用其他账号来操作，如果需要权限的话，那就给给自己的账号增加root权限，下面演示如何给`sdll`账号增加root权限。\n- 修改`/etc/sudoers` 文件，找到`root`一行，在`root`下面添加一行，如下所示：\n```\n## Allow root to run any commands anywhere\nroot    ALL=(ALL)     ALL\nsdll   ALL=(ALL)     ALL\n```\n修改完毕后，用`sdll`帐号登录，在需要权限才可操作的命令前面加上`sudo `，`sdll`账号以系统管理者的身份执行指令,间接的获取到了root权限。\n- Linux sudo命令\nLinux `sudo`命令以系统管理者的身份执行指令，也就是说，经由 `sudo` 所执行的指令就好像是 root 亲自执行。\n使用权限：在 `/etc/sudoers` 中有出现的使用者。\n> $ sudo -u uggc vi ~www/index.html\n//以 uggc 用户身份编辑  home 目录下www目录中的 index.html 文件\n\n### 八、vim编辑器\n- *Normal Mode* -> *Command-line Mode*\n    - `:/filename` 搜索字符串\n    - `:w` 保存文件\n    - `:w!` 强制保存文件（前提是用户有修改文件访问权限的权限）\n    - `:q` 退出缓冲区\n    - `:q!` 强制退出缓冲区而不保存\n    - `:wq` 保存文件并退出缓冲区\n    - `:ZZ`  保存文件并且退出\n    - `:wq!` 强制保存文件并退出缓冲区（前提是用户有修改文件访问权限的权限）\n    - `:w <filename>` 另存为名为filename文件\n    - `:n1,n2 w <filename>` 将n1行到n2行的数据另存为名为filename文件\n    - `: x` 如果文件有更改，则保存后退出。否则直接退出。\n \n- *Insert Mode* -> *Normal Mode* **OR** *Command-line* -> *Normal Mode*\n按下ESC键\n\n### 九、查看进程和杀掉进程\n- `ps`命令用于查看当前正在运行的进程。`grep`是搜索,`aux`显示所有状态，例如： \n```\nps -ef|grep java    // 表示查看所有进程里 CMD 是 java 的进程信息\nps -aux|grep java   \n```\n- `kill` 命令用于终止进程例如： \n```\nkill -9 [PID]       // -9 表示强迫进程立即停止\n```\n通常用 ps 查看进程 PID ，用 kill 命令终止进程.\n\n### 十、输入命令小技巧\n有时候会碰到文件夹名特别长的时候，这个时候敲这个文件夹名就有点头疼，现在要进入`apache-tomcat-7.0.82`这个文件夹\n```\n[sdll@sdll-pc tomcat]$ ls\napache-tomcat-7.0.82\n[sdll@sdll-pc tomcat]$ cd apa    //输入 apa 后，按 Tab 键，自动补全 apache-tomcat-7.0.82\n```\n有木有很方便呀~~~\n\n**参考：**\nhttps://www.cnblogs.com/guzhanyu/p/7921552.html\nhttps://zhidao.baidu.com/question/251895351.html\n\n","source":"_posts/在Linux环境下部署java-web项目.md","raw":"---\ntitle: 在Linux环境下部署java web项目\ntags:\n  - JAVA\n  - Linux\n  - web\nabbrlink: d54218b1\ndate: 2017-12-12 22:13:39\n---\n\n由于项目需要，最近开发的这个项目的部署工作由我们开发自己来完成，因为项目是部署在Linux环境中，对我来说说还是蛮有吸引力的，之前开发都是在windows环境中完成的，还没有体验过真正项目的部署过程；下面开始记录部署的整个过程。\n<!-- more -->\n### 一、安装jdk\n- 解压jdk安装包\n下载linux环境对应的jdk安装包，[jdk下载地址](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html),大家选择对应自己电脑的版本下载，这个就不多讲了；下载好了之后解压安装包\n```\ntar -zxvf jdk-8u151-linux-x64.tar.gz -C /usr/local/java/\n```\n此处把jdk压缩包解压到指定目录`/usr/local/java/`中\n- 配置环境变量\n\n\n\n### 二、安装zookeeper\n- 首先下载zookeeper的稳定版本。[zookeeper-3.4.10.tar.gz stable版本下载](http://mirrors.hust.edu.cn/apache/zookeeper/stable/)\n- 解压压缩包\n```\ntar -zxvf zookeeper-3.4.10.tar.gz\n```\n- 把conf目录下的zoo_sample.cfg复制一份,并命名为zoo.cfg\n`cp zoo_sample.cfg zoo.cfg`\n- 修改zoo.cfg配置文件，此处是单机版zookeeper配置。\n```\ndataDir=/datatmp/zookeeper/data\ndataLogDir=/datatmp/zookeeper/logs\n```\n保存。如果在对应文件夹`data`、`logs`不存在，请自己在对应的路径下新建。\n- 在/etc/profile文件中设置PATH\n修改profile文件：`vi /etc/profile`，在文件末尾加入\n```\nexport ZOOKEEPER_INSTALL=/usr/local/zookeeper/zookeeper-3.4.10/\nexport PATH=$PATH:$ZOOKEEPER_INSTALL/bin\n```\n到此安装完毕\n- 启动zookeeper\n```\n./zkServer.sh start   #启动服务\n./zkServer.sh status  #查看状态STARTED、STOPPED\n./zkServer.sh stop    #关闭服务\n```\n### 三、安装tomcat\n- 解压tomcat安装包\n```\ntar -zxvf apache-tomcat-7.0.77.tar.gz\n```\n- 启动tomcat\n使用`./catalina.sh start`和`./startup.sh`都能启动tomcat。\n使用`./catalina.sh stop`或`./shutdown.sh`停止tomcat。\n\n- 查看tomcat的启动日志\n```\ntail -f catalina.out\n```\n- 退出查看:`Ctrl + c`,退出tail命令。  \n\n### 四、Centos 7端口、防火墙。\nCentOS7使用firewall而不是iptables。所以解决这类问题可以通过添加firewall的端口，使其对我们需要用的端口开放。\n#### 4.1、Centos 7 端口\n- 查看已经开放的端口：\n```\nfirewall-cmd --list-ports\n```\n- 开放新的端口\n```\nfirewall-cmd --zone=public --add-port=8080/tcp --permanent\n```\n**命令含义：**\n`zone` #作用域\n`add-port=80/tcp` #添加端口，格式为：端口/通讯协议\n`permanent` #永久生效，没有此参数重启后失效\n\n#### 4.2、Centos 7防火墙\n```\nfirewall-cmd --state    #查看防火墙状态。得到结果是running或者not running\nfirewall-cmd --reload   #加载配置,重启firewall\nfirewall-cmd --permanent --zone=public --list-ports //查看开启的端口\nsystemctl stop firewalld.service    #停止firewall\nsystemctl disable firewalld.service     #禁止firewall开机启动\n```\n\n### 五、Centos 6.x版本及以下版本\n- 开放8080 端口.\n用vi打开 `/etc/sysconfig/iptables`,新增如下一行。\n```\n-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT\n```\n此行必须放在\n```\n-A INPUT -j REJECT --reject-with icmp-host-prohibited\n-A FORWARD -j REJECT --reject-with icmp-host-prohibited\n```\n这两行的前面，否则一样无效,编辑完后保存。\n重启防火墙，使新增的端口生效。\n```\nservice iptables restart\n```\n- 查看开启的端口：\n```\n/etc/init.d/iptables status\n```\n- 开启、关闭防火墙\n    1. 永久性生效，重启后不会复原\n        开启： `chkconfig iptables on`\n        关闭： `chkconfig iptables off`\n    2.  即时生效，重启后复原\n        开启： `service iptables start`\n        关闭： `service iptables stop`\n\n### 六、linux中切换账户\n- 使用root用户切换普通用户时直接`su - 用户名`就可以了；\n```\nsu - sdll \n```\n切换到用户:`sdll`, 切换到root用户同理。\n\n> 使用普通用户切换至root用户时`su -`或者`su - root`然后输入root密码就可以了；\n在大都的Linux的版本中，都可以使用`su`或者`su -`，但是`su`和`su -`还是有一定的差别的：\nsu只是切换了root身份，但Shell环境仍然是普通用户的Shell；而`su -`连用户和Shell环境一起切换成root身份了。只有切换了Shell环境才不会出现PATH环境变量错误。`su`切换成root用户以后，pwd一下，发现工作目录仍然是普通用户的工作目录；而用`su -`命令切换以后，工作目录变成root的工作目录了。用`echo $PATH`命令看一下`su`和`su -`以后的环境变量有何不同。以此类推，要从当前用户切换到其它用户也一样，应该使用`su -`命令。\n\n### 七、root权限\n在操作的时候尽量不要直接使用root账号来操作，使用其他账号来操作，如果需要权限的话，那就给给自己的账号增加root权限，下面演示如何给`sdll`账号增加root权限。\n- 修改`/etc/sudoers` 文件，找到`root`一行，在`root`下面添加一行，如下所示：\n```\n## Allow root to run any commands anywhere\nroot    ALL=(ALL)     ALL\nsdll   ALL=(ALL)     ALL\n```\n修改完毕后，用`sdll`帐号登录，在需要权限才可操作的命令前面加上`sudo `，`sdll`账号以系统管理者的身份执行指令,间接的获取到了root权限。\n- Linux sudo命令\nLinux `sudo`命令以系统管理者的身份执行指令，也就是说，经由 `sudo` 所执行的指令就好像是 root 亲自执行。\n使用权限：在 `/etc/sudoers` 中有出现的使用者。\n> $ sudo -u uggc vi ~www/index.html\n//以 uggc 用户身份编辑  home 目录下www目录中的 index.html 文件\n\n### 八、vim编辑器\n- *Normal Mode* -> *Command-line Mode*\n    - `:/filename` 搜索字符串\n    - `:w` 保存文件\n    - `:w!` 强制保存文件（前提是用户有修改文件访问权限的权限）\n    - `:q` 退出缓冲区\n    - `:q!` 强制退出缓冲区而不保存\n    - `:wq` 保存文件并退出缓冲区\n    - `:ZZ`  保存文件并且退出\n    - `:wq!` 强制保存文件并退出缓冲区（前提是用户有修改文件访问权限的权限）\n    - `:w <filename>` 另存为名为filename文件\n    - `:n1,n2 w <filename>` 将n1行到n2行的数据另存为名为filename文件\n    - `: x` 如果文件有更改，则保存后退出。否则直接退出。\n \n- *Insert Mode* -> *Normal Mode* **OR** *Command-line* -> *Normal Mode*\n按下ESC键\n\n### 九、查看进程和杀掉进程\n- `ps`命令用于查看当前正在运行的进程。`grep`是搜索,`aux`显示所有状态，例如： \n```\nps -ef|grep java    // 表示查看所有进程里 CMD 是 java 的进程信息\nps -aux|grep java   \n```\n- `kill` 命令用于终止进程例如： \n```\nkill -9 [PID]       // -9 表示强迫进程立即停止\n```\n通常用 ps 查看进程 PID ，用 kill 命令终止进程.\n\n### 十、输入命令小技巧\n有时候会碰到文件夹名特别长的时候，这个时候敲这个文件夹名就有点头疼，现在要进入`apache-tomcat-7.0.82`这个文件夹\n```\n[sdll@sdll-pc tomcat]$ ls\napache-tomcat-7.0.82\n[sdll@sdll-pc tomcat]$ cd apa    //输入 apa 后，按 Tab 键，自动补全 apache-tomcat-7.0.82\n```\n有木有很方便呀~~~\n\n**参考：**\nhttps://www.cnblogs.com/guzhanyu/p/7921552.html\nhttps://zhidao.baidu.com/question/251895351.html\n\n","slug":"在Linux环境下部署java-web项目","published":1,"updated":"2017-12-25T08:12:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2w200y10019mwd3wq0ieo5o","content":"<p>由于项目需要，最近开发的这个项目的部署工作由我们开发自己来完成，因为项目是部署在Linux环境中，对我来说说还是蛮有吸引力的，之前开发都是在windows环境中完成的，还没有体验过真正项目的部署过程；下面开始记录部署的整个过程。<br><a id=\"more\"></a></p>\n<h3 id=\"一、安装jdk\"><a href=\"#一、安装jdk\" class=\"headerlink\" title=\"一、安装jdk\"></a>一、安装jdk</h3><ul>\n<li>解压jdk安装包<br>下载linux环境对应的jdk安装包，<a href=\"http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\" target=\"_blank\" rel=\"noopener\">jdk下载地址</a>,大家选择对应自己电脑的版本下载，这个就不多讲了；下载好了之后解压安装包<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zxvf jdk-8u151-linux-x64.tar.gz -C /usr/local/java/</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>此处把jdk压缩包解压到指定目录<code>/usr/local/java/</code>中</p>\n<ul>\n<li>配置环境变量</li>\n</ul>\n<h3 id=\"二、安装zookeeper\"><a href=\"#二、安装zookeeper\" class=\"headerlink\" title=\"二、安装zookeeper\"></a>二、安装zookeeper</h3><ul>\n<li>首先下载zookeeper的稳定版本。<a href=\"http://mirrors.hust.edu.cn/apache/zookeeper/stable/\" target=\"_blank\" rel=\"noopener\">zookeeper-3.4.10.tar.gz stable版本下载</a></li>\n<li><p>解压压缩包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zxvf zookeeper-3.4.10.tar.gz</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>把conf目录下的zoo_sample.cfg复制一份,并命名为zoo.cfg<br><code>cp zoo_sample.cfg zoo.cfg</code></p>\n</li>\n<li>修改zoo.cfg配置文件，此处是单机版zookeeper配置。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dataDir=/datatmp/zookeeper/data</span><br><span class=\"line\">dataLogDir=/datatmp/zookeeper/logs</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>保存。如果在对应文件夹<code>data</code>、<code>logs</code>不存在，请自己在对应的路径下新建。</p>\n<ul>\n<li>在/etc/profile文件中设置PATH<br>修改profile文件：<code>vi /etc/profile</code>，在文件末尾加入<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export ZOOKEEPER_INSTALL=/usr/local/zookeeper/zookeeper-3.4.10/</span><br><span class=\"line\">export PATH=$PATH:$ZOOKEEPER_INSTALL/bin</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>到此安装完毕</p>\n<ul>\n<li>启动zookeeper<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./zkServer.sh start   #启动服务</span><br><span class=\"line\">./zkServer.sh status  #查看状态STARTED、STOPPED</span><br><span class=\"line\">./zkServer.sh stop    #关闭服务</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"三、安装tomcat\"><a href=\"#三、安装tomcat\" class=\"headerlink\" title=\"三、安装tomcat\"></a>三、安装tomcat</h3><ul>\n<li><p>解压tomcat安装包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zxvf apache-tomcat-7.0.77.tar.gz</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动tomcat<br>使用<code>./catalina.sh start</code>和<code>./startup.sh</code>都能启动tomcat。<br>使用<code>./catalina.sh stop</code>或<code>./shutdown.sh</code>停止tomcat。</p>\n</li>\n<li><p>查看tomcat的启动日志</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tail -f catalina.out</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>退出查看:<code>Ctrl + c</code>,退出tail命令。  </p>\n</li>\n</ul>\n<h3 id=\"四、Centos-7端口、防火墙。\"><a href=\"#四、Centos-7端口、防火墙。\" class=\"headerlink\" title=\"四、Centos 7端口、防火墙。\"></a>四、Centos 7端口、防火墙。</h3><p>CentOS7使用firewall而不是iptables。所以解决这类问题可以通过添加firewall的端口，使其对我们需要用的端口开放。</p>\n<h4 id=\"4-1、Centos-7-端口\"><a href=\"#4-1、Centos-7-端口\" class=\"headerlink\" title=\"4.1、Centos 7 端口\"></a>4.1、Centos 7 端口</h4><ul>\n<li><p>查看已经开放的端口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>开放新的端口</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>命令含义：</strong><br><code>zone</code> #作用域<br><code>add-port=80/tcp</code> #添加端口，格式为：端口/通讯协议<br><code>permanent</code> #永久生效，没有此参数重启后失效</p>\n<h4 id=\"4-2、Centos-7防火墙\"><a href=\"#4-2、Centos-7防火墙\" class=\"headerlink\" title=\"4.2、Centos 7防火墙\"></a>4.2、Centos 7防火墙</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --state    #查看防火墙状态。得到结果是running或者not running</span><br><span class=\"line\">firewall-cmd --reload   #加载配置,重启firewall</span><br><span class=\"line\">firewall-cmd --permanent --zone=public --list-ports //查看开启的端口</span><br><span class=\"line\">systemctl stop firewalld.service    #停止firewall</span><br><span class=\"line\">systemctl disable firewalld.service     #禁止firewall开机启动</span><br></pre></td></tr></table></figure>\n<h3 id=\"五、Centos-6-x版本及以下版本\"><a href=\"#五、Centos-6-x版本及以下版本\" class=\"headerlink\" title=\"五、Centos 6.x版本及以下版本\"></a>五、Centos 6.x版本及以下版本</h3><ul>\n<li>开放8080 端口.<br>用vi打开 <code>/etc/sysconfig/iptables</code>,新增如下一行。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>此行必须放在<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-A INPUT -j REJECT --reject-with icmp-host-prohibited</span><br><span class=\"line\">-A FORWARD -j REJECT --reject-with icmp-host-prohibited</span><br></pre></td></tr></table></figure></p>\n<p>这两行的前面，否则一样无效,编辑完后保存。<br>重启防火墙，使新增的端口生效。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service iptables restart</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>查看开启的端口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/init.d/iptables status</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>开启、关闭防火墙</p>\n<ol>\n<li>永久性生效，重启后不会复原<br> 开启： <code>chkconfig iptables on</code><br> 关闭： <code>chkconfig iptables off</code></li>\n<li>即时生效，重启后复原<br>开启： <code>service iptables start</code><br>关闭： <code>service iptables stop</code></li>\n</ol>\n</li>\n</ul>\n<h3 id=\"六、linux中切换账户\"><a href=\"#六、linux中切换账户\" class=\"headerlink\" title=\"六、linux中切换账户\"></a>六、linux中切换账户</h3><ul>\n<li>使用root用户切换普通用户时直接<code>su - 用户名</code>就可以了；<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su - sdll</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>切换到用户:<code>sdll</code>, 切换到root用户同理。</p>\n<blockquote>\n<p>使用普通用户切换至root用户时<code>su -</code>或者<code>su - root</code>然后输入root密码就可以了；<br>在大都的Linux的版本中，都可以使用<code>su</code>或者<code>su -</code>，但是<code>su</code>和<code>su -</code>还是有一定的差别的：<br>su只是切换了root身份，但Shell环境仍然是普通用户的Shell；而<code>su -</code>连用户和Shell环境一起切换成root身份了。只有切换了Shell环境才不会出现PATH环境变量错误。<code>su</code>切换成root用户以后，pwd一下，发现工作目录仍然是普通用户的工作目录；而用<code>su -</code>命令切换以后，工作目录变成root的工作目录了。用<code>echo $PATH</code>命令看一下<code>su</code>和<code>su -</code>以后的环境变量有何不同。以此类推，要从当前用户切换到其它用户也一样，应该使用<code>su -</code>命令。</p>\n</blockquote>\n<h3 id=\"七、root权限\"><a href=\"#七、root权限\" class=\"headerlink\" title=\"七、root权限\"></a>七、root权限</h3><p>在操作的时候尽量不要直接使用root账号来操作，使用其他账号来操作，如果需要权限的话，那就给给自己的账号增加root权限，下面演示如何给<code>sdll</code>账号增加root权限。</p>\n<ul>\n<li>修改<code>/etc/sudoers</code> 文件，找到<code>root</code>一行，在<code>root</code>下面添加一行，如下所示：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## Allow root to run any commands anywhere</span><br><span class=\"line\">root    ALL=(ALL)     ALL</span><br><span class=\"line\">sdll   ALL=(ALL)     ALL</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>修改完毕后，用<code>sdll</code>帐号登录，在需要权限才可操作的命令前面加上<code>sudo</code>，<code>sdll</code>账号以系统管理者的身份执行指令,间接的获取到了root权限。</p>\n<ul>\n<li>Linux sudo命令<br>Linux <code>sudo</code>命令以系统管理者的身份执行指令，也就是说，经由 <code>sudo</code> 所执行的指令就好像是 root 亲自执行。<br>使用权限：在 <code>/etc/sudoers</code> 中有出现的使用者。<blockquote>\n<p>$ sudo -u uggc vi ~www/index.html<br>//以 uggc 用户身份编辑  home 目录下www目录中的 index.html 文件</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"八、vim编辑器\"><a href=\"#八、vim编辑器\" class=\"headerlink\" title=\"八、vim编辑器\"></a>八、vim编辑器</h3><ul>\n<li><p><em>Normal Mode</em> -&gt; <em>Command-line Mode</em></p>\n<ul>\n<li><code>:/filename</code> 搜索字符串</li>\n<li><code>:w</code> 保存文件</li>\n<li><code>:w!</code> 强制保存文件（前提是用户有修改文件访问权限的权限）</li>\n<li><code>:q</code> 退出缓冲区</li>\n<li><code>:q!</code> 强制退出缓冲区而不保存</li>\n<li><code>:wq</code> 保存文件并退出缓冲区</li>\n<li><code>:ZZ</code>  保存文件并且退出</li>\n<li><code>:wq!</code> 强制保存文件并退出缓冲区（前提是用户有修改文件访问权限的权限）</li>\n<li><code>:w &lt;filename&gt;</code> 另存为名为filename文件</li>\n<li><code>:n1,n2 w &lt;filename&gt;</code> 将n1行到n2行的数据另存为名为filename文件</li>\n<li><code>: x</code> 如果文件有更改，则保存后退出。否则直接退出。</li>\n</ul>\n</li>\n<li><p><em>Insert Mode</em> -&gt; <em>Normal Mode</em> <strong>OR</strong> <em>Command-line</em> -&gt; <em>Normal Mode</em><br>按下ESC键</p>\n</li>\n</ul>\n<h3 id=\"九、查看进程和杀掉进程\"><a href=\"#九、查看进程和杀掉进程\" class=\"headerlink\" title=\"九、查看进程和杀掉进程\"></a>九、查看进程和杀掉进程</h3><ul>\n<li><p><code>ps</code>命令用于查看当前正在运行的进程。<code>grep</code>是搜索,<code>aux</code>显示所有状态，例如： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -ef|grep java    // 表示查看所有进程里 CMD 是 java 的进程信息</span><br><span class=\"line\">ps -aux|grep java</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>kill</code> 命令用于终止进程例如： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kill -9 [PID]       // -9 表示强迫进程立即停止</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>通常用 ps 查看进程 PID ，用 kill 命令终止进程.</p>\n<h3 id=\"十、输入命令小技巧\"><a href=\"#十、输入命令小技巧\" class=\"headerlink\" title=\"十、输入命令小技巧\"></a>十、输入命令小技巧</h3><p>有时候会碰到文件夹名特别长的时候，这个时候敲这个文件夹名就有点头疼，现在要进入<code>apache-tomcat-7.0.82</code>这个文件夹<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[sdll@sdll-pc tomcat]$ ls</span><br><span class=\"line\">apache-tomcat-7.0.82</span><br><span class=\"line\">[sdll@sdll-pc tomcat]$ cd apa    //输入 apa 后，按 Tab 键，自动补全 apache-tomcat-7.0.82</span><br></pre></td></tr></table></figure></p>\n<p>有木有很方便呀~~~</p>\n<p><strong>参考：</strong><br><a href=\"https://www.cnblogs.com/guzhanyu/p/7921552.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/guzhanyu/p/7921552.html</a><br><a href=\"https://zhidao.baidu.com/question/251895351.html\" target=\"_blank\" rel=\"noopener\">https://zhidao.baidu.com/question/251895351.html</a></p>\n","site":{"data":{}},"excerpt":"<p>由于项目需要，最近开发的这个项目的部署工作由我们开发自己来完成，因为项目是部署在Linux环境中，对我来说说还是蛮有吸引力的，之前开发都是在windows环境中完成的，还没有体验过真正项目的部署过程；下面开始记录部署的整个过程。<br>","more":"</p>\n<h3 id=\"一、安装jdk\"><a href=\"#一、安装jdk\" class=\"headerlink\" title=\"一、安装jdk\"></a>一、安装jdk</h3><ul>\n<li>解压jdk安装包<br>下载linux环境对应的jdk安装包，<a href=\"http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\" target=\"_blank\" rel=\"noopener\">jdk下载地址</a>,大家选择对应自己电脑的版本下载，这个就不多讲了；下载好了之后解压安装包<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zxvf jdk-8u151-linux-x64.tar.gz -C /usr/local/java/</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>此处把jdk压缩包解压到指定目录<code>/usr/local/java/</code>中</p>\n<ul>\n<li>配置环境变量</li>\n</ul>\n<h3 id=\"二、安装zookeeper\"><a href=\"#二、安装zookeeper\" class=\"headerlink\" title=\"二、安装zookeeper\"></a>二、安装zookeeper</h3><ul>\n<li>首先下载zookeeper的稳定版本。<a href=\"http://mirrors.hust.edu.cn/apache/zookeeper/stable/\" target=\"_blank\" rel=\"noopener\">zookeeper-3.4.10.tar.gz stable版本下载</a></li>\n<li><p>解压压缩包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zxvf zookeeper-3.4.10.tar.gz</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>把conf目录下的zoo_sample.cfg复制一份,并命名为zoo.cfg<br><code>cp zoo_sample.cfg zoo.cfg</code></p>\n</li>\n<li>修改zoo.cfg配置文件，此处是单机版zookeeper配置。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dataDir=/datatmp/zookeeper/data</span><br><span class=\"line\">dataLogDir=/datatmp/zookeeper/logs</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>保存。如果在对应文件夹<code>data</code>、<code>logs</code>不存在，请自己在对应的路径下新建。</p>\n<ul>\n<li>在/etc/profile文件中设置PATH<br>修改profile文件：<code>vi /etc/profile</code>，在文件末尾加入<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export ZOOKEEPER_INSTALL=/usr/local/zookeeper/zookeeper-3.4.10/</span><br><span class=\"line\">export PATH=$PATH:$ZOOKEEPER_INSTALL/bin</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>到此安装完毕</p>\n<ul>\n<li>启动zookeeper<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./zkServer.sh start   #启动服务</span><br><span class=\"line\">./zkServer.sh status  #查看状态STARTED、STOPPED</span><br><span class=\"line\">./zkServer.sh stop    #关闭服务</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"三、安装tomcat\"><a href=\"#三、安装tomcat\" class=\"headerlink\" title=\"三、安装tomcat\"></a>三、安装tomcat</h3><ul>\n<li><p>解压tomcat安装包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -zxvf apache-tomcat-7.0.77.tar.gz</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动tomcat<br>使用<code>./catalina.sh start</code>和<code>./startup.sh</code>都能启动tomcat。<br>使用<code>./catalina.sh stop</code>或<code>./shutdown.sh</code>停止tomcat。</p>\n</li>\n<li><p>查看tomcat的启动日志</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tail -f catalina.out</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>退出查看:<code>Ctrl + c</code>,退出tail命令。  </p>\n</li>\n</ul>\n<h3 id=\"四、Centos-7端口、防火墙。\"><a href=\"#四、Centos-7端口、防火墙。\" class=\"headerlink\" title=\"四、Centos 7端口、防火墙。\"></a>四、Centos 7端口、防火墙。</h3><p>CentOS7使用firewall而不是iptables。所以解决这类问题可以通过添加firewall的端口，使其对我们需要用的端口开放。</p>\n<h4 id=\"4-1、Centos-7-端口\"><a href=\"#4-1、Centos-7-端口\" class=\"headerlink\" title=\"4.1、Centos 7 端口\"></a>4.1、Centos 7 端口</h4><ul>\n<li><p>查看已经开放的端口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>开放新的端口</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>命令含义：</strong><br><code>zone</code> #作用域<br><code>add-port=80/tcp</code> #添加端口，格式为：端口/通讯协议<br><code>permanent</code> #永久生效，没有此参数重启后失效</p>\n<h4 id=\"4-2、Centos-7防火墙\"><a href=\"#4-2、Centos-7防火墙\" class=\"headerlink\" title=\"4.2、Centos 7防火墙\"></a>4.2、Centos 7防火墙</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --state    #查看防火墙状态。得到结果是running或者not running</span><br><span class=\"line\">firewall-cmd --reload   #加载配置,重启firewall</span><br><span class=\"line\">firewall-cmd --permanent --zone=public --list-ports //查看开启的端口</span><br><span class=\"line\">systemctl stop firewalld.service    #停止firewall</span><br><span class=\"line\">systemctl disable firewalld.service     #禁止firewall开机启动</span><br></pre></td></tr></table></figure>\n<h3 id=\"五、Centos-6-x版本及以下版本\"><a href=\"#五、Centos-6-x版本及以下版本\" class=\"headerlink\" title=\"五、Centos 6.x版本及以下版本\"></a>五、Centos 6.x版本及以下版本</h3><ul>\n<li>开放8080 端口.<br>用vi打开 <code>/etc/sysconfig/iptables</code>,新增如下一行。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>此行必须放在<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-A INPUT -j REJECT --reject-with icmp-host-prohibited</span><br><span class=\"line\">-A FORWARD -j REJECT --reject-with icmp-host-prohibited</span><br></pre></td></tr></table></figure></p>\n<p>这两行的前面，否则一样无效,编辑完后保存。<br>重启防火墙，使新增的端口生效。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service iptables restart</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>查看开启的端口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/init.d/iptables status</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>开启、关闭防火墙</p>\n<ol>\n<li>永久性生效，重启后不会复原<br> 开启： <code>chkconfig iptables on</code><br> 关闭： <code>chkconfig iptables off</code></li>\n<li>即时生效，重启后复原<br>开启： <code>service iptables start</code><br>关闭： <code>service iptables stop</code></li>\n</ol>\n</li>\n</ul>\n<h3 id=\"六、linux中切换账户\"><a href=\"#六、linux中切换账户\" class=\"headerlink\" title=\"六、linux中切换账户\"></a>六、linux中切换账户</h3><ul>\n<li>使用root用户切换普通用户时直接<code>su - 用户名</code>就可以了；<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">su - sdll</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>切换到用户:<code>sdll</code>, 切换到root用户同理。</p>\n<blockquote>\n<p>使用普通用户切换至root用户时<code>su -</code>或者<code>su - root</code>然后输入root密码就可以了；<br>在大都的Linux的版本中，都可以使用<code>su</code>或者<code>su -</code>，但是<code>su</code>和<code>su -</code>还是有一定的差别的：<br>su只是切换了root身份，但Shell环境仍然是普通用户的Shell；而<code>su -</code>连用户和Shell环境一起切换成root身份了。只有切换了Shell环境才不会出现PATH环境变量错误。<code>su</code>切换成root用户以后，pwd一下，发现工作目录仍然是普通用户的工作目录；而用<code>su -</code>命令切换以后，工作目录变成root的工作目录了。用<code>echo $PATH</code>命令看一下<code>su</code>和<code>su -</code>以后的环境变量有何不同。以此类推，要从当前用户切换到其它用户也一样，应该使用<code>su -</code>命令。</p>\n</blockquote>\n<h3 id=\"七、root权限\"><a href=\"#七、root权限\" class=\"headerlink\" title=\"七、root权限\"></a>七、root权限</h3><p>在操作的时候尽量不要直接使用root账号来操作，使用其他账号来操作，如果需要权限的话，那就给给自己的账号增加root权限，下面演示如何给<code>sdll</code>账号增加root权限。</p>\n<ul>\n<li>修改<code>/etc/sudoers</code> 文件，找到<code>root</code>一行，在<code>root</code>下面添加一行，如下所示：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## Allow root to run any commands anywhere</span><br><span class=\"line\">root    ALL=(ALL)     ALL</span><br><span class=\"line\">sdll   ALL=(ALL)     ALL</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>修改完毕后，用<code>sdll</code>帐号登录，在需要权限才可操作的命令前面加上<code>sudo</code>，<code>sdll</code>账号以系统管理者的身份执行指令,间接的获取到了root权限。</p>\n<ul>\n<li>Linux sudo命令<br>Linux <code>sudo</code>命令以系统管理者的身份执行指令，也就是说，经由 <code>sudo</code> 所执行的指令就好像是 root 亲自执行。<br>使用权限：在 <code>/etc/sudoers</code> 中有出现的使用者。<blockquote>\n<p>$ sudo -u uggc vi ~www/index.html<br>//以 uggc 用户身份编辑  home 目录下www目录中的 index.html 文件</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"八、vim编辑器\"><a href=\"#八、vim编辑器\" class=\"headerlink\" title=\"八、vim编辑器\"></a>八、vim编辑器</h3><ul>\n<li><p><em>Normal Mode</em> -&gt; <em>Command-line Mode</em></p>\n<ul>\n<li><code>:/filename</code> 搜索字符串</li>\n<li><code>:w</code> 保存文件</li>\n<li><code>:w!</code> 强制保存文件（前提是用户有修改文件访问权限的权限）</li>\n<li><code>:q</code> 退出缓冲区</li>\n<li><code>:q!</code> 强制退出缓冲区而不保存</li>\n<li><code>:wq</code> 保存文件并退出缓冲区</li>\n<li><code>:ZZ</code>  保存文件并且退出</li>\n<li><code>:wq!</code> 强制保存文件并退出缓冲区（前提是用户有修改文件访问权限的权限）</li>\n<li><code>:w &lt;filename&gt;</code> 另存为名为filename文件</li>\n<li><code>:n1,n2 w &lt;filename&gt;</code> 将n1行到n2行的数据另存为名为filename文件</li>\n<li><code>: x</code> 如果文件有更改，则保存后退出。否则直接退出。</li>\n</ul>\n</li>\n<li><p><em>Insert Mode</em> -&gt; <em>Normal Mode</em> <strong>OR</strong> <em>Command-line</em> -&gt; <em>Normal Mode</em><br>按下ESC键</p>\n</li>\n</ul>\n<h3 id=\"九、查看进程和杀掉进程\"><a href=\"#九、查看进程和杀掉进程\" class=\"headerlink\" title=\"九、查看进程和杀掉进程\"></a>九、查看进程和杀掉进程</h3><ul>\n<li><p><code>ps</code>命令用于查看当前正在运行的进程。<code>grep</code>是搜索,<code>aux</code>显示所有状态，例如： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -ef|grep java    // 表示查看所有进程里 CMD 是 java 的进程信息</span><br><span class=\"line\">ps -aux|grep java</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>kill</code> 命令用于终止进程例如： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kill -9 [PID]       // -9 表示强迫进程立即停止</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>通常用 ps 查看进程 PID ，用 kill 命令终止进程.</p>\n<h3 id=\"十、输入命令小技巧\"><a href=\"#十、输入命令小技巧\" class=\"headerlink\" title=\"十、输入命令小技巧\"></a>十、输入命令小技巧</h3><p>有时候会碰到文件夹名特别长的时候，这个时候敲这个文件夹名就有点头疼，现在要进入<code>apache-tomcat-7.0.82</code>这个文件夹<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[sdll@sdll-pc tomcat]$ ls</span><br><span class=\"line\">apache-tomcat-7.0.82</span><br><span class=\"line\">[sdll@sdll-pc tomcat]$ cd apa    //输入 apa 后，按 Tab 键，自动补全 apache-tomcat-7.0.82</span><br></pre></td></tr></table></figure></p>\n<p>有木有很方便呀~~~</p>\n<p><strong>参考：</strong><br><a href=\"https://www.cnblogs.com/guzhanyu/p/7921552.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/guzhanyu/p/7921552.html</a><br><a href=\"https://zhidao.baidu.com/question/251895351.html\" target=\"_blank\" rel=\"noopener\">https://zhidao.baidu.com/question/251895351.html</a></p>"},{"title":"常用单词汇集","abbrlink":"aef118f4","date":"2017-12-02T14:12:38.000Z","_content":"用于英语比较渣，好些单词都不认识，此贴以用来记录一些常用单词。\n<!-- more -->\n- transient  瞬态\n- Constructs  构建\n- Internal  内部\n- ensure   确保\n- template  模板\n- specified  指定\n- sequence  序列\n- substring  子串\n- Delegating 授权\n- Resolver 解析器\n- Parser  分析器\n- Concurrent  同时发生的\n- delegate  代表\n- const 常数的，不变的；\n- externals   外部\n- scope   范围\n- artifact   神器\n- datagram  数据报\n- intentionally   故意地\n- substitution 替代\n- delimiters   分隔符\n- placeholder  占位符\n- pertaining 有关\n- invoked 调用\n- Deprecated 弃用\n- respectively  分别地\n- acceptance  验收\n- hints 提示\n- Recursion  递归\n- Dynamic Programming   动态规划\n- Top-Down Variation  自上而下的变化\n- Bottom-Up Variation  自底向上的变化\n- inflated  膨胀的\n- unicast   单播\n- multicast   多播\n- monitor   监控器\n- protocol  协议\n- Wrapper 包装器\n- invokers 调用器\n- explicitly 显示地\n- passed in  传入\n- persists   仍然存在\n- hint    暗示\n- scheduler  调度器（者）\n- tracked    跟踪\n- discard   丢弃","source":"_posts/常用单词汇集.md","raw":"---\ntitle: 常用单词汇集\ntags:\n  - JAVA\n  - 单词\nabbrlink: aef118f4\ndate: 2017-12-02 22:12:38\n---\n用于英语比较渣，好些单词都不认识，此贴以用来记录一些常用单词。\n<!-- more -->\n- transient  瞬态\n- Constructs  构建\n- Internal  内部\n- ensure   确保\n- template  模板\n- specified  指定\n- sequence  序列\n- substring  子串\n- Delegating 授权\n- Resolver 解析器\n- Parser  分析器\n- Concurrent  同时发生的\n- delegate  代表\n- const 常数的，不变的；\n- externals   外部\n- scope   范围\n- artifact   神器\n- datagram  数据报\n- intentionally   故意地\n- substitution 替代\n- delimiters   分隔符\n- placeholder  占位符\n- pertaining 有关\n- invoked 调用\n- Deprecated 弃用\n- respectively  分别地\n- acceptance  验收\n- hints 提示\n- Recursion  递归\n- Dynamic Programming   动态规划\n- Top-Down Variation  自上而下的变化\n- Bottom-Up Variation  自底向上的变化\n- inflated  膨胀的\n- unicast   单播\n- multicast   多播\n- monitor   监控器\n- protocol  协议\n- Wrapper 包装器\n- invokers 调用器\n- explicitly 显示地\n- passed in  传入\n- persists   仍然存在\n- hint    暗示\n- scheduler  调度器（者）\n- tracked    跟踪\n- discard   丢弃","slug":"常用单词汇集","published":1,"updated":"2018-01-11T13:58:23.880Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2w200yb001bmwd3ysys6l5d","content":"<p>用于英语比较渣，好些单词都不认识，此贴以用来记录一些常用单词。<br><a id=\"more\"></a></p>\n<ul>\n<li>transient  瞬态</li>\n<li>Constructs  构建</li>\n<li>Internal  内部</li>\n<li>ensure   确保</li>\n<li>template  模板</li>\n<li>specified  指定</li>\n<li>sequence  序列</li>\n<li>substring  子串</li>\n<li>Delegating 授权</li>\n<li>Resolver 解析器</li>\n<li>Parser  分析器</li>\n<li>Concurrent  同时发生的</li>\n<li>delegate  代表</li>\n<li>const 常数的，不变的；</li>\n<li>externals   外部</li>\n<li>scope   范围</li>\n<li>artifact   神器</li>\n<li>datagram  数据报</li>\n<li>intentionally   故意地</li>\n<li>substitution 替代</li>\n<li>delimiters   分隔符</li>\n<li>placeholder  占位符</li>\n<li>pertaining 有关</li>\n<li>invoked 调用</li>\n<li>Deprecated 弃用</li>\n<li>respectively  分别地</li>\n<li>acceptance  验收</li>\n<li>hints 提示</li>\n<li>Recursion  递归</li>\n<li>Dynamic Programming   动态规划</li>\n<li>Top-Down Variation  自上而下的变化</li>\n<li>Bottom-Up Variation  自底向上的变化</li>\n<li>inflated  膨胀的</li>\n<li>unicast   单播</li>\n<li>multicast   多播</li>\n<li>monitor   监控器</li>\n<li>protocol  协议</li>\n<li>Wrapper 包装器</li>\n<li>invokers 调用器</li>\n<li>explicitly 显示地</li>\n<li>passed in  传入</li>\n<li>persists   仍然存在</li>\n<li>hint    暗示</li>\n<li>scheduler  调度器（者）</li>\n<li>tracked    跟踪</li>\n<li>discard   丢弃</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>用于英语比较渣，好些单词都不认识，此贴以用来记录一些常用单词。<br>","more":"</p>\n<ul>\n<li>transient  瞬态</li>\n<li>Constructs  构建</li>\n<li>Internal  内部</li>\n<li>ensure   确保</li>\n<li>template  模板</li>\n<li>specified  指定</li>\n<li>sequence  序列</li>\n<li>substring  子串</li>\n<li>Delegating 授权</li>\n<li>Resolver 解析器</li>\n<li>Parser  分析器</li>\n<li>Concurrent  同时发生的</li>\n<li>delegate  代表</li>\n<li>const 常数的，不变的；</li>\n<li>externals   外部</li>\n<li>scope   范围</li>\n<li>artifact   神器</li>\n<li>datagram  数据报</li>\n<li>intentionally   故意地</li>\n<li>substitution 替代</li>\n<li>delimiters   分隔符</li>\n<li>placeholder  占位符</li>\n<li>pertaining 有关</li>\n<li>invoked 调用</li>\n<li>Deprecated 弃用</li>\n<li>respectively  分别地</li>\n<li>acceptance  验收</li>\n<li>hints 提示</li>\n<li>Recursion  递归</li>\n<li>Dynamic Programming   动态规划</li>\n<li>Top-Down Variation  自上而下的变化</li>\n<li>Bottom-Up Variation  自底向上的变化</li>\n<li>inflated  膨胀的</li>\n<li>unicast   单播</li>\n<li>multicast   多播</li>\n<li>monitor   监控器</li>\n<li>protocol  协议</li>\n<li>Wrapper 包装器</li>\n<li>invokers 调用器</li>\n<li>explicitly 显示地</li>\n<li>passed in  传入</li>\n<li>persists   仍然存在</li>\n<li>hint    暗示</li>\n<li>scheduler  调度器（者）</li>\n<li>tracked    跟踪</li>\n<li>discard   丢弃</li>\n</ul>"},{"title":"理解分析HashMap的数据结构","abbrlink":"7e219bde","date":"2017-11-28T15:37:23.000Z","_content":"\n此文旨在方便自己理解HashMap的结构；Hashmap是一种非常常用的、应用广泛的数据类型，虽然用的很多，内部的具体的实现是什么样的？在此总结下。\n<!-- more -->\n\n- **hashmap的数据结构** \n在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，hashmap也不例外。Hashmap实际上是一个数组和链表的结合体（在数据结构中，一般称之为“链表散列“），请看下图（横排表示数组，纵排表示数组元素【实际上是一个链表】）。\n![hashMap结构示意图](http://ozux0lqfa.bkt.clouddn.com/HashMap%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)\n所以hashmap的数据结构是数组和链表的结合。\n下面是HashMap中的内部类`Node<K, V>`节点，用来存储键值对。\n```\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash;\n    final K key;\n    V value;\n    Node<K,V> next;\n\n    Node(int hash, K key, V value, Node<K,V> next) {\n        this.hash = hash;\n        this.key = key;\n        this.value = value;\n        this.next = next;\n    }\n\n    public final K getKey()        { return key; }\n    public final V getValue()      { return value; }\n    public final String toString() { return key + \"=\" + value; }\n\n    public final int hashCode() {\n        return Objects.hashCode(key) ^ Objects.hashCode(value);\n    }\n\n    public final V setValue(V newValue) {\n        V oldValue = value;\n        value = newValue;\n        return oldValue;\n    }\n\n    public final boolean equals(Object o) {\n        if (o == this)\n            return true;\n        if (o instanceof Map.Entry) {\n            Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n            if (Objects.equals(key, e.getKey()) &&\n                Objects.equals(value, e.getValue()))\n                return true;\n        }\n        return false;\n    }\n}\n```\n上面的Node就是数组中的元素，它持有一个指向下一个元素的引用，这就构成了链表。当我们往hashmap中put元素的时候，先根据key的hash值得到这个元素在数组中的位置（即下标），然后就可以把这个元素放到对应的位置中了。如果这个元素所在的位子上已经存放有其他元素了，那么在同一个位子上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。从hashmap中get元素时，首先计算key的hashcode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。从这里我们可以想象得到，如果每个位置上的链表只有一个元素，那么hashmap的get效率将是最高的。\n\n- **hash算法**\n我们可以看到在hashmap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过hashmap的数据结构是数组和链表的结合，所以我们当然希望这个hashmap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。\n所以我们首先想到的就是把hashcode对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，能不能找一种更快速，消耗更小的方式那？java中时这样做的，\n```\nstatic int indexFor(int h, int length) {  \n    return h & (length-1);  \n}  \n```\n首先算得key得hashcode值，然后跟数组的长度-1做一次“与”运算（&）。看上去很简单，其实比较有玄机。比如数组的长度是2的4次方，那么hashcode就会和2的4次方-1做“与”运算。很多人都有这个疑问，为什么hashmap的数组初始化大小都是2的次方大小时，hashmap的效率最高，我以2的4次方举例，来解释一下为什么数组大小为2的幂时hashmap访问的性能最高。 \n\n下图，左边两组是数组长度为16（2的4次方），右边两组是数组长度为15。两组的hashcode均为8和9，但是很明显，当它们和1110“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到同一个链表上，那么查询的时候就需要遍历这个链表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hashcode的值会与14（1110）进行“与”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！\n![按位与](http://ozux0lqfa.bkt.clouddn.com/%E6%8C%89%E4%BD%8D%E4%B8%8E.jpg)\n所以说，当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。\n说到这里，我们再回头看一下hashmap中默认的数组大小是多少，查看源代码可以得知是16，为什么是16，而不是15，也不是20呢，看到上面annegu的解释之后我们就清楚了吧，显然是因为16是2的整数次幂的原因，在小数据量的情况下16比15和20更能减少key之间的碰撞，而加快查询的效率。 \n```\nint capacity = 1;  \nwhile (capacity < initialCapacity)   \n    capacity <<= 1;  \n```\n\n- **hashmap的resize方法**\n当hashmap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对hashmap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在hashmap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。\n那么hashmap什么时候进行扩容呢？当hashmap中的元素个数超过 数组大小 × loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16 × 0.75=12的时候，就把数组的大小扩展为2 × 16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面annegu已经说过，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.75 × 1000 < 1000, 也就是说为了让0.75 × size > 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了&的问题，也避免了resize的问题。 \n\n- **key的hashcode与equals方法改写** \nhashmap的get()方法的过程：在hashmap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置，然后通过key的equals方法在对应位置的链表中找到需要的元素。所以，hashcode与equals方法对于找到对应元素是两个关键方法。\nHashmap的key可以是任何类型的对象，例如User这种对象，为了保证两个具有相同属性的user的hashcode相同，我们就需要改写hashcode方法，比方把hashcode值的计算与User对象的id关联起来，那么只要user对象拥有相同id，那么他们的hashcode也能保持一致了，这样就可以找到在hashmap数组中的位置了。如果这个位置上有多个元素，还需要用key的equals方法在对应位置的链表中找到需要的元素，所以只改写了hashcode方法是不够的，equals方法也是需要改写滴~当然啦，按正常思维逻辑，equals方法一般都会根据实际的业务内容来定义，例如根据user对象的id来判断两个user是否相等。\n在改写equals方法的时候，需要满足以下三点：\n(1) 自反性：就是说a.equals(a)必须为true。\n(2) 对称性：就是说a.equals(b)=true的话，b.equals(a)也必须为true。\n(3) 传递性：就是说a.equals(b)=true，并且b.equals(c)=true的话，a.equals(c)也必须为true。\n通过改写key对象的equals和hashcode方法，我们可以将任意的业务对象作为map的key(前提是你确实有这样的需要)。\n\n- **hashMap数组扩容**\nHashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize\n\n**引用参考文章：**\nhttps://www.cnblogs.com/ITtangtang/p/3948406.html\nhttp://annegu.iteye.com/blog/539465\n\n\n","source":"_posts/理解分析HashMap的数据结构.md","raw":"---\ntitle: 理解分析HashMap的数据结构\ntags:\n  - jdk源码\n  - 数据结构\nabbrlink: 7e219bde\ndate: 2017-11-28 23:37:23\n---\n\n此文旨在方便自己理解HashMap的结构；Hashmap是一种非常常用的、应用广泛的数据类型，虽然用的很多，内部的具体的实现是什么样的？在此总结下。\n<!-- more -->\n\n- **hashmap的数据结构** \n在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，hashmap也不例外。Hashmap实际上是一个数组和链表的结合体（在数据结构中，一般称之为“链表散列“），请看下图（横排表示数组，纵排表示数组元素【实际上是一个链表】）。\n![hashMap结构示意图](http://ozux0lqfa.bkt.clouddn.com/HashMap%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)\n所以hashmap的数据结构是数组和链表的结合。\n下面是HashMap中的内部类`Node<K, V>`节点，用来存储键值对。\n```\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash;\n    final K key;\n    V value;\n    Node<K,V> next;\n\n    Node(int hash, K key, V value, Node<K,V> next) {\n        this.hash = hash;\n        this.key = key;\n        this.value = value;\n        this.next = next;\n    }\n\n    public final K getKey()        { return key; }\n    public final V getValue()      { return value; }\n    public final String toString() { return key + \"=\" + value; }\n\n    public final int hashCode() {\n        return Objects.hashCode(key) ^ Objects.hashCode(value);\n    }\n\n    public final V setValue(V newValue) {\n        V oldValue = value;\n        value = newValue;\n        return oldValue;\n    }\n\n    public final boolean equals(Object o) {\n        if (o == this)\n            return true;\n        if (o instanceof Map.Entry) {\n            Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n            if (Objects.equals(key, e.getKey()) &&\n                Objects.equals(value, e.getValue()))\n                return true;\n        }\n        return false;\n    }\n}\n```\n上面的Node就是数组中的元素，它持有一个指向下一个元素的引用，这就构成了链表。当我们往hashmap中put元素的时候，先根据key的hash值得到这个元素在数组中的位置（即下标），然后就可以把这个元素放到对应的位置中了。如果这个元素所在的位子上已经存放有其他元素了，那么在同一个位子上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。从hashmap中get元素时，首先计算key的hashcode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。从这里我们可以想象得到，如果每个位置上的链表只有一个元素，那么hashmap的get效率将是最高的。\n\n- **hash算法**\n我们可以看到在hashmap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过hashmap的数据结构是数组和链表的结合，所以我们当然希望这个hashmap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。\n所以我们首先想到的就是把hashcode对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，能不能找一种更快速，消耗更小的方式那？java中时这样做的，\n```\nstatic int indexFor(int h, int length) {  \n    return h & (length-1);  \n}  \n```\n首先算得key得hashcode值，然后跟数组的长度-1做一次“与”运算（&）。看上去很简单，其实比较有玄机。比如数组的长度是2的4次方，那么hashcode就会和2的4次方-1做“与”运算。很多人都有这个疑问，为什么hashmap的数组初始化大小都是2的次方大小时，hashmap的效率最高，我以2的4次方举例，来解释一下为什么数组大小为2的幂时hashmap访问的性能最高。 \n\n下图，左边两组是数组长度为16（2的4次方），右边两组是数组长度为15。两组的hashcode均为8和9，但是很明显，当它们和1110“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到同一个链表上，那么查询的时候就需要遍历这个链表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hashcode的值会与14（1110）进行“与”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！\n![按位与](http://ozux0lqfa.bkt.clouddn.com/%E6%8C%89%E4%BD%8D%E4%B8%8E.jpg)\n所以说，当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。\n说到这里，我们再回头看一下hashmap中默认的数组大小是多少，查看源代码可以得知是16，为什么是16，而不是15，也不是20呢，看到上面annegu的解释之后我们就清楚了吧，显然是因为16是2的整数次幂的原因，在小数据量的情况下16比15和20更能减少key之间的碰撞，而加快查询的效率。 \n```\nint capacity = 1;  \nwhile (capacity < initialCapacity)   \n    capacity <<= 1;  \n```\n\n- **hashmap的resize方法**\n当hashmap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对hashmap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在hashmap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。\n那么hashmap什么时候进行扩容呢？当hashmap中的元素个数超过 数组大小 × loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16 × 0.75=12的时候，就把数组的大小扩展为2 × 16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面annegu已经说过，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.75 × 1000 < 1000, 也就是说为了让0.75 × size > 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了&的问题，也避免了resize的问题。 \n\n- **key的hashcode与equals方法改写** \nhashmap的get()方法的过程：在hashmap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置，然后通过key的equals方法在对应位置的链表中找到需要的元素。所以，hashcode与equals方法对于找到对应元素是两个关键方法。\nHashmap的key可以是任何类型的对象，例如User这种对象，为了保证两个具有相同属性的user的hashcode相同，我们就需要改写hashcode方法，比方把hashcode值的计算与User对象的id关联起来，那么只要user对象拥有相同id，那么他们的hashcode也能保持一致了，这样就可以找到在hashmap数组中的位置了。如果这个位置上有多个元素，还需要用key的equals方法在对应位置的链表中找到需要的元素，所以只改写了hashcode方法是不够的，equals方法也是需要改写滴~当然啦，按正常思维逻辑，equals方法一般都会根据实际的业务内容来定义，例如根据user对象的id来判断两个user是否相等。\n在改写equals方法的时候，需要满足以下三点：\n(1) 自反性：就是说a.equals(a)必须为true。\n(2) 对称性：就是说a.equals(b)=true的话，b.equals(a)也必须为true。\n(3) 传递性：就是说a.equals(b)=true，并且b.equals(c)=true的话，a.equals(c)也必须为true。\n通过改写key对象的equals和hashcode方法，我们可以将任意的业务对象作为map的key(前提是你确实有这样的需要)。\n\n- **hashMap数组扩容**\nHashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize\n\n**引用参考文章：**\nhttps://www.cnblogs.com/ITtangtang/p/3948406.html\nhttp://annegu.iteye.com/blog/539465\n\n\n","slug":"理解分析HashMap的数据结构","published":1,"updated":"2017-12-14T13:55:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2w200yi001dmwd35ji85bgs","content":"<p>此文旨在方便自己理解HashMap的结构；Hashmap是一种非常常用的、应用广泛的数据类型，虽然用的很多，内部的具体的实现是什么样的？在此总结下。<br><a id=\"more\"></a></p>\n<ul>\n<li><strong>hashmap的数据结构</strong><br>在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，hashmap也不例外。Hashmap实际上是一个数组和链表的结合体（在数据结构中，一般称之为“链表散列“），请看下图（横排表示数组，纵排表示数组元素【实际上是一个链表】）。<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/HashMap%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg\" alt=\"hashMap结构示意图\"><br>所以hashmap的数据结构是数组和链表的结合。<br>下面是HashMap中的内部类<code>Node&lt;K, V&gt;</code>节点，用来存储键值对。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class=\"line\">    final int hash;</span><br><span class=\"line\">    final K key;</span><br><span class=\"line\">    V value;</span><br><span class=\"line\">    Node&lt;K,V&gt; next;</span><br><span class=\"line\"></span><br><span class=\"line\">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">        this.hash = hash;</span><br><span class=\"line\">        this.key = key;</span><br><span class=\"line\">        this.value = value;</span><br><span class=\"line\">        this.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public final K getKey()        &#123; return key; &#125;</span><br><span class=\"line\">    public final V getValue()      &#123; return value; &#125;</span><br><span class=\"line\">    public final String toString() &#123; return key + &quot;=&quot; + value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public final int hashCode() &#123;</span><br><span class=\"line\">        return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public final V setValue(V newValue) &#123;</span><br><span class=\"line\">        V oldValue = value;</span><br><span class=\"line\">        value = newValue;</span><br><span class=\"line\">        return oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public final boolean equals(Object o) &#123;</span><br><span class=\"line\">        if (o == this)</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        if (o instanceof Map.Entry) &#123;</span><br><span class=\"line\">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class=\"line\">            if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class=\"line\">                Objects.equals(value, e.getValue()))</span><br><span class=\"line\">                return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上面的Node就是数组中的元素，它持有一个指向下一个元素的引用，这就构成了链表。当我们往hashmap中put元素的时候，先根据key的hash值得到这个元素在数组中的位置（即下标），然后就可以把这个元素放到对应的位置中了。如果这个元素所在的位子上已经存放有其他元素了，那么在同一个位子上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。从hashmap中get元素时，首先计算key的hashcode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。从这里我们可以想象得到，如果每个位置上的链表只有一个元素，那么hashmap的get效率将是最高的。</p>\n<ul>\n<li><strong>hash算法</strong><br>我们可以看到在hashmap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过hashmap的数据结构是数组和链表的结合，所以我们当然希望这个hashmap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。<br>所以我们首先想到的就是把hashcode对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，能不能找一种更快速，消耗更小的方式那？java中时这样做的，<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int indexFor(int h, int length) &#123;  </span><br><span class=\"line\">    return h &amp; (length-1);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>首先算得key得hashcode值，然后跟数组的长度-1做一次“与”运算（&amp;）。看上去很简单，其实比较有玄机。比如数组的长度是2的4次方，那么hashcode就会和2的4次方-1做“与”运算。很多人都有这个疑问，为什么hashmap的数组初始化大小都是2的次方大小时，hashmap的效率最高，我以2的4次方举例，来解释一下为什么数组大小为2的幂时hashmap访问的性能最高。 </p>\n<p>下图，左边两组是数组长度为16（2的4次方），右边两组是数组长度为15。两组的hashcode均为8和9，但是很明显，当它们和1110“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到同一个链表上，那么查询的时候就需要遍历这个链表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hashcode的值会与14（1110）进行“与”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/%E6%8C%89%E4%BD%8D%E4%B8%8E.jpg\" alt=\"按位与\"><br>所以说，当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。<br>说到这里，我们再回头看一下hashmap中默认的数组大小是多少，查看源代码可以得知是16，为什么是16，而不是15，也不是20呢，看到上面annegu的解释之后我们就清楚了吧，显然是因为16是2的整数次幂的原因，在小数据量的情况下16比15和20更能减少key之间的碰撞，而加快查询的效率。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int capacity = 1;  </span><br><span class=\"line\">while (capacity &lt; initialCapacity)   </span><br><span class=\"line\">    capacity &lt;&lt;= 1;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p><strong>hashmap的resize方法</strong><br>当hashmap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对hashmap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在hashmap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。<br>那么hashmap什么时候进行扩容呢？当hashmap中的元素个数超过 数组大小 × loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16 × 0.75=12的时候，就把数组的大小扩展为2 × 16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面annegu已经说过，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.75 × 1000 &lt; 1000, 也就是说为了让0.75 × size &gt; 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了&amp;的问题，也避免了resize的问题。 </p>\n</li>\n<li><p><strong>key的hashcode与equals方法改写</strong><br>hashmap的get()方法的过程：在hashmap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置，然后通过key的equals方法在对应位置的链表中找到需要的元素。所以，hashcode与equals方法对于找到对应元素是两个关键方法。<br>Hashmap的key可以是任何类型的对象，例如User这种对象，为了保证两个具有相同属性的user的hashcode相同，我们就需要改写hashcode方法，比方把hashcode值的计算与User对象的id关联起来，那么只要user对象拥有相同id，那么他们的hashcode也能保持一致了，这样就可以找到在hashmap数组中的位置了。如果这个位置上有多个元素，还需要用key的equals方法在对应位置的链表中找到需要的元素，所以只改写了hashcode方法是不够的，equals方法也是需要改写滴~当然啦，按正常思维逻辑，equals方法一般都会根据实际的业务内容来定义，例如根据user对象的id来判断两个user是否相等。<br>在改写equals方法的时候，需要满足以下三点：<br>(1) 自反性：就是说a.equals(a)必须为true。<br>(2) 对称性：就是说a.equals(b)=true的话，b.equals(a)也必须为true。<br>(3) 传递性：就是说a.equals(b)=true，并且b.equals(c)=true的话，a.equals(c)也必须为true。<br>通过改写key对象的equals和hashcode方法，我们可以将任意的业务对象作为map的key(前提是你确实有这样的需要)。</p>\n</li>\n<li><p><strong>hashMap数组扩容</strong><br>HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize</p>\n</li>\n</ul>\n<p><strong>引用参考文章：</strong><br><a href=\"https://www.cnblogs.com/ITtangtang/p/3948406.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/ITtangtang/p/3948406.html</a><br><a href=\"http://annegu.iteye.com/blog/539465\" target=\"_blank\" rel=\"noopener\">http://annegu.iteye.com/blog/539465</a></p>\n","site":{"data":{}},"excerpt":"<p>此文旨在方便自己理解HashMap的结构；Hashmap是一种非常常用的、应用广泛的数据类型，虽然用的很多，内部的具体的实现是什么样的？在此总结下。<br>","more":"</p>\n<ul>\n<li><strong>hashmap的数据结构</strong><br>在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，hashmap也不例外。Hashmap实际上是一个数组和链表的结合体（在数据结构中，一般称之为“链表散列“），请看下图（横排表示数组，纵排表示数组元素【实际上是一个链表】）。<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/HashMap%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg\" alt=\"hashMap结构示意图\"><br>所以hashmap的数据结构是数组和链表的结合。<br>下面是HashMap中的内部类<code>Node&lt;K, V&gt;</code>节点，用来存储键值对。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class=\"line\">    final int hash;</span><br><span class=\"line\">    final K key;</span><br><span class=\"line\">    V value;</span><br><span class=\"line\">    Node&lt;K,V&gt; next;</span><br><span class=\"line\"></span><br><span class=\"line\">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">        this.hash = hash;</span><br><span class=\"line\">        this.key = key;</span><br><span class=\"line\">        this.value = value;</span><br><span class=\"line\">        this.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public final K getKey()        &#123; return key; &#125;</span><br><span class=\"line\">    public final V getValue()      &#123; return value; &#125;</span><br><span class=\"line\">    public final String toString() &#123; return key + &quot;=&quot; + value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public final int hashCode() &#123;</span><br><span class=\"line\">        return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public final V setValue(V newValue) &#123;</span><br><span class=\"line\">        V oldValue = value;</span><br><span class=\"line\">        value = newValue;</span><br><span class=\"line\">        return oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public final boolean equals(Object o) &#123;</span><br><span class=\"line\">        if (o == this)</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        if (o instanceof Map.Entry) &#123;</span><br><span class=\"line\">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class=\"line\">            if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class=\"line\">                Objects.equals(value, e.getValue()))</span><br><span class=\"line\">                return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上面的Node就是数组中的元素，它持有一个指向下一个元素的引用，这就构成了链表。当我们往hashmap中put元素的时候，先根据key的hash值得到这个元素在数组中的位置（即下标），然后就可以把这个元素放到对应的位置中了。如果这个元素所在的位子上已经存放有其他元素了，那么在同一个位子上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。从hashmap中get元素时，首先计算key的hashcode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。从这里我们可以想象得到，如果每个位置上的链表只有一个元素，那么hashmap的get效率将是最高的。</p>\n<ul>\n<li><strong>hash算法</strong><br>我们可以看到在hashmap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过hashmap的数据结构是数组和链表的结合，所以我们当然希望这个hashmap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。<br>所以我们首先想到的就是把hashcode对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，能不能找一种更快速，消耗更小的方式那？java中时这样做的，<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int indexFor(int h, int length) &#123;  </span><br><span class=\"line\">    return h &amp; (length-1);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>首先算得key得hashcode值，然后跟数组的长度-1做一次“与”运算（&amp;）。看上去很简单，其实比较有玄机。比如数组的长度是2的4次方，那么hashcode就会和2的4次方-1做“与”运算。很多人都有这个疑问，为什么hashmap的数组初始化大小都是2的次方大小时，hashmap的效率最高，我以2的4次方举例，来解释一下为什么数组大小为2的幂时hashmap访问的性能最高。 </p>\n<p>下图，左边两组是数组长度为16（2的4次方），右边两组是数组长度为15。两组的hashcode均为8和9，但是很明显，当它们和1110“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到同一个链表上，那么查询的时候就需要遍历这个链表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hashcode的值会与14（1110）进行“与”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/%E6%8C%89%E4%BD%8D%E4%B8%8E.jpg\" alt=\"按位与\"><br>所以说，当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。<br>说到这里，我们再回头看一下hashmap中默认的数组大小是多少，查看源代码可以得知是16，为什么是16，而不是15，也不是20呢，看到上面annegu的解释之后我们就清楚了吧，显然是因为16是2的整数次幂的原因，在小数据量的情况下16比15和20更能减少key之间的碰撞，而加快查询的效率。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int capacity = 1;  </span><br><span class=\"line\">while (capacity &lt; initialCapacity)   </span><br><span class=\"line\">    capacity &lt;&lt;= 1;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p><strong>hashmap的resize方法</strong><br>当hashmap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对hashmap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在hashmap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。<br>那么hashmap什么时候进行扩容呢？当hashmap中的元素个数超过 数组大小 × loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16 × 0.75=12的时候，就把数组的大小扩展为2 × 16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面annegu已经说过，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.75 × 1000 &lt; 1000, 也就是说为了让0.75 × size &gt; 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了&amp;的问题，也避免了resize的问题。 </p>\n</li>\n<li><p><strong>key的hashcode与equals方法改写</strong><br>hashmap的get()方法的过程：在hashmap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置，然后通过key的equals方法在对应位置的链表中找到需要的元素。所以，hashcode与equals方法对于找到对应元素是两个关键方法。<br>Hashmap的key可以是任何类型的对象，例如User这种对象，为了保证两个具有相同属性的user的hashcode相同，我们就需要改写hashcode方法，比方把hashcode值的计算与User对象的id关联起来，那么只要user对象拥有相同id，那么他们的hashcode也能保持一致了，这样就可以找到在hashmap数组中的位置了。如果这个位置上有多个元素，还需要用key的equals方法在对应位置的链表中找到需要的元素，所以只改写了hashcode方法是不够的，equals方法也是需要改写滴~当然啦，按正常思维逻辑，equals方法一般都会根据实际的业务内容来定义，例如根据user对象的id来判断两个user是否相等。<br>在改写equals方法的时候，需要满足以下三点：<br>(1) 自反性：就是说a.equals(a)必须为true。<br>(2) 对称性：就是说a.equals(b)=true的话，b.equals(a)也必须为true。<br>(3) 传递性：就是说a.equals(b)=true，并且b.equals(c)=true的话，a.equals(c)也必须为true。<br>通过改写key对象的equals和hashcode方法，我们可以将任意的业务对象作为map的key(前提是你确实有这样的需要)。</p>\n</li>\n<li><p><strong>hashMap数组扩容</strong><br>HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize</p>\n</li>\n</ul>\n<p><strong>引用参考文章：</strong><br><a href=\"https://www.cnblogs.com/ITtangtang/p/3948406.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/ITtangtang/p/3948406.html</a><br><a href=\"http://annegu.iteye.com/blog/539465\" target=\"_blank\" rel=\"noopener\">http://annegu.iteye.com/blog/539465</a></p>"},{"title":"由最长回文数引发的思考","abbrlink":"702042b3","date":"2017-08-11T09:14:55.000Z","_content":"- 最长公共子串（Longest Common Substring）与最长公共子序列（Longest Common Subsequence）的区别：\n<!-- more -->\n> 子串要求在原字符串中是连续的，而子序列则只需保持相对顺序一致，并不要求连续。\n\n- 最长公共子序列\n![](http://ww1.sinaimg.cn/large/8515e8c2ly1g46u0zfy8zj20ae0aomyf.jpg)\n- 求最长子序列长度\n![](http://ww1.sinaimg.cn/large/8515e8c2ly1g46u4063x9j20e702n744.jpg)\n- 最长回文数的代码实现：\n```\npublic static int testMaxLongPlalindrome(String str) {\n    int length = str.length();\n    String[] charstr = str.split(\"\");\n    int[][] dp = new int[length + 1][length + 1];\n    for (int i = 0; i < length; i++) {\n        for (int j = 0; j < length; j++) {\n            if(charstr[i].equals(charstr[length - j - 1])) {\n                dp[i + 1][j + 1] = dp[i][j] + 1;\n            }else {\n                dp[i + 1][j + 1] = Math.max(dp[i][j + 1], dp[i + 1][j]);\n            }\n        }\n    }\n    System.out.println(length - dp[length][length]);    \n    return length - dp[length][length];\n}\n```\n\n#### `算法是一个程序员的灵魂！！！`","source":"_posts/由求最长回文数的引发的思考.md","raw":"---\ntitle: 由最长回文数引发的思考\ntags:\n  - 数据结构算法\nabbrlink: 702042b3\ndate: 2017-08-11 17:14:55\n---\n- 最长公共子串（Longest Common Substring）与最长公共子序列（Longest Common Subsequence）的区别：\n<!-- more -->\n> 子串要求在原字符串中是连续的，而子序列则只需保持相对顺序一致，并不要求连续。\n\n- 最长公共子序列\n![](http://ww1.sinaimg.cn/large/8515e8c2ly1g46u0zfy8zj20ae0aomyf.jpg)\n- 求最长子序列长度\n![](http://ww1.sinaimg.cn/large/8515e8c2ly1g46u4063x9j20e702n744.jpg)\n- 最长回文数的代码实现：\n```\npublic static int testMaxLongPlalindrome(String str) {\n    int length = str.length();\n    String[] charstr = str.split(\"\");\n    int[][] dp = new int[length + 1][length + 1];\n    for (int i = 0; i < length; i++) {\n        for (int j = 0; j < length; j++) {\n            if(charstr[i].equals(charstr[length - j - 1])) {\n                dp[i + 1][j + 1] = dp[i][j] + 1;\n            }else {\n                dp[i + 1][j + 1] = Math.max(dp[i][j + 1], dp[i + 1][j]);\n            }\n        }\n    }\n    System.out.println(length - dp[length][length]);    \n    return length - dp[length][length];\n}\n```\n\n#### `算法是一个程序员的灵魂！！！`","slug":"由求最长回文数的引发的思考","published":1,"updated":"2019-06-19T14:29:40.386Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2w200ym001emwd3nb3tykv8","content":"<ul>\n<li><p>最长公共子串（Longest Common Substring）与最长公共子序列（Longest Common Subsequence）的区别：</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>子串要求在原字符串中是连续的，而子序列则只需保持相对顺序一致，并不要求连续。</p>\n</blockquote>\n</li>\n<li><p>最长公共子序列<br><img src=\"http://ww1.sinaimg.cn/large/8515e8c2ly1g46u0zfy8zj20ae0aomyf.jpg\" alt=\"\"></p>\n</li>\n<li>求最长子序列长度<br><img src=\"http://ww1.sinaimg.cn/large/8515e8c2ly1g46u4063x9j20e702n744.jpg\" alt=\"\"></li>\n<li>最长回文数的代码实现：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int testMaxLongPlalindrome(String str) &#123;</span><br><span class=\"line\">    int length = str.length();</span><br><span class=\"line\">    String[] charstr = str.split(&quot;&quot;);</span><br><span class=\"line\">    int[][] dp = new int[length + 1][length + 1];</span><br><span class=\"line\">    for (int i = 0; i &lt; length; i++) &#123;</span><br><span class=\"line\">        for (int j = 0; j &lt; length; j++) &#123;</span><br><span class=\"line\">            if(charstr[i].equals(charstr[length - j - 1])) &#123;</span><br><span class=\"line\">                dp[i + 1][j + 1] = dp[i][j] + 1;</span><br><span class=\"line\">            &#125;else &#123;</span><br><span class=\"line\">                dp[i + 1][j + 1] = Math.max(dp[i][j + 1], dp[i + 1][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(length - dp[length][length]);    </span><br><span class=\"line\">    return length - dp[length][length];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"算法是一个程序员的灵魂！！！\"><a href=\"#算法是一个程序员的灵魂！！！\" class=\"headerlink\" title=\"算法是一个程序员的灵魂！！！\"></a><code>算法是一个程序员的灵魂！！！</code></h4>","site":{"data":{}},"excerpt":"<ul>\n<li><p>最长公共子串（Longest Common Substring）与最长公共子序列（Longest Common Subsequence）的区别：</p>","more":"<blockquote>\n<p>子串要求在原字符串中是连续的，而子序列则只需保持相对顺序一致，并不要求连续。</p>\n</blockquote>\n</li>\n<li><p>最长公共子序列<br><img src=\"http://ww1.sinaimg.cn/large/8515e8c2ly1g46u0zfy8zj20ae0aomyf.jpg\" alt=\"\"></p>\n</li>\n<li>求最长子序列长度<br><img src=\"http://ww1.sinaimg.cn/large/8515e8c2ly1g46u4063x9j20e702n744.jpg\" alt=\"\"></li>\n<li>最长回文数的代码实现：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int testMaxLongPlalindrome(String str) &#123;</span><br><span class=\"line\">    int length = str.length();</span><br><span class=\"line\">    String[] charstr = str.split(&quot;&quot;);</span><br><span class=\"line\">    int[][] dp = new int[length + 1][length + 1];</span><br><span class=\"line\">    for (int i = 0; i &lt; length; i++) &#123;</span><br><span class=\"line\">        for (int j = 0; j &lt; length; j++) &#123;</span><br><span class=\"line\">            if(charstr[i].equals(charstr[length - j - 1])) &#123;</span><br><span class=\"line\">                dp[i + 1][j + 1] = dp[i][j] + 1;</span><br><span class=\"line\">            &#125;else &#123;</span><br><span class=\"line\">                dp[i + 1][j + 1] = Math.max(dp[i][j + 1], dp[i + 1][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(length - dp[length][length]);    </span><br><span class=\"line\">    return length - dp[length][length];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"算法是一个程序员的灵魂！！！\"><a href=\"#算法是一个程序员的灵魂！！！\" class=\"headerlink\" title=\"算法是一个程序员的灵魂！！！\"></a><code>算法是一个程序员的灵魂！！！</code></h4>"},{"title":"突如起来的阿里巴巴的面试电话","abbrlink":"c95fe668","date":"2018-02-27T13:35:45.000Z","_content":"\n在忙着整理之前 github 上的项目的时候，突然阿里巴巴的电话打过来了，手机震动了一下又停了，我想着估摸是是我在淘宝客服啥的电话，亦或者是打错了，没管了，就接着弄我的手头上的事情去了。\n<!-- more -->\n![阿里巴巴的面试电话](http://ozux0lqfa.bkt.clouddn.com/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E9%9D%A2%E8%AF%95%E7%94%B5%E8%AF%9D.png)\n没过一分钟电话又再次响起来了，咦？是啥？突然莫名的有点僵住了。我等了2秒后接起电话,“喂，你好”，对方也回复了我，“你好，我是阿里巴巴的hr,请问你最近在找工作吗？”\n我：是的，在找工作。\n\nhr:请问你现在有时间吗？\n我：嗯。\n\n问题：\n\n- 请你说下你做过的项目。\n这部分满关键的，会根据你所讲的项目开始深入下面的问题。\n-  了解哪些框架？会根据你说的挑几个问你。\n- spring了解吗，说下你对spring的理解。\n-  对dubbo理解。因为说在项目中使用过dubbo,结果就直接问我了，切身体会，还是要懂原理，老铁们，只会用是不行的。\n- 嘴误，把自己不熟悉的shiro说了，结果问完Spring就开始问Shiro，回答的不行。\n- 接口跟抽象类的理解？\n- 多线程的实现方式，对多线程的理解？\n- 说下你对面对对象的理解。\n- 重载跟重写的区别？可以根据返回值的不同进行重载吗？\n- 你基础怎么样？说了下平时项目不忙的时候回去看一些源码，比如String,ArrayList，LinkedList等等，\n- 下面立马就开始问 说下你对HashMap的理解。\n- 结束\n从项目一直问到基础，提问方式很专业。自己还有很多需要学习的。努力。\n\n（全文完）","source":"_posts/突如起来的阿里巴巴的面试电话.md","raw":"---\ntitle: 突如起来的阿里巴巴的面试电话\ntags:\n  - 面试\n  - 感想\nabbrlink: c95fe668\ndate: 2018-02-27 21:35:45\n---\n\n在忙着整理之前 github 上的项目的时候，突然阿里巴巴的电话打过来了，手机震动了一下又停了，我想着估摸是是我在淘宝客服啥的电话，亦或者是打错了，没管了，就接着弄我的手头上的事情去了。\n<!-- more -->\n![阿里巴巴的面试电话](http://ozux0lqfa.bkt.clouddn.com/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E9%9D%A2%E8%AF%95%E7%94%B5%E8%AF%9D.png)\n没过一分钟电话又再次响起来了，咦？是啥？突然莫名的有点僵住了。我等了2秒后接起电话,“喂，你好”，对方也回复了我，“你好，我是阿里巴巴的hr,请问你最近在找工作吗？”\n我：是的，在找工作。\n\nhr:请问你现在有时间吗？\n我：嗯。\n\n问题：\n\n- 请你说下你做过的项目。\n这部分满关键的，会根据你所讲的项目开始深入下面的问题。\n-  了解哪些框架？会根据你说的挑几个问你。\n- spring了解吗，说下你对spring的理解。\n-  对dubbo理解。因为说在项目中使用过dubbo,结果就直接问我了，切身体会，还是要懂原理，老铁们，只会用是不行的。\n- 嘴误，把自己不熟悉的shiro说了，结果问完Spring就开始问Shiro，回答的不行。\n- 接口跟抽象类的理解？\n- 多线程的实现方式，对多线程的理解？\n- 说下你对面对对象的理解。\n- 重载跟重写的区别？可以根据返回值的不同进行重载吗？\n- 你基础怎么样？说了下平时项目不忙的时候回去看一些源码，比如String,ArrayList，LinkedList等等，\n- 下面立马就开始问 说下你对HashMap的理解。\n- 结束\n从项目一直问到基础，提问方式很专业。自己还有很多需要学习的。努力。\n\n（全文完）","slug":"突如起来的阿里巴巴的面试电话","published":1,"updated":"2018-03-23T15:12:09.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2w200yw001gmwd3t96xqe7p","content":"<p>在忙着整理之前 github 上的项目的时候，突然阿里巴巴的电话打过来了，手机震动了一下又停了，我想着估摸是是我在淘宝客服啥的电话，亦或者是打错了，没管了，就接着弄我的手头上的事情去了。<br><a id=\"more\"></a><br><img src=\"http://ozux0lqfa.bkt.clouddn.com/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E9%9D%A2%E8%AF%95%E7%94%B5%E8%AF%9D.png\" alt=\"阿里巴巴的面试电话\"><br>没过一分钟电话又再次响起来了，咦？是啥？突然莫名的有点僵住了。我等了2秒后接起电话,“喂，你好”，对方也回复了我，“你好，我是阿里巴巴的hr,请问你最近在找工作吗？”<br>我：是的，在找工作。</p>\n<p>hr:请问你现在有时间吗？<br>我：嗯。</p>\n<p>问题：</p>\n<ul>\n<li>请你说下你做过的项目。<br>这部分满关键的，会根据你所讲的项目开始深入下面的问题。</li>\n<li>了解哪些框架？会根据你说的挑几个问你。</li>\n<li>spring了解吗，说下你对spring的理解。</li>\n<li>对dubbo理解。因为说在项目中使用过dubbo,结果就直接问我了，切身体会，还是要懂原理，老铁们，只会用是不行的。</li>\n<li>嘴误，把自己不熟悉的shiro说了，结果问完Spring就开始问Shiro，回答的不行。</li>\n<li>接口跟抽象类的理解？</li>\n<li>多线程的实现方式，对多线程的理解？</li>\n<li>说下你对面对对象的理解。</li>\n<li>重载跟重写的区别？可以根据返回值的不同进行重载吗？</li>\n<li>你基础怎么样？说了下平时项目不忙的时候回去看一些源码，比如String,ArrayList，LinkedList等等，</li>\n<li>下面立马就开始问 说下你对HashMap的理解。</li>\n<li>结束<br>从项目一直问到基础，提问方式很专业。自己还有很多需要学习的。努力。</li>\n</ul>\n<p>（全文完）</p>\n","site":{"data":{}},"excerpt":"<p>在忙着整理之前 github 上的项目的时候，突然阿里巴巴的电话打过来了，手机震动了一下又停了，我想着估摸是是我在淘宝客服啥的电话，亦或者是打错了，没管了，就接着弄我的手头上的事情去了。<br>","more":"<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E9%9D%A2%E8%AF%95%E7%94%B5%E8%AF%9D.png\" alt=\"阿里巴巴的面试电话\"><br>没过一分钟电话又再次响起来了，咦？是啥？突然莫名的有点僵住了。我等了2秒后接起电话,“喂，你好”，对方也回复了我，“你好，我是阿里巴巴的hr,请问你最近在找工作吗？”<br>我：是的，在找工作。</p>\n<p>hr:请问你现在有时间吗？<br>我：嗯。</p>\n<p>问题：</p>\n<ul>\n<li>请你说下你做过的项目。<br>这部分满关键的，会根据你所讲的项目开始深入下面的问题。</li>\n<li>了解哪些框架？会根据你说的挑几个问你。</li>\n<li>spring了解吗，说下你对spring的理解。</li>\n<li>对dubbo理解。因为说在项目中使用过dubbo,结果就直接问我了，切身体会，还是要懂原理，老铁们，只会用是不行的。</li>\n<li>嘴误，把自己不熟悉的shiro说了，结果问完Spring就开始问Shiro，回答的不行。</li>\n<li>接口跟抽象类的理解？</li>\n<li>多线程的实现方式，对多线程的理解？</li>\n<li>说下你对面对对象的理解。</li>\n<li>重载跟重写的区别？可以根据返回值的不同进行重载吗？</li>\n<li>你基础怎么样？说了下平时项目不忙的时候回去看一些源码，比如String,ArrayList，LinkedList等等，</li>\n<li>下面立马就开始问 说下你对HashMap的理解。</li>\n<li>结束<br>从项目一直问到基础，提问方式很专业。自己还有很多需要学习的。努力。</li>\n</ul>\n<p>（全文完）</p>"},{"title":"致那些年我读过的英才","abbrlink":"12d63093","date":"2012-06-11T09:05:32.000Z","_content":"\n高考那天真的到了，伴随着紧张与兴奋的情感，我步入了考场，现在回想起从学校出发到一中区考试中的一幕幕，我不禁满怀深情！\n<!-- more -->\n有一词叫做日久生情，我觉得用在我和母校英才上，再合适不过了。从刚进英才高中的那一刻起，我觉得我对英才充满了许许多多的不屑与不满，每当别人问我在哪所学校念书时，我都感觉这些都是难言之隐，讲出来会没面子（通俗说应该是掉底子吧），其实到现在，我才发现我错了；我冤枉母校那么久。\n\n6月7日早晨7:48分，所有的高三考生都坐在公汽汽上了，正准备出发前往考试地点参加考试，也就在第一辆公汽出门的那一刻，只听见烟花的声音响起，循声望去。听着那喜庆的声音，我的心好像被针扎了一样的，一阵阵的；我强忍住泪水，尽可能不使它流下来；可能在母校看来，我们早已经是她的孩子了！孩子出去考试好比出远门，临行前她千叮万嘱，小心，细心，耐心；烟火（烟花）代表着她给我们每一位考生的祝福；此时的我才发现他真的为我做的更多更好了，我压根就不应该看不起“她”。\n\n> 慈母手中线，游子身上衣。\n> 临行密密缝，意恐迟迟归。\n> 谁言寸草心，报得三春晖。         \n\n车子徐徐的出了大门，门外站了许多送考的考生家长！好久没被感动的我，眼泪在那一刻差点决堤了（这下应该是父爱母爱的汇集），我好像控制不住我的眼睛了，用手死死捂着它。\n\n我的父亲应该也是这样的吧......\n\n我做了许多次深呼吸，可就是怎么也平静不下来。","source":"_posts/致那些年我读过的英才.md","raw":"---\ntitle: 致那些年我读过的英才\ntags:\n  - 生活感想\nabbrlink: 12d63093\ndate: 2012-06-11 17:05:32\n---\n\n高考那天真的到了，伴随着紧张与兴奋的情感，我步入了考场，现在回想起从学校出发到一中区考试中的一幕幕，我不禁满怀深情！\n<!-- more -->\n有一词叫做日久生情，我觉得用在我和母校英才上，再合适不过了。从刚进英才高中的那一刻起，我觉得我对英才充满了许许多多的不屑与不满，每当别人问我在哪所学校念书时，我都感觉这些都是难言之隐，讲出来会没面子（通俗说应该是掉底子吧），其实到现在，我才发现我错了；我冤枉母校那么久。\n\n6月7日早晨7:48分，所有的高三考生都坐在公汽汽上了，正准备出发前往考试地点参加考试，也就在第一辆公汽出门的那一刻，只听见烟花的声音响起，循声望去。听着那喜庆的声音，我的心好像被针扎了一样的，一阵阵的；我强忍住泪水，尽可能不使它流下来；可能在母校看来，我们早已经是她的孩子了！孩子出去考试好比出远门，临行前她千叮万嘱，小心，细心，耐心；烟火（烟花）代表着她给我们每一位考生的祝福；此时的我才发现他真的为我做的更多更好了，我压根就不应该看不起“她”。\n\n> 慈母手中线，游子身上衣。\n> 临行密密缝，意恐迟迟归。\n> 谁言寸草心，报得三春晖。         \n\n车子徐徐的出了大门，门外站了许多送考的考生家长！好久没被感动的我，眼泪在那一刻差点决堤了（这下应该是父爱母爱的汇集），我好像控制不住我的眼睛了，用手死死捂着它。\n\n我的父亲应该也是这样的吧......\n\n我做了许多次深呼吸，可就是怎么也平静不下来。","slug":"致那些年我读过的英才","published":1,"updated":"2017-12-14T13:55:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2w200z2001imwd3gblsgj89","content":"<p>高考那天真的到了，伴随着紧张与兴奋的情感，我步入了考场，现在回想起从学校出发到一中区考试中的一幕幕，我不禁满怀深情！<br><a id=\"more\"></a><br>有一词叫做日久生情，我觉得用在我和母校英才上，再合适不过了。从刚进英才高中的那一刻起，我觉得我对英才充满了许许多多的不屑与不满，每当别人问我在哪所学校念书时，我都感觉这些都是难言之隐，讲出来会没面子（通俗说应该是掉底子吧），其实到现在，我才发现我错了；我冤枉母校那么久。</p>\n<p>6月7日早晨7:48分，所有的高三考生都坐在公汽汽上了，正准备出发前往考试地点参加考试，也就在第一辆公汽出门的那一刻，只听见烟花的声音响起，循声望去。听着那喜庆的声音，我的心好像被针扎了一样的，一阵阵的；我强忍住泪水，尽可能不使它流下来；可能在母校看来，我们早已经是她的孩子了！孩子出去考试好比出远门，临行前她千叮万嘱，小心，细心，耐心；烟火（烟花）代表着她给我们每一位考生的祝福；此时的我才发现他真的为我做的更多更好了，我压根就不应该看不起“她”。</p>\n<blockquote>\n<p>慈母手中线，游子身上衣。<br>临行密密缝，意恐迟迟归。<br>谁言寸草心，报得三春晖。         </p>\n</blockquote>\n<p>车子徐徐的出了大门，门外站了许多送考的考生家长！好久没被感动的我，眼泪在那一刻差点决堤了（这下应该是父爱母爱的汇集），我好像控制不住我的眼睛了，用手死死捂着它。</p>\n<p>我的父亲应该也是这样的吧……</p>\n<p>我做了许多次深呼吸，可就是怎么也平静不下来。</p>\n","site":{"data":{}},"excerpt":"<p>高考那天真的到了，伴随着紧张与兴奋的情感，我步入了考场，现在回想起从学校出发到一中区考试中的一幕幕，我不禁满怀深情！<br>","more":"<br>有一词叫做日久生情，我觉得用在我和母校英才上，再合适不过了。从刚进英才高中的那一刻起，我觉得我对英才充满了许许多多的不屑与不满，每当别人问我在哪所学校念书时，我都感觉这些都是难言之隐，讲出来会没面子（通俗说应该是掉底子吧），其实到现在，我才发现我错了；我冤枉母校那么久。</p>\n<p>6月7日早晨7:48分，所有的高三考生都坐在公汽汽上了，正准备出发前往考试地点参加考试，也就在第一辆公汽出门的那一刻，只听见烟花的声音响起，循声望去。听着那喜庆的声音，我的心好像被针扎了一样的，一阵阵的；我强忍住泪水，尽可能不使它流下来；可能在母校看来，我们早已经是她的孩子了！孩子出去考试好比出远门，临行前她千叮万嘱，小心，细心，耐心；烟火（烟花）代表着她给我们每一位考生的祝福；此时的我才发现他真的为我做的更多更好了，我压根就不应该看不起“她”。</p>\n<blockquote>\n<p>慈母手中线，游子身上衣。<br>临行密密缝，意恐迟迟归。<br>谁言寸草心，报得三春晖。         </p>\n</blockquote>\n<p>车子徐徐的出了大门，门外站了许多送考的考生家长！好久没被感动的我，眼泪在那一刻差点决堤了（这下应该是父爱母爱的汇集），我好像控制不住我的眼睛了，用手死死捂着它。</p>\n<p>我的父亲应该也是这样的吧……</p>\n<p>我做了许多次深呼吸，可就是怎么也平静不下来。</p>"},{"title":"记毕业第一个月","abbrlink":"162a7fa0","date":"2017-08-18T02:13:43.000Z","_content":"\n#### 再见了我的大学\n\n时间是真的过得很快的，转眼间17年8月份到来了，还依稀记得5月20号毕业论文答辩那天，\n<!-- more -->\n怀着些许紧张的心情进入答辩现场，进入答辩现场后发现答辩顺序是按照名字姓氏排序，没有往届所谓抽签答辩，这样我就毫无悬念的成为我那个答辩组第一个上台答辩的了。\n\n> **答辩一刻**\n上台前还是有些紧张的，因为我的答辩ppt是作业熬夜写的，只是在室友大涛的ppt上做些修改，换下名字，就准备拿来参加答辩，哎，真是没想到尽然要我第一个答辩，早知道就好好写我的ppt了，答辩现场坐了四位老师，两位是我的专业课老师（我导师也在其中），其他两位那会还不认识，听老师说可以开始了，我就上台了，做了下自我介绍，然后给到场的老师说了几句客套话，谢谢他们来参加答辩啥的，打开讲台电脑里我的事先拷贝进去的ppt，紧张的毕业论文答辩就这样结束了，后来看论文老师给的答辩成绩知道我在我们小组是拿到了93分。\n\n今天在上班的路上，路上蛮凉爽的，可能是立秋到了的原因吧！突然想起了在学校的上课日子，每到周末，那会我早上上课老迟到，不过总在最后一刻到达教室......老雷族喜欢喊班长跟学习委起来回答问题，无奈那个时候的我成绩吊车尾，也无心学习，被逼着硬是把三极管啥的学了一波......","source":"_posts/记毕业第一个月.md","raw":"---\ntitle: 记毕业第一个月\ntags:\n  - 生活感想\nabbrlink: 162a7fa0\ndate: 2017-08-18 10:13:43\n---\n\n#### 再见了我的大学\n\n时间是真的过得很快的，转眼间17年8月份到来了，还依稀记得5月20号毕业论文答辩那天，\n<!-- more -->\n怀着些许紧张的心情进入答辩现场，进入答辩现场后发现答辩顺序是按照名字姓氏排序，没有往届所谓抽签答辩，这样我就毫无悬念的成为我那个答辩组第一个上台答辩的了。\n\n> **答辩一刻**\n上台前还是有些紧张的，因为我的答辩ppt是作业熬夜写的，只是在室友大涛的ppt上做些修改，换下名字，就准备拿来参加答辩，哎，真是没想到尽然要我第一个答辩，早知道就好好写我的ppt了，答辩现场坐了四位老师，两位是我的专业课老师（我导师也在其中），其他两位那会还不认识，听老师说可以开始了，我就上台了，做了下自我介绍，然后给到场的老师说了几句客套话，谢谢他们来参加答辩啥的，打开讲台电脑里我的事先拷贝进去的ppt，紧张的毕业论文答辩就这样结束了，后来看论文老师给的答辩成绩知道我在我们小组是拿到了93分。\n\n今天在上班的路上，路上蛮凉爽的，可能是立秋到了的原因吧！突然想起了在学校的上课日子，每到周末，那会我早上上课老迟到，不过总在最后一刻到达教室......老雷族喜欢喊班长跟学习委起来回答问题，无奈那个时候的我成绩吊车尾，也无心学习，被逼着硬是把三极管啥的学了一波......","slug":"记毕业第一个月","published":1,"updated":"2017-12-14T13:55:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2w200z8001lmwd3lcnthn17","content":"<h4 id=\"再见了我的大学\"><a href=\"#再见了我的大学\" class=\"headerlink\" title=\"再见了我的大学\"></a>再见了我的大学</h4><p>时间是真的过得很快的，转眼间17年8月份到来了，还依稀记得5月20号毕业论文答辩那天，<br><a id=\"more\"></a><br>怀着些许紧张的心情进入答辩现场，进入答辩现场后发现答辩顺序是按照名字姓氏排序，没有往届所谓抽签答辩，这样我就毫无悬念的成为我那个答辩组第一个上台答辩的了。</p>\n<blockquote>\n<p><strong>答辩一刻</strong><br>上台前还是有些紧张的，因为我的答辩ppt是作业熬夜写的，只是在室友大涛的ppt上做些修改，换下名字，就准备拿来参加答辩，哎，真是没想到尽然要我第一个答辩，早知道就好好写我的ppt了，答辩现场坐了四位老师，两位是我的专业课老师（我导师也在其中），其他两位那会还不认识，听老师说可以开始了，我就上台了，做了下自我介绍，然后给到场的老师说了几句客套话，谢谢他们来参加答辩啥的，打开讲台电脑里我的事先拷贝进去的ppt，紧张的毕业论文答辩就这样结束了，后来看论文老师给的答辩成绩知道我在我们小组是拿到了93分。</p>\n</blockquote>\n<p>今天在上班的路上，路上蛮凉爽的，可能是立秋到了的原因吧！突然想起了在学校的上课日子，每到周末，那会我早上上课老迟到，不过总在最后一刻到达教室……老雷族喜欢喊班长跟学习委起来回答问题，无奈那个时候的我成绩吊车尾，也无心学习，被逼着硬是把三极管啥的学了一波……</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"再见了我的大学\"><a href=\"#再见了我的大学\" class=\"headerlink\" title=\"再见了我的大学\"></a>再见了我的大学</h4><p>时间是真的过得很快的，转眼间17年8月份到来了，还依稀记得5月20号毕业论文答辩那天，<br>","more":"<br>怀着些许紧张的心情进入答辩现场，进入答辩现场后发现答辩顺序是按照名字姓氏排序，没有往届所谓抽签答辩，这样我就毫无悬念的成为我那个答辩组第一个上台答辩的了。</p>\n<blockquote>\n<p><strong>答辩一刻</strong><br>上台前还是有些紧张的，因为我的答辩ppt是作业熬夜写的，只是在室友大涛的ppt上做些修改，换下名字，就准备拿来参加答辩，哎，真是没想到尽然要我第一个答辩，早知道就好好写我的ppt了，答辩现场坐了四位老师，两位是我的专业课老师（我导师也在其中），其他两位那会还不认识，听老师说可以开始了，我就上台了，做了下自我介绍，然后给到场的老师说了几句客套话，谢谢他们来参加答辩啥的，打开讲台电脑里我的事先拷贝进去的ppt，紧张的毕业论文答辩就这样结束了，后来看论文老师给的答辩成绩知道我在我们小组是拿到了93分。</p>\n</blockquote>\n<p>今天在上班的路上，路上蛮凉爽的，可能是立秋到了的原因吧！突然想起了在学校的上课日子，每到周末，那会我早上上课老迟到，不过总在最后一刻到达教室……老雷族喜欢喊班长跟学习委起来回答问题，无奈那个时候的我成绩吊车尾，也无心学习，被逼着硬是把三极管啥的学了一波……</p>"},{"title":"配置zookeeper的dubbo-admin管理平台","abbrlink":"fda57de0","date":"2017-12-13T07:37:32.000Z","_content":"因为zookeeper的启动是通过命令来操控的，我们无法看到注册中心存在了哪些`provider(提供者)`或`consumer（消费者）`，这时就需要借助dubbo-admin可视化管理平台进行实时的查看，同时也可以通过这个平台来管理`provider(提供者)`或`consumer（消费者）`。\n<!-- more -->\n### 一、本机环境\n> jdk:1.8\n操作系统：windows 7\nzookeeper :zookeeper-3.4.8\ntomcat：apache-tomcat-8.0.31\ndubbo-version：2.5.8\nmaven：3.3.9\n\n### 二、dubbo-admin 源码下载、编译\n- 在github上下载dubbo源码，[alibaba/dubbo](https://github.com/alibaba/dubbo)，下载下来后进行解压，本文与2017年12月13日记录，后期dubbo版本的更新可能会影响本文所描述的效果呈现。下图是解压后的路径。\n![dubbo解压后的目录](http://ozux0lqfa.bkt.clouddn.com/dubbo-master%E8%A7%A3%E5%8E%8B%E5%90%8E%E7%9B%AE%E5%BD%95.png)\n- 进入 `dubbo-admin` 文件夹，点击文件夹外的空白处，按住 `shift` 键，鼠标点击右键，选择`在此处打开命令行窗口`，进入cmd命令行。输入一下命令\n```\nmvn package -Dmaven.skip.test=true\n```\n出现如下结果，说明打包成功；\n![dubbo-admin编译打包](http://ozux0lqfa.bkt.clouddn.com/dubbo-admin%E7%BC%96%E8%AF%91%E6%88%90%E5%8A%9F%E6%95%88%E6%9E%9C.png)\n去`dubbo-admin`文件下的`target`目录找`dubbo-admin-2.5.8.war`的war包，把war改下名为`dubbo-admin`（方便后面浏览器访问）后扔到tomcat里面的webapps目录中，使用`startup.bat`启动tomcat。注意端口冲突。解决tomcat的端口冲突这里就不细讲了。\n**注意：**\n先启动zookeeper，再启动项目dubbo-admin的tomcat\n此处是我编译打好的war包：[dubbo-admin.war](http://download.csdn.net/download/shandianlala/10157122)\n\n### 三、测试安装效果\n打开浏览器输入`http://localhost:8080/dubbo-admin/`，提示需要输入用户名和密码。用户名和密码在部署`dubbo-admin`的tomcat目录里面。进入目录 `apache-tomcat-8.0.31\\webapps\\dubbo-admin\\WEB-INF` 中，打开`dubbo.properties`配置文件，文件内容如下：\n```\ndubbo.registry.address=zookeeper://127.0.0.1:2181\ndubbo.admin.root.password=root      #账户:root，密码:root\ndubbo.admin.guest.password=guest    #账户:guest，密码:guest\n```\n这里你随便选择一个账户密码进行登录就行。\n![dubbo-admin登录成功首页](http://ozux0lqfa.bkt.clouddn.com/dubbo-admin%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F%E5%90%8E%E9%A6%96%E9%A1%B5.png)\n\n**参考：**\nhttp://blog.csdn.net/evankaka/article/details/47858707#comments","source":"_posts/配置zookeeper的dubbo-admin管理平台.md","raw":"---\ntitle: 配置zookeeper的dubbo-admin管理平台\ntags:\n  - dubbo\n  - zookeeper\n  - dubbo-admin\nabbrlink: fda57de0\ndate: 2017-12-13 15:37:32\n---\n因为zookeeper的启动是通过命令来操控的，我们无法看到注册中心存在了哪些`provider(提供者)`或`consumer（消费者）`，这时就需要借助dubbo-admin可视化管理平台进行实时的查看，同时也可以通过这个平台来管理`provider(提供者)`或`consumer（消费者）`。\n<!-- more -->\n### 一、本机环境\n> jdk:1.8\n操作系统：windows 7\nzookeeper :zookeeper-3.4.8\ntomcat：apache-tomcat-8.0.31\ndubbo-version：2.5.8\nmaven：3.3.9\n\n### 二、dubbo-admin 源码下载、编译\n- 在github上下载dubbo源码，[alibaba/dubbo](https://github.com/alibaba/dubbo)，下载下来后进行解压，本文与2017年12月13日记录，后期dubbo版本的更新可能会影响本文所描述的效果呈现。下图是解压后的路径。\n![dubbo解压后的目录](http://ozux0lqfa.bkt.clouddn.com/dubbo-master%E8%A7%A3%E5%8E%8B%E5%90%8E%E7%9B%AE%E5%BD%95.png)\n- 进入 `dubbo-admin` 文件夹，点击文件夹外的空白处，按住 `shift` 键，鼠标点击右键，选择`在此处打开命令行窗口`，进入cmd命令行。输入一下命令\n```\nmvn package -Dmaven.skip.test=true\n```\n出现如下结果，说明打包成功；\n![dubbo-admin编译打包](http://ozux0lqfa.bkt.clouddn.com/dubbo-admin%E7%BC%96%E8%AF%91%E6%88%90%E5%8A%9F%E6%95%88%E6%9E%9C.png)\n去`dubbo-admin`文件下的`target`目录找`dubbo-admin-2.5.8.war`的war包，把war改下名为`dubbo-admin`（方便后面浏览器访问）后扔到tomcat里面的webapps目录中，使用`startup.bat`启动tomcat。注意端口冲突。解决tomcat的端口冲突这里就不细讲了。\n**注意：**\n先启动zookeeper，再启动项目dubbo-admin的tomcat\n此处是我编译打好的war包：[dubbo-admin.war](http://download.csdn.net/download/shandianlala/10157122)\n\n### 三、测试安装效果\n打开浏览器输入`http://localhost:8080/dubbo-admin/`，提示需要输入用户名和密码。用户名和密码在部署`dubbo-admin`的tomcat目录里面。进入目录 `apache-tomcat-8.0.31\\webapps\\dubbo-admin\\WEB-INF` 中，打开`dubbo.properties`配置文件，文件内容如下：\n```\ndubbo.registry.address=zookeeper://127.0.0.1:2181\ndubbo.admin.root.password=root      #账户:root，密码:root\ndubbo.admin.guest.password=guest    #账户:guest，密码:guest\n```\n这里你随便选择一个账户密码进行登录就行。\n![dubbo-admin登录成功首页](http://ozux0lqfa.bkt.clouddn.com/dubbo-admin%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F%E5%90%8E%E9%A6%96%E9%A1%B5.png)\n\n**参考：**\nhttp://blog.csdn.net/evankaka/article/details/47858707#comments","slug":"配置zookeeper的dubbo-admin管理平台","published":1,"updated":"2017-12-14T13:55:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2w200ze001nmwd324ava2r9","content":"<p>因为zookeeper的启动是通过命令来操控的，我们无法看到注册中心存在了哪些<code>provider(提供者)</code>或<code>consumer（消费者）</code>，这时就需要借助dubbo-admin可视化管理平台进行实时的查看，同时也可以通过这个平台来管理<code>provider(提供者)</code>或<code>consumer（消费者）</code>。<br><a id=\"more\"></a></p>\n<h3 id=\"一、本机环境\"><a href=\"#一、本机环境\" class=\"headerlink\" title=\"一、本机环境\"></a>一、本机环境</h3><blockquote>\n<p>jdk:1.8<br>操作系统：windows 7<br>zookeeper :zookeeper-3.4.8<br>tomcat：apache-tomcat-8.0.31<br>dubbo-version：2.5.8<br>maven：3.3.9</p>\n</blockquote>\n<h3 id=\"二、dubbo-admin-源码下载、编译\"><a href=\"#二、dubbo-admin-源码下载、编译\" class=\"headerlink\" title=\"二、dubbo-admin 源码下载、编译\"></a>二、dubbo-admin 源码下载、编译</h3><ul>\n<li>在github上下载dubbo源码，<a href=\"https://github.com/alibaba/dubbo\" target=\"_blank\" rel=\"noopener\">alibaba/dubbo</a>，下载下来后进行解压，本文与2017年12月13日记录，后期dubbo版本的更新可能会影响本文所描述的效果呈现。下图是解压后的路径。<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/dubbo-master%E8%A7%A3%E5%8E%8B%E5%90%8E%E7%9B%AE%E5%BD%95.png\" alt=\"dubbo解压后的目录\"></li>\n<li>进入 <code>dubbo-admin</code> 文件夹，点击文件夹外的空白处，按住 <code>shift</code> 键，鼠标点击右键，选择<code>在此处打开命令行窗口</code>，进入cmd命令行。输入一下命令<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn package -Dmaven.skip.test=true</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>出现如下结果，说明打包成功；<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/dubbo-admin%E7%BC%96%E8%AF%91%E6%88%90%E5%8A%9F%E6%95%88%E6%9E%9C.png\" alt=\"dubbo-admin编译打包\"><br>去<code>dubbo-admin</code>文件下的<code>target</code>目录找<code>dubbo-admin-2.5.8.war</code>的war包，把war改下名为<code>dubbo-admin</code>（方便后面浏览器访问）后扔到tomcat里面的webapps目录中，使用<code>startup.bat</code>启动tomcat。注意端口冲突。解决tomcat的端口冲突这里就不细讲了。<br><strong>注意：</strong><br>先启动zookeeper，再启动项目dubbo-admin的tomcat<br>此处是我编译打好的war包：<a href=\"http://download.csdn.net/download/shandianlala/10157122\" target=\"_blank\" rel=\"noopener\">dubbo-admin.war</a></p>\n<h3 id=\"三、测试安装效果\"><a href=\"#三、测试安装效果\" class=\"headerlink\" title=\"三、测试安装效果\"></a>三、测试安装效果</h3><p>打开浏览器输入<code>http://localhost:8080/dubbo-admin/</code>，提示需要输入用户名和密码。用户名和密码在部署<code>dubbo-admin</code>的tomcat目录里面。进入目录 <code>apache-tomcat-8.0.31\\webapps\\dubbo-admin\\WEB-INF</code> 中，打开<code>dubbo.properties</code>配置文件，文件内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dubbo.registry.address=zookeeper://127.0.0.1:2181</span><br><span class=\"line\">dubbo.admin.root.password=root      #账户:root，密码:root</span><br><span class=\"line\">dubbo.admin.guest.password=guest    #账户:guest，密码:guest</span><br></pre></td></tr></table></figure></p>\n<p>这里你随便选择一个账户密码进行登录就行。<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/dubbo-admin%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F%E5%90%8E%E9%A6%96%E9%A1%B5.png\" alt=\"dubbo-admin登录成功首页\"></p>\n<p><strong>参考：</strong><br><a href=\"http://blog.csdn.net/evankaka/article/details/47858707#comments\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/evankaka/article/details/47858707#comments</a></p>\n","site":{"data":{}},"excerpt":"<p>因为zookeeper的启动是通过命令来操控的，我们无法看到注册中心存在了哪些<code>provider(提供者)</code>或<code>consumer（消费者）</code>，这时就需要借助dubbo-admin可视化管理平台进行实时的查看，同时也可以通过这个平台来管理<code>provider(提供者)</code>或<code>consumer（消费者）</code>。<br>","more":"</p>\n<h3 id=\"一、本机环境\"><a href=\"#一、本机环境\" class=\"headerlink\" title=\"一、本机环境\"></a>一、本机环境</h3><blockquote>\n<p>jdk:1.8<br>操作系统：windows 7<br>zookeeper :zookeeper-3.4.8<br>tomcat：apache-tomcat-8.0.31<br>dubbo-version：2.5.8<br>maven：3.3.9</p>\n</blockquote>\n<h3 id=\"二、dubbo-admin-源码下载、编译\"><a href=\"#二、dubbo-admin-源码下载、编译\" class=\"headerlink\" title=\"二、dubbo-admin 源码下载、编译\"></a>二、dubbo-admin 源码下载、编译</h3><ul>\n<li>在github上下载dubbo源码，<a href=\"https://github.com/alibaba/dubbo\" target=\"_blank\" rel=\"noopener\">alibaba/dubbo</a>，下载下来后进行解压，本文与2017年12月13日记录，后期dubbo版本的更新可能会影响本文所描述的效果呈现。下图是解压后的路径。<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/dubbo-master%E8%A7%A3%E5%8E%8B%E5%90%8E%E7%9B%AE%E5%BD%95.png\" alt=\"dubbo解压后的目录\"></li>\n<li>进入 <code>dubbo-admin</code> 文件夹，点击文件夹外的空白处，按住 <code>shift</code> 键，鼠标点击右键，选择<code>在此处打开命令行窗口</code>，进入cmd命令行。输入一下命令<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn package -Dmaven.skip.test=true</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>出现如下结果，说明打包成功；<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/dubbo-admin%E7%BC%96%E8%AF%91%E6%88%90%E5%8A%9F%E6%95%88%E6%9E%9C.png\" alt=\"dubbo-admin编译打包\"><br>去<code>dubbo-admin</code>文件下的<code>target</code>目录找<code>dubbo-admin-2.5.8.war</code>的war包，把war改下名为<code>dubbo-admin</code>（方便后面浏览器访问）后扔到tomcat里面的webapps目录中，使用<code>startup.bat</code>启动tomcat。注意端口冲突。解决tomcat的端口冲突这里就不细讲了。<br><strong>注意：</strong><br>先启动zookeeper，再启动项目dubbo-admin的tomcat<br>此处是我编译打好的war包：<a href=\"http://download.csdn.net/download/shandianlala/10157122\" target=\"_blank\" rel=\"noopener\">dubbo-admin.war</a></p>\n<h3 id=\"三、测试安装效果\"><a href=\"#三、测试安装效果\" class=\"headerlink\" title=\"三、测试安装效果\"></a>三、测试安装效果</h3><p>打开浏览器输入<code>http://localhost:8080/dubbo-admin/</code>，提示需要输入用户名和密码。用户名和密码在部署<code>dubbo-admin</code>的tomcat目录里面。进入目录 <code>apache-tomcat-8.0.31\\webapps\\dubbo-admin\\WEB-INF</code> 中，打开<code>dubbo.properties</code>配置文件，文件内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dubbo.registry.address=zookeeper://127.0.0.1:2181</span><br><span class=\"line\">dubbo.admin.root.password=root      #账户:root，密码:root</span><br><span class=\"line\">dubbo.admin.guest.password=guest    #账户:guest，密码:guest</span><br></pre></td></tr></table></figure></p>\n<p>这里你随便选择一个账户密码进行登录就行。<br><img src=\"http://ozux0lqfa.bkt.clouddn.com/dubbo-admin%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F%E5%90%8E%E9%A6%96%E9%A1%B5.png\" alt=\"dubbo-admin登录成功首页\"></p>\n<p><strong>参考：</strong><br><a href=\"http://blog.csdn.net/evankaka/article/details/47858707#comments\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/evankaka/article/details/47858707#comments</a></p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ck2w200sl0001mwd3c00on2rj","tag_id":"ck2w200tf0003mwd36zzs7ydf","_id":"ck2w200uc0008mwd3dve5cmd4"},{"post_id":"ck2w200t40002mwd3s1lt7zex","tag_id":"ck2w200u80007mwd3h77gd576","_id":"ck2w200vt000gmwd3gegas0sh"},{"post_id":"ck2w200t40002mwd3s1lt7zex","tag_id":"ck2w200v7000bmwd3ywlr7ecd","_id":"ck2w200vy000imwd3vhou8pze"},{"post_id":"ck2w200vh000dmwd39xe0ly6j","tag_id":"ck2w200tf0003mwd36zzs7ydf","_id":"ck2w200w6000lmwd3xj3j5olw"},{"post_id":"ck2w200tn0004mwd37isr0qlg","tag_id":"ck2w200vn000emwd3zgt6uc7x","_id":"ck2w200wa000nmwd3v95v58vy"},{"post_id":"ck2w200wt000tmwd3kw0b6mll","tag_id":"ck2w200vz000jmwd37b4xob51","_id":"ck2w200x3000wmwd3dcyv92wt"},{"post_id":"ck2w200tx0005mwd3moqs87z6","tag_id":"ck2w200vz000jmwd37b4xob51","_id":"ck2w200x8000ymwd394k4didd"},{"post_id":"ck2w200tx0005mwd3moqs87z6","tag_id":"ck2w200wf000pmwd3am3bcdtk","_id":"ck2w200xd0010mwd3i8a180mn"},{"post_id":"ck2w200tx0005mwd3moqs87z6","tag_id":"ck2w200wr000smwd37tb3642f","_id":"ck2w200xj0013mwd3lc2nxg6y"},{"post_id":"ck2w200u20006mwd3d5yo1fkk","tag_id":"ck2w200x3000vmwd36t408ztk","_id":"ck2w200xo0015mwd3zgfphmsv"},{"post_id":"ck2w200xe0012mwd33i5cukck","tag_id":"ck2w200tf0003mwd36zzs7ydf","_id":"ck2w200y10018mwd33bgddqsv"},{"post_id":"ck2w200ue0009mwd330ggsnqq","tag_id":"ck2w200xd0011mwd395oi32rb","_id":"ck2w200ya001amwd36vr1futm"},{"post_id":"ck2w200v2000amwd3c5gikuf3","tag_id":"ck2w200vz000jmwd37b4xob51","_id":"ck2w200z0001hmwd3qxzskw6o"},{"post_id":"ck2w200v2000amwd3c5gikuf3","tag_id":"ck2w200yf001cmwd3kfb4zi1c","_id":"ck2w200z5001jmwd3ga07o5z4"},{"post_id":"ck2w200z2001imwd3gblsgj89","tag_id":"ck2w200tf0003mwd36zzs7ydf","_id":"ck2w200zd001mmwd3hjtj5tcy"},{"post_id":"ck2w200z8001lmwd3lcnthn17","tag_id":"ck2w200tf0003mwd36zzs7ydf","_id":"ck2w200zk001pmwd3djfigd10"},{"post_id":"ck2w200vb000cmwd3gw9rf1vo","tag_id":"ck2w200vz000jmwd37b4xob51","_id":"ck2w200zl001qmwd3avgn8krh"},{"post_id":"ck2w200vb000cmwd3gw9rf1vo","tag_id":"ck2w200yf001cmwd3kfb4zi1c","_id":"ck2w200zn001smwd3e1l2vmxm"},{"post_id":"ck2w200vp000fmwd3kd36217v","tag_id":"ck2w200zj001omwd3tx4fntfo","_id":"ck2w200zo001tmwd3yuw9nut8"},{"post_id":"ck2w200w7000mmwd3jv113d2e","tag_id":"ck2w200zm001rmwd3rx3x56pd","_id":"ck2w200zt001wmwd3v7u2dalm"},{"post_id":"ck2w200w7000mmwd3jv113d2e","tag_id":"ck2w200zp001umwd3o0jr5vdy","_id":"ck2w200zu001xmwd3h7523n7y"},{"post_id":"ck2w200wc000omwd3wgmldymh","tag_id":"ck2w200v7000bmwd3ywlr7ecd","_id":"ck2w200zx001zmwd3b7su7sfw"},{"post_id":"ck2w200wc000omwd3wgmldymh","tag_id":"ck2w200zm001rmwd3rx3x56pd","_id":"ck2w200zy0020mwd3s5plovcs"},{"post_id":"ck2w200wi000qmwd3fly6yg02","tag_id":"ck2w200zm001rmwd3rx3x56pd","_id":"ck2w201000022mwd3jmarsmt9"},{"post_id":"ck2w200wo000rmwd3el17fc07","tag_id":"ck2w200zz0021mwd3s4gkax7k","_id":"ck2w201030025mwd3ap2ce85w"},{"post_id":"ck2w200wo000rmwd3el17fc07","tag_id":"ck2w200vz000jmwd37b4xob51","_id":"ck2w201040026mwd3ernr1fyc"},{"post_id":"ck2w200wo000rmwd3el17fc07","tag_id":"ck2w201010023mwd30mfyg19j","_id":"ck2w201060028mwd3e4lp6xtg"},{"post_id":"ck2w200wy000umwd300xub7cy","tag_id":"ck2w200vz000jmwd37b4xob51","_id":"ck2w201080029mwd3dd4qyes3"},{"post_id":"ck2w200wy000umwd300xub7cy","tag_id":"ck2w200wf000pmwd3am3bcdtk","_id":"ck2w2010b002bmwd3mlleb83q"},{"post_id":"ck2w200wy000umwd300xub7cy","tag_id":"ck2w201020024mwd3difyn5jd","_id":"ck2w2010c002cmwd30h6x699r"},{"post_id":"ck2w200x4000xmwd35kwqv8ge","tag_id":"ck2w200vz000jmwd37b4xob51","_id":"ck2w2010f002emwd3dttmg8jn"},{"post_id":"ck2w200x4000xmwd35kwqv8ge","tag_id":"ck2w200wf000pmwd3am3bcdtk","_id":"ck2w2010g002fmwd3ksq898a7"},{"post_id":"ck2w200x4000xmwd35kwqv8ge","tag_id":"ck2w201040027mwd3stn5jv0f","_id":"ck2w2010h002gmwd3zpomwac1"},{"post_id":"ck2w200x9000zmwd3bvwccd0b","tag_id":"ck2w20109002amwd32il6t54l","_id":"ck2w2010i002imwd3hz6kdtmc"},{"post_id":"ck2w200xk0014mwd3eg71a7ip","tag_id":"ck2w200vz000jmwd37b4xob51","_id":"ck2w2010i002jmwd3bwss2nhk"},{"post_id":"ck2w200xk0014mwd3eg71a7ip","tag_id":"ck2w2010e002dmwd3o7joy6h5","_id":"ck2w2010j002lmwd3bhkjfzj6"},{"post_id":"ck2w200xp0016mwd357y5n4zo","tag_id":"ck2w200vz000jmwd37b4xob51","_id":"ck2w2010m002nmwd34difw0nn"},{"post_id":"ck2w200xp0016mwd357y5n4zo","tag_id":"ck2w2010h002hmwd3latvg07i","_id":"ck2w2010m002omwd39i5mm4c2"},{"post_id":"ck2w200xp0016mwd357y5n4zo","tag_id":"ck2w2010i002kmwd3s8c41y33","_id":"ck2w2010o002qmwd3yzuh3csz"},{"post_id":"ck2w200y10019mwd3wq0ieo5o","tag_id":"ck2w200vz000jmwd37b4xob51","_id":"ck2w2010s002smwd3e6dkpnjl"},{"post_id":"ck2w200y10019mwd3wq0ieo5o","tag_id":"ck2w2010k002mmwd35dv56bw8","_id":"ck2w2010t002tmwd34zsp5ub4"},{"post_id":"ck2w200y10019mwd3wq0ieo5o","tag_id":"ck2w2010n002pmwd3tu1egt7t","_id":"ck2w2010v002vmwd3fi23z3vg"},{"post_id":"ck2w200yb001bmwd3ysys6l5d","tag_id":"ck2w200vz000jmwd37b4xob51","_id":"ck2w2010v002wmwd3269af8tl"},{"post_id":"ck2w200yb001bmwd3ysys6l5d","tag_id":"ck2w2010p002rmwd3uwartl9n","_id":"ck2w2010y002ymwd3l8xlia1u"},{"post_id":"ck2w200yi001dmwd35ji85bgs","tag_id":"ck2w200yf001cmwd3kfb4zi1c","_id":"ck2w2010y002zmwd33h4fawr7"},{"post_id":"ck2w200yi001dmwd35ji85bgs","tag_id":"ck2w2010t002umwd3sxc60kxx","_id":"ck2w201100031mwd3kkv2cwgj"},{"post_id":"ck2w200ym001emwd3nb3tykv8","tag_id":"ck2w2010w002xmwd3o74oyhuq","_id":"ck2w201120032mwd365vezelz"},{"post_id":"ck2w200yw001gmwd3t96xqe7p","tag_id":"ck2w2010e002dmwd3o7joy6h5","_id":"ck2w201180035mwd3htj0ra40"},{"post_id":"ck2w200yw001gmwd3t96xqe7p","tag_id":"ck2w201140033mwd31lpwt58v","_id":"ck2w201180036mwd3pkp6t5fe"},{"post_id":"ck2w200ze001nmwd324ava2r9","tag_id":"ck2w200wr000smwd37tb3642f","_id":"ck2w2011b0038mwd3r75z6led"},{"post_id":"ck2w200ze001nmwd324ava2r9","tag_id":"ck2w201150034mwd342ggf7qe","_id":"ck2w2011c0039mwd3ugzr0oko"},{"post_id":"ck2w200ze001nmwd324ava2r9","tag_id":"ck2w201190037mwd3n0wab0o8","_id":"ck2w2011c003amwd3y8pru35n"}],"Tag":[{"name":"生活感想","_id":"ck2w200tf0003mwd36zzs7ydf"},{"name":"IntelliJ IDEA","_id":"ck2w200u80007mwd3h77gd576"},{"name":"配置","_id":"ck2w200v7000bmwd3ywlr7ecd"},{"name":"MarkDown命令","_id":"ck2w200vn000emwd3zgt6uc7x"},{"name":"JAVA","_id":"ck2w200vz000jmwd37b4xob51"},{"name":"框架","_id":"ck2w200wf000pmwd3am3bcdtk"},{"name":"dubbo","_id":"ck2w200wr000smwd37tb3642f"},{"name":"java虚拟机","_id":"ck2w200x3000vmwd36t408ztk"},{"name":"算法","_id":"ck2w200xd0011mwd395oi32rb"},{"name":"jdk源码","_id":"ck2w200yf001cmwd3kfb4zi1c"},{"name":"ZooKeeper","_id":"ck2w200zj001omwd3tx4fntfo"},{"name":"hexo博客配置","_id":"ck2w200zm001rmwd3rx3x56pd"},{"name":"教程","_id":"ck2w200zp001umwd3o0jr5vdy"},{"name":"乱码","_id":"ck2w200zz0021mwd3s4gkax7k"},{"name":"HTTP","_id":"ck2w201010023mwd30mfyg19j"},{"name":"mybatis","_id":"ck2w201020024mwd3difyn5jd"},{"name":"shiro","_id":"ck2w201040027mwd3stn5jv0f"},{"name":"电影","_id":"ck2w20109002amwd32il6t54l"},{"name":"面试","_id":"ck2w2010e002dmwd3o7joy6h5"},{"name":"Tomcat","_id":"ck2w2010h002hmwd3latvg07i"},{"name":"nginx","_id":"ck2w2010i002kmwd3s8c41y33"},{"name":"Linux","_id":"ck2w2010k002mmwd35dv56bw8"},{"name":"web","_id":"ck2w2010n002pmwd3tu1egt7t"},{"name":"单词","_id":"ck2w2010p002rmwd3uwartl9n"},{"name":"数据结构","_id":"ck2w2010t002umwd3sxc60kxx"},{"name":"数据结构算法","_id":"ck2w2010w002xmwd3o74oyhuq"},{"name":"感想","_id":"ck2w201140033mwd31lpwt58v"},{"name":"zookeeper","_id":"ck2w201150034mwd342ggf7qe"},{"name":"dubbo-admin","_id":"ck2w201190037mwd3n0wab0o8"}]}}